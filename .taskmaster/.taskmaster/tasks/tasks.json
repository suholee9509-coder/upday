{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Define Core Types, Constants, and Utilities",
        "description": "Establish the foundational TypeScript types, shared constants, and utility functions that all subsequent development will depend on.",
        "details": "Create the following files in the project structure:\n\n1. `types/news.ts` - Core type definitions:\n```typescript\nexport type Category = 'ai' | 'startup' | 'science' | 'design' | 'space' | 'dev';\n\nexport interface NewsItem {\n  id: string;\n  title: string;\n  summary: string;\n  body: string;\n  category: Category;\n  source: string;\n  sourceUrl: string;\n  publishedAt: string; // ISO 8601, UTC\n  createdAt: string;\n}\n\nexport interface NewsQueryParams {\n  limit?: number; // default 20\n  cursor?: string; // publishedAt of last item\n  category?: Category;\n  q?: string; // search query\n}\n\nexport interface NewsResponse {\n  items: Omit<NewsItem, 'body'>[]; // body not sent to client\n  hasMore: boolean;\n}\n```\n\n2. `lib/constants.ts` - Shared constants:\n```typescript\nexport const CATEGORIES: { id: Category; label: string; coverage: string }[] = [\n  { id: 'ai', label: 'AI', coverage: 'Artificial intelligence, machine learning, LLMs' },\n  { id: 'startup', label: 'Startup', coverage: 'Startups, funding, M&A' },\n  { id: 'science', label: 'Science', coverage: 'Scientific research, medical breakthroughs' },\n  { id: 'design', label: 'Design', coverage: 'Product design, UX, visual design' },\n  { id: 'space', label: 'Space', coverage: 'Space exploration, aerospace' },\n  { id: 'dev', label: 'Dev', coverage: 'Software development, open source, infrastructure' },\n];\n\nexport const DEFAULT_PAGE_SIZE = 20;\nexport const DEBOUNCE_MS = 300;\n```\n\n3. `lib/utils.ts` - Utility functions:\n```typescript\nimport { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function formatRelativeTime(dateString: string): string {\n  const date = new Date(dateString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffHours = diffMs / (1000 * 60 * 60);\n  \n  if (diffHours < 24) {\n    const hours = Math.floor(diffHours);\n    if (hours < 1) {\n      const minutes = Math.floor(diffMs / (1000 * 60));\n      return `${minutes}m ago`;\n    }\n    return `${hours}h ago`;\n  }\n  \n  return date.toLocaleDateString('en-US', {\n    month: 'numeric',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n  });\n}\n\nexport function formatDateSeparator(dateString: string): string {\n  const date = new Date(dateString);\n  return date.toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  });\n}\n\nexport function isSameDay(date1: string, date2: string): boolean {\n  const d1 = new Date(date1);\n  const d2 = new Date(date2);\n  return d1.toDateString() === d2.toDateString();\n}\n```",
        "testStrategy": "Unit tests for all utility functions:\n- Test `cn()` merges Tailwind classes correctly\n- Test `formatRelativeTime()` returns '5m ago' for 5 minutes, '3h ago' for 3 hours, and absolute format for >24h\n- Test `formatDateSeparator()` returns correct format like 'Monday, February 2, 2026'\n- Test `isSameDay()` correctly identifies same/different days\n- Verify TypeScript types compile without errors\n- Test edge cases: midnight boundaries, timezone handling",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create types/news.ts with core TypeScript definitions",
            "description": "Implement the specified NewsItem, NewsQueryParams, NewsResponse interfaces and Category type union in the types/news.ts file.",
            "dependencies": [],
            "details": "Copy the exact TypeScript code provided for types/news.ts including all interfaces and type definitions. Ensure proper export statements and JSDoc comments where specified. Verify type safety with TypeScript compiler.",
            "status": "pending",
            "testStrategy": "Run tsc to verify no type errors. Check that Category is properly constrained to the 6 literal values. Validate that NewsResponse omits 'body' field correctly using TypeScript's Omit utility.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement lib/constants.ts with shared application constants",
            "description": "Create the constants file containing CATEGORIES array, DEFAULT_PAGE_SIZE, and DEBOUNCE_MS values as specified.",
            "dependencies": [
              1
            ],
            "details": "Implement the exact CATEGORIES array with id, label, and coverage fields for all 6 categories. Define DEFAULT_PAGE_SIZE = 20 and DEBOUNCE_MS = 300. Ensure all constants are properly exported for use across the application.",
            "status": "pending",
            "testStrategy": "Verify CATEGORIES array contains exactly 6 items matching Category type. Confirm DEFAULT_PAGE_SIZE equals 20 and DEBOUNCE_MS equals 300 through console.log or unit tests.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Tailwind utility function cn to lib/utils.ts",
            "description": "Implement the class name merging utility using clsx and twMerge for consistent Tailwind class handling.",
            "dependencies": [
              1
            ],
            "details": "Install clsx and tailwind-merge if not present. Implement cn function that accepts variable ClassValue arguments and returns twMerge(clsx(inputs)). This will be used throughout all UI components.",
            "status": "pending",
            "testStrategy": "Test cn('bg-red-500', 'text-white', 'hover:bg-red-600') returns properly merged classes. Verify it handles conditional classes like { 'md:hidden': true } correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement date formatting utilities in lib/utils.ts",
            "description": "Add formatRelativeTime, formatDateSeparator, and isSameDay functions for consistent date handling across the application.",
            "dependencies": [
              1
            ],
            "details": "Implement all three utility functions exactly as specified: relative time formatting (<24h shows Xm/h ago, >24h shows date), full date separator formatting, and same-day comparison logic using Date objects.",
            "status": "pending",
            "testStrategy": "Unit tests: formatRelativeTime('5min ago')→'5m ago', '3h ago'→'3h ago', '2days ago'→'2/2 9:00'; formatDateSeparator returns 'Monday, February 2, 2026'; isSameDay works for same vs different days.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify TypeScript compilation and foundational setup",
            "description": "Run full TypeScript compilation check and update tsconfig.json paths to ensure all new types/constants/utils are properly referenced.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Execute 'npx tsc --noEmit' to validate all new files compile without errors. Update tsconfig.json paths to include 'types/**/*' and 'lib/**/*'. Verify project references if using multiple tsconfig files.",
            "status": "pending",
            "testStrategy": "tsc --noEmit passes with no errors. Verify intellisense recognizes all new types in other files. Confirm CATEGORIES constant autocompletes Category values correctly.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:07:42.239Z"
      },
      {
        "id": 12,
        "title": "Setup Design System and Base Components",
        "description": "Add ThemeProvider and ThemeToggle components for light/dark mode switching, and create a Skeleton component matching the existing Monet theme design system. Existing components (Button, Badge, Card, Input), cn() utility, and CSS variables are already implemented.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Existing infrastructure already in place:\n- `src/components/ui/` contains Monet theme-based Button, Badge, Card, Input components\n- `src/lib/utils.ts` has cn() function for class merging\n- `src/index.css` has oklch-based design system CSS variables for light/dark modes\n\nRemaining tasks:\n\n1. Install next-themes for theme management:\n```bash\nnpm install next-themes\n```\n\n2. Create `src/components/ui/theme-provider.tsx` for dark mode:\n```typescript\n'use client';\nimport { ThemeProvider as NextThemesProvider } from 'next-themes';\nimport { type ThemeProviderProps } from 'next-themes/dist/types';\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;\n}\n```\n\n3. Create `src/components/ui/theme-toggle.tsx`:\n```typescript\n'use client';\nimport { Moon, Sun } from 'lucide-react';\nimport { useTheme } from 'next-themes';\nimport { Button } from '@/components/ui/button';\n\nexport function ThemeToggle() {\n  const { theme, setTheme } = useTheme();\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}\n    >\n      <Sun className=\"h-5 w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" />\n      <Moon className=\"absolute h-5 w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" />\n      <span className=\"sr-only\">Toggle theme</span>\n    </Button>\n  );\n}\n```\n\n4. Create `src/components/ui/skeleton.tsx` matching Monet theme:\n```typescript\nimport { cn } from '@/lib/utils';\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn('animate-pulse rounded-md bg-muted', className)}\n      {...props}\n    />\n  );\n}\n\nexport { Skeleton };\n```\n\n5. Wrap app in ThemeProvider in `app/layout.tsx` with `attribute=\"class\"` and `defaultTheme=\"system\"`.",
        "testStrategy": "Visual testing:\n- Verify ThemeProvider correctly wraps the application\n- Test theme toggle switches between light/dark modes\n- Verify existing CSS variables (oklch-based) are applied correctly when theme changes\n- Test Skeleton component renders with proper animation and matches Monet theme styling\n- Verify ThemeToggle button uses existing Button component correctly\n- Accessibility: verify color contrast meets WCAG AA standards in both modes\n- Test system theme preference detection works on initial load",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ThemeProvider component for Next.js themes",
            "description": "Implement src/components/ui/theme-provider.tsx wrapper using next-themes to enable theme management across the application.",
            "dependencies": [],
            "details": "Install next-themes package and create the file with the provided TypeScript code importing NextThemesProvider, typing ThemeProviderProps, and rendering children within the provider. Use 'use client' directive for client-side rendering.",
            "status": "pending",
            "testStrategy": "Verify component exports correctly and wraps children; check no TypeScript errors and proper client-side rendering with 'use client' directive.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ThemeToggle button component",
            "description": "Build src/components/ui/theme-toggle.tsx with Lucide icons and next-themes hook for toggling between light/dark modes, using the existing Monet-themed Button component.",
            "dependencies": [
              1
            ],
            "details": "Create the file using provided code with existing Button component from src/components/ui/button, useTheme hook, Sun/Moon icons with transition animations, and toggle logic based on current theme.",
            "status": "pending",
            "testStrategy": "Test button renders icons correctly; verify click toggles theme (check localStorage and class on html); confirm accessibility with sr-only span; ensure it uses existing Button component styling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Skeleton component matching Monet theme",
            "description": "Implement src/components/ui/skeleton.tsx component with pulse animation that matches the existing Monet design system styling.",
            "dependencies": [],
            "details": "Create Skeleton component using cn() from src/lib/utils.ts, applying animate-pulse, rounded-md, and bg-muted classes to match the existing oklch-based design tokens in src/index.css.",
            "status": "pending",
            "testStrategy": "Verify Skeleton renders with proper animation; test it uses correct muted color from existing CSS variables; confirm styling matches other Monet theme components.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate ThemeProvider into app layout",
            "description": "Update app/layout.tsx to wrap the entire application with ThemeProvider, enabling system theme detection and class-based switching.",
            "dependencies": [
              1
            ],
            "details": "Import ThemeProvider from src/components/ui/theme-provider, wrap {children} with <ThemeProvider attribute='class' defaultTheme='system'>{children}</ThemeProvider> in the root layout component.",
            "status": "pending",
            "testStrategy": "Verify layout renders without errors; test theme respects system preference on load; confirm manual toggle via ThemeToggle updates entire app; check existing oklch-based light/dark mode variables apply correctly.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:07:46.771Z"
      },
      {
        "id": 13,
        "title": "Setup Database Schema and Seed Data",
        "description": "Create the database schema for news items and populate with 50-100 seed articles to enable frontend development.",
        "details": "1. Choose and configure database (recommend Supabase for MVP):\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create database schema (SQL for Supabase):\n```sql\nCREATE TABLE news_items (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  title TEXT NOT NULL,\n  summary TEXT NOT NULL,\n  body TEXT NOT NULL,\n  category TEXT NOT NULL CHECK (category IN ('ai', 'startup', 'science', 'design', 'space', 'dev')),\n  source TEXT NOT NULL,\n  source_url TEXT NOT NULL UNIQUE,\n  published_at TIMESTAMPTZ NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_news_published_at ON news_items(published_at DESC);\nCREATE INDEX idx_news_category ON news_items(category);\nCREATE INDEX idx_news_search ON news_items USING GIN(to_tsvector('english', title || ' ' || summary));\n```\n\n3. Create `lib/db.ts` for database client:\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n\nexport const db = createClient(supabaseUrl, supabaseKey);\n```\n\n4. Create `scripts/seed.ts` with 50-100 realistic news items:\n```typescript\nimport { db } from '@/lib/db';\nimport { Category } from '@/types/news';\n\nconst seedData: Omit<NewsItem, 'id' | 'createdAt'>[] = [\n  {\n    title: 'OpenAI Announces GPT-5 with Enhanced Reasoning',\n    summary: 'OpenAI released GPT-5, featuring significantly improved reasoning capabilities and reduced hallucinations. The model shows 40% better performance on complex problem-solving benchmarks.',\n    body: '...full article text...',\n    category: 'ai',\n    source: 'TechCrunch',\n    sourceUrl: 'https://techcrunch.com/example-1',\n    publishedAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),\n  },\n  // ... 49-99 more items across all categories\n];\n\nasync function seed() {\n  const { error } = await db.from('news_items').insert(seedData);\n  if (error) throw error;\n  console.log('Seeded', seedData.length, 'news items');\n}\n\nseed();\n```\n\n5. Ensure seed data covers:\n- All 6 categories with roughly equal distribution\n- Various time ranges (last 7 days)\n- Different sources per category\n- Realistic titles and 2-3 line summaries",
        "testStrategy": "Database verification:\n- Run seed script and verify 50-100 rows inserted\n- Query by category and verify correct filtering\n- Query with cursor pagination and verify ordering\n- Test full-text search returns relevant results\n- Verify unique constraint on source_url prevents duplicates\n- Test index performance with EXPLAIN ANALYZE",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Supabase Client and Create Supabase Project",
            "description": "Install the Supabase JavaScript client via npm and create a new Supabase project in the dashboard with appropriate name, password, and region.",
            "dependencies": [],
            "details": "Run `npm install @supabase/supabase-js` and follow Supabase dashboard steps: sign in, click New Project, set name/password/region, wait for setup. Copy project URL and service role key for later use.",
            "status": "pending",
            "testStrategy": "Verify package.json includes @supabase/supabase-js and Supabase dashboard shows active project with Database section accessible.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create news_items Table Schema and Indexes",
            "description": "Execute the provided SQL in Supabase SQL Editor to create the news_items table with all specified columns, constraints, and indexes.",
            "dependencies": [
              1
            ],
            "details": "Use Table Editor or SQL Editor to run the CREATE TABLE news_items script including UUID id, title, summary, body, category CHECK constraint, source, source_url UNIQUE, published_at, created_at, plus three indexes for published_at, category, and full-text search.",
            "status": "pending",
            "testStrategy": "Verify table exists in Table Editor with correct columns/types/constraints; check indexes listed; test INSERT one row succeeds and violates UNIQUE source_url.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Database Client in lib/db.ts",
            "description": "Create the lib/db.ts file with Supabase client initialization using environment variables for URL and service role key.",
            "dependencies": [
              1
            ],
            "details": "Create lib/db.ts with import createClient, use NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY from process.env, export const db. Add env vars to .env.local from Supabase dashboard.",
            "status": "pending",
            "testStrategy": "Import and use db in a test script; verify client connects without errors by running a simple select('*') from news_items (should return empty array).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop Seed Script with 50-100 News Items",
            "description": "Create scripts/seed.ts importing db, define seedData array with 50-100 realistic news items covering all categories, then implement seed() function to insert data.",
            "dependencies": [
              2,
              3
            ],
            "details": "Structure seedData as array of objects matching schema (title, summary, body, category: ai/startup/science/design/space/dev equally ~8-17 each, source, unique source_url, published_at last 7 days). Include async seed() with db.from('news_items').insert(seedData) and error handling.",
            "status": "pending",
            "testStrategy": "Run `tsx scripts/seed.ts`; verify console logs insertion count 50-100; check Supabase table row count matches.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run Seed Script and Verify Data Distribution",
            "description": "Execute the seed script and validate data meets requirements: category distribution, time ranges, unique sources, search functionality.",
            "dependencies": [
              4
            ],
            "details": "Run seed script via `npx tsx scripts/seed.ts`; query Supabase for row count per category (~equal), published_at spans 7 days, unique source_url, test full-text search index with sample query.",
            "status": "pending",
            "testStrategy": "SQL queries: SELECT COUNT(*) FROM news_items; SELECT category, COUNT(*) GROUP BY category; SELECT * FROM news_items WHERE to_tsvector('english', title || ' ' || summary) @@ to_tsquery('english', 'AI'); verify 50-100 total rows, balanced categories, relevant search results.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:16:41.206Z"
      },
      {
        "id": 14,
        "title": "Build News Card and Date Separator Components",
        "description": "Create the NewsCard component displaying title, summary, time, category badge, and source link, plus the DateSeparator component for timeline grouping.",
        "details": "1. Create `components/news/news-card.tsx`:\n```typescript\nimport { Badge } from '@/components/ui/badge';\nimport { ExternalLink } from 'lucide-react';\nimport { formatRelativeTime } from '@/lib/utils';\nimport { NewsItem, Category } from '@/types/news';\nimport { cn } from '@/lib/utils';\n\nconst categoryColors: Record<Category, string> = {\n  ai: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200',\n  startup: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',\n  science: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',\n  design: 'bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200',\n  space: 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200',\n  dev: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200',\n};\n\ninterface NewsCardProps {\n  item: Omit<NewsItem, 'body'>;\n}\n\nexport function NewsCard({ item }: NewsCardProps) {\n  return (\n    <article className=\"p-4 border-b border-border hover:bg-muted/50 transition-colors\">\n      {/* 1st: Title - highest visual weight */}\n      <h2 className=\"text-lg font-semibold text-foreground leading-tight mb-2\">\n        {item.title}\n      </h2>\n      \n      {/* 2nd: Summary - why it matters */}\n      <p className=\"text-muted-foreground text-sm leading-relaxed mb-3\">\n        {item.summary}\n      </p>\n      \n      {/* 3rd: Time + Category - metadata */}\n      <div className=\"flex items-center gap-3 mb-2\">\n        <time className=\"text-xs text-muted-foreground\">\n          {formatRelativeTime(item.publishedAt)}\n        </time>\n        <Badge variant=\"secondary\" className={cn('text-xs', categoryColors[item.category])}>\n          {item.category.toUpperCase()}\n        </Badge>\n      </div>\n      \n      {/* 4th: Source + Link - action */}\n      <a\n        href={item.sourceUrl}\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        className=\"inline-flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors\"\n      >\n        {item.source}\n        <ExternalLink className=\"h-3 w-3\" />\n      </a>\n    </article>\n  );\n}\n```\n\n2. Create `components/news/date-separator.tsx`:\n```typescript\nimport { formatDateSeparator } from '@/lib/utils';\n\ninterface DateSeparatorProps {\n  date: string;\n}\n\nexport function DateSeparator({ date }: DateSeparatorProps) {\n  return (\n    <div className=\"sticky top-0 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 px-4 py-2 border-b border-border\">\n      <span className=\"text-sm font-medium text-muted-foreground\">\n        {formatDateSeparator(date)}\n      </span>\n    </div>\n  );\n}\n```\n\n3. Create `components/news/news-card-skeleton.tsx` for loading state:\n```typescript\nimport { Skeleton } from '@/components/ui/skeleton';\n\nexport function NewsCardSkeleton() {\n  return (\n    <div className=\"p-4 border-b border-border\">\n      <Skeleton className=\"h-6 w-3/4 mb-2\" />\n      <Skeleton className=\"h-4 w-full mb-1\" />\n      <Skeleton className=\"h-4 w-2/3 mb-3\" />\n      <div className=\"flex items-center gap-3\">\n        <Skeleton className=\"h-4 w-16\" />\n        <Skeleton className=\"h-5 w-12 rounded-full\" />\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "Component testing:\n- Render NewsCard with mock data and verify all 4 information hierarchy levels display correctly\n- Test relative time displays '3h ago' for recent items\n- Test absolute time displays for items >24h old\n- Verify category badge shows correct color per category\n- Test external link opens in new tab with correct attributes\n- Test DateSeparator displays formatted date with day of week\n- Verify skeleton matches card dimensions\n- Visual regression testing for light/dark modes\n- Accessibility: verify semantic HTML (article, time, heading levels)",
        "priority": "high",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NewsCard Component File",
            "description": "Create the NewsCard component file at components/news/news-card.tsx with all provided code including imports, category colors, and UI structure.",
            "dependencies": [],
            "details": "Copy the complete NewsCard code including Badge import, ExternalLink icon, formatRelativeTime utility, NewsItem type, cn utility, categoryColors mapping, and the full article JSX structure with title, summary, time/category metadata, and source link.",
            "status": "pending",
            "testStrategy": "Verify component renders without errors, displays all 4 hierarchy levels (title, summary, metadata, link), and applies correct Tailwind classes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create DateSeparator Component File",
            "description": "Create the DateSeparator component at components/news/date-separator.tsx using the provided sticky header implementation.",
            "dependencies": [],
            "details": "Implement the sticky top-0 div with backdrop-blur effects, background opacity handling, padding, border, and formatDateSeparator utility call for displaying formatted dates.",
            "status": "pending",
            "testStrategy": "Test renders correct date format, verify sticky positioning works, check backdrop-blur support fallback, and confirm dark mode text color.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create NewsCardSkeleton Loading Component",
            "description": "Build the NewsCardSkeleton component at components/news/news-card-skeleton.tsx matching the NewsCard layout for loading states.",
            "dependencies": [],
            "details": "Use Skeleton components to mimic exact layout: h-6 title, h-4 summary lines, time/badge placeholders with correct widths, rounded-full badge, maintaining border-b spacing.",
            "status": "pending",
            "testStrategy": "Verify skeleton matches NewsCard dimensions exactly, test shimmer animation if configured, ensure proper spacing and responsive widths.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify Dependencies and Utilities Exist",
            "description": "Ensure all required utilities, types, and UI components referenced in the news components are available and functional.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Check formatRelativeTime, formatDateSeparator in lib/utils.ts exist and work correctly; verify NewsItem/Category types in types/news.ts; confirm Badge, Skeleton, ExternalLink imports resolve.",
            "status": "pending",
            "testStrategy": "Run type checking (tsc), test utility functions with sample data, verify all imports resolve without errors, check categoryColors type safety.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write and Run Component Tests",
            "description": "Implement comprehensive tests for all three news components following the specified test strategy.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Test NewsCard: mock NewsItem data, verify rendering hierarchy, relative time formatting, category colors, link attributes. Test DateSeparator: various date strings. Test Skeleton: layout matching.",
            "status": "pending",
            "testStrategy": "Jest/RTL tests: render each component with mocks, snapshot testing, visual regression for category badges, time formatting edge cases (recent/older), accessibility checks.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:07:52.634Z"
      },
      {
        "id": 15,
        "title": "Build Timeline Feed with Pagination and Filter Bar",
        "description": "Create the main timeline feed component with date grouping, cursor-based pagination, category filter chips, and URL state synchronization.",
        "details": "1. Create `app/api/news/route.ts` - Timeline API:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { db } from '@/lib/db';\nimport { NewsQueryParams, NewsResponse, Category } from '@/types/news';\nimport { DEFAULT_PAGE_SIZE } from '@/lib/constants';\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const limit = parseInt(searchParams.get('limit') || String(DEFAULT_PAGE_SIZE));\n  const cursor = searchParams.get('cursor');\n  const category = searchParams.get('category') as Category | null;\n  const q = searchParams.get('q');\n\n  let query = db\n    .from('news_items')\n    .select('id, title, summary, category, source, source_url, published_at, created_at')\n    .order('published_at', { ascending: false })\n    .limit(limit + 1); // +1 to check hasMore\n\n  if (cursor) {\n    query = query.lt('published_at', cursor);\n  }\n\n  if (category) {\n    query = query.eq('category', category);\n  }\n\n  if (q) {\n    query = query.textSearch('title', q, { type: 'websearch' });\n  }\n\n  const { data, error } = await query;\n  if (error) throw error;\n\n  const hasMore = data.length > limit;\n  const items = data.slice(0, limit).map(row => ({\n    id: row.id,\n    title: row.title,\n    summary: row.summary,\n    category: row.category,\n    source: row.source,\n    sourceUrl: row.source_url,\n    publishedAt: row.published_at,\n    createdAt: row.created_at,\n  }));\n\n  return NextResponse.json({ items, hasMore } as NewsResponse);\n}\n```\n\n2. Create `components/news/filter-bar.tsx`:\n```typescript\n'use client';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport { CATEGORIES } from '@/lib/constants';\nimport { cn } from '@/lib/utils';\n\nexport function FilterBar() {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const currentCategory = searchParams.get('category');\n  const isSearchActive = searchParams.has('q');\n\n  const handleFilter = (categoryId: string | null) => {\n    const params = new URLSearchParams(searchParams);\n    if (categoryId) {\n      params.set('category', categoryId);\n    } else {\n      params.delete('category');\n    }\n    router.push(`/timeline?${params.toString()}`);\n  };\n\n  return (\n    <div className={cn(\n      'sticky top-0 z-10 bg-background border-b border-border px-4 py-3',\n      'overflow-x-auto flex gap-2 scrollbar-hide',\n      isSearchActive && 'opacity-50 pointer-events-none'\n    )}>\n      <Button\n        variant={!currentCategory ? 'default' : 'outline'}\n        size=\"sm\"\n        onClick={() => handleFilter(null)}\n      >\n        All\n      </Button>\n      {CATEGORIES.map((cat) => (\n        <Button\n          key={cat.id}\n          variant={currentCategory === cat.id ? 'default' : 'outline'}\n          size=\"sm\"\n          onClick={() => handleFilter(cat.id)}\n        >\n          {cat.label}\n        </Button>\n      ))}\n    </div>\n  );\n}\n```\n\n3. Create `components/news/timeline-feed.tsx`:\n```typescript\n'use client';\nimport { useState, useEffect } from 'react';\nimport { useSearchParams } from 'next/navigation';\nimport { NewsCard } from './news-card';\nimport { DateSeparator } from './date-separator';\nimport { NewsCardSkeleton } from './news-card-skeleton';\nimport { Button } from '@/components/ui/button';\nimport { NewsResponse } from '@/types/news';\nimport { isSameDay } from '@/lib/utils';\n\nexport function TimelineFeed({ initialData }: { initialData: NewsResponse }) {\n  const searchParams = useSearchParams();\n  const [items, setItems] = useState(initialData.items);\n  const [hasMore, setHasMore] = useState(initialData.hasMore);\n  const [loading, setLoading] = useState(false);\n\n  // Reset on filter/search change\n  useEffect(() => {\n    setItems(initialData.items);\n    setHasMore(initialData.hasMore);\n  }, [initialData]);\n\n  const loadMore = async () => {\n    if (!hasMore || loading) return;\n    setLoading(true);\n    const lastItem = items[items.length - 1];\n    const params = new URLSearchParams(searchParams);\n    params.set('cursor', lastItem.publishedAt);\n    \n    const res = await fetch(`/api/news?${params.toString()}`);\n    const data: NewsResponse = await res.json();\n    \n    setItems([...items, ...data.items]);\n    setHasMore(data.hasMore);\n    setLoading(false);\n  };\n\n  // Group items by date\n  const groupedItems: { date: string; items: typeof items }[] = [];\n  items.forEach((item) => {\n    const lastGroup = groupedItems[groupedItems.length - 1];\n    if (!lastGroup || !isSameDay(lastGroup.date, item.publishedAt)) {\n      groupedItems.push({ date: item.publishedAt, items: [item] });\n    } else {\n      lastGroup.items.push(item);\n    }\n  });\n\n  if (items.length === 0) {\n    return <EmptyState type={searchParams.has('q') ? 'search' : 'filter'} />;\n  }\n\n  return (\n    <div className=\"max-w-2xl mx-auto\">\n      {groupedItems.map((group) => (\n        <div key={group.date}>\n          <DateSeparator date={group.date} />\n          {group.items.map((item) => (\n            <NewsCard key={item.id} item={item} />\n          ))}\n        </div>\n      ))}\n      {hasMore && (\n        <div className=\"p-4 text-center\">\n          <Button onClick={loadMore} disabled={loading} variant=\"outline\">\n            {loading ? 'Loading...' : 'Load more'}\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction EmptyState({ type }: { type: 'search' | 'filter' }) {\n  return (\n    <div className=\"text-center py-12 text-muted-foreground\">\n      {type === 'search' \n        ? 'No results found. Try a different search term.'\n        : 'No news in this category yet.'}\n    </div>\n  );\n}\n```\n\n4. Create `app/timeline/page.tsx`:\n```typescript\nimport { FilterBar } from '@/components/news/filter-bar';\nimport { TimelineFeed } from '@/components/news/timeline-feed';\nimport { Header } from '@/components/layout/header';\n\nexport default async function TimelinePage({ searchParams }: { searchParams: { category?: string; q?: string } }) {\n  const params = new URLSearchParams();\n  if (searchParams.category) params.set('category', searchParams.category);\n  if (searchParams.q) params.set('q', searchParams.q);\n  \n  const res = await fetch(`${process.env.NEXT_PUBLIC_URL}/api/news?${params.toString()}`, { cache: 'no-store' });\n  const initialData = await res.json();\n\n  return (\n    <div className=\"min-h-screen bg-background\">\n      <Header />\n      <FilterBar />\n      <main>\n        <TimelineFeed initialData={initialData} />\n      </main>\n    </div>\n  );\n}\n```",
        "testStrategy": "Integration testing:\n- Test initial load displays 20 items grouped by date\n- Test 'Load more' button fetches next page with correct cursor\n- Test category filter updates URL and filters results\n- Test scroll resets to top on filter change\n- Test empty state displays for no results\n- Test filter bar is disabled during search\n- Test URL state is preserved on page refresh\n- Test back button navigation works correctly\n- Performance: verify LCP < 2 seconds\n- Mobile: test horizontal scroll on filter chips",
        "priority": "high",
        "dependencies": [
          "13",
          "14"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Timeline API Endpoint",
            "description": "Create the API route at app/api/news/route.ts to handle cursor-based pagination, category filtering, and search queries for the timeline feed.",
            "dependencies": [],
            "details": "Complete the provided API code ensuring proper cursor pagination with published_at, category filtering, full-text search on title, and return NewsResponse format with items and hasMore flag. Handle errors and validate parameters.",
            "status": "pending",
            "testStrategy": "Test API returns 20 items initially, correct cursor pagination, category filtering works, search returns relevant results, hasMore flag accurate",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build Filter Bar Component",
            "description": "Create components/news/filter-bar.tsx with category filter chips that update URL search params and sync with router.",
            "dependencies": [],
            "details": "Implement sticky filter bar with 'All' button and category chips using shadcn Button. Handle URL state synchronization, disable filters during search, and apply correct active states based on current category.",
            "status": "pending",
            "testStrategy": "Test filter buttons update URL params correctly, active states reflect current category, filters disabled during search, sticky positioning works",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop Timeline Feed Component",
            "description": "Create components/news/timeline-feed.tsx with date grouping, infinite scroll pagination, and empty states.",
            "dependencies": [],
            "details": "Implement client-side pagination with loadMore function using cursor from last item, group items by date using isSameDay utility, render NewsCard components, show empty states for search/filter, and handle loading states.",
            "status": "pending",
            "testStrategy": "Test date grouping works correctly, load more fetches next page, resets on filter change, empty states display appropriately, loading states smooth",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Timeline Page Layout",
            "description": "Build app/timeline/page.tsx to orchestrate Header, FilterBar, and TimelineFeed with SSR initial data.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Server component that fetches initial data from API using search params, passes to TimelineFeed as initialData, includes Header and FilterBar, uses no-store cache for fresh data, handles category and search params.",
            "status": "pending",
            "testStrategy": "Test page SSR loads with correct initial data, search params preserved, components render in correct order, no hydration errors",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integration Testing and Polish",
            "description": "Test end-to-end functionality and add final polish for smooth user experience.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Verify full flow: filter changes reset feed and scroll to top, pagination continues correctly with filters, search disables filters, URL state fully synchronized, responsive design works, performance optimized.",
            "status": "pending",
            "testStrategy": "End-to-end tests: initial load 20 items grouped by date, load more works with filters, filter change resets to top, search shows empty state, URL deep linking works, mobile responsive",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:08:01.340Z"
      },
      {
        "id": 16,
        "title": "Implement Header with Search Bar and Keyboard Shortcut",
        "description": "Build the header component with logo, search bar with ⌘K shortcut, debounced input, URL synchronization, and dark mode toggle.",
        "details": "1. Create `components/layout/header.tsx`:\n```typescript\n'use client';\nimport { useState, useEffect, useRef } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport { Search, X } from 'lucide-react';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { ThemeToggle } from '@/components/ui/theme-toggle';\nimport { useDebounce } from '@/hooks/use-debounce';\nimport { cn } from '@/lib/utils';\n\nexport function Header() {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const [query, setQuery] = useState(searchParams.get('q') || '');\n  const [isSearchOpen, setIsSearchOpen] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const debouncedQuery = useDebounce(query, 300);\n\n  // Sync URL with debounced query\n  useEffect(() => {\n    const params = new URLSearchParams(searchParams);\n    if (debouncedQuery) {\n      params.set('q', debouncedQuery);\n      params.delete('category'); // Filter disabled during search\n    } else {\n      params.delete('q');\n    }\n    router.push(`/timeline?${params.toString()}`);\n  }, [debouncedQuery]);\n\n  // ⌘K shortcut\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n        e.preventDefault();\n        setIsSearchOpen(true);\n        inputRef.current?.focus();\n      }\n      if (e.key === 'Escape') {\n        setIsSearchOpen(false);\n        inputRef.current?.blur();\n      }\n    };\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, []);\n\n  const clearSearch = () => {\n    setQuery('');\n    setIsSearchOpen(false);\n  };\n\n  return (\n    <header className=\"sticky top-0 z-20 bg-background border-b border-border\">\n      <div className=\"max-w-2xl mx-auto px-4 py-3 flex items-center justify-between gap-4\">\n        {/* Logo */}\n        <a href=\"/timeline\" className=\"font-bold text-xl text-foreground\">\n          upday\n        </a>\n\n        {/* Search - Desktop */}\n        <div className=\"hidden md:flex flex-1 max-w-md relative\">\n          <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n          <Input\n            ref={inputRef}\n            type=\"text\"\n            placeholder=\"Search news... (⌘K)\"\n            value={query}\n            onChange={(e) => setQuery(e.target.value)}\n            className=\"pl-10 pr-10\"\n          />\n          {query && (\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              className=\"absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7\"\n              onClick={clearSearch}\n            >\n              <X className=\"h-4 w-4\" />\n            </Button>\n          )}\n        </div>\n\n        {/* Search - Mobile (icon that expands) */}\n        <div className=\"md:hidden\">\n          {isSearchOpen ? (\n            <div className=\"fixed inset-0 z-50 bg-background p-4\">\n              <div className=\"flex items-center gap-2\">\n                <Input\n                  ref={inputRef}\n                  type=\"text\"\n                  placeholder=\"Search news...\"\n                  value={query}\n                  onChange={(e) => setQuery(e.target.value)}\n                  autoFocus\n                  className=\"flex-1\"\n                />\n                <Button variant=\"ghost\" onClick={() => setIsSearchOpen(false)}>\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          ) : (\n            <Button variant=\"ghost\" size=\"icon\" onClick={() => setIsSearchOpen(true)}>\n              <Search className=\"h-5 w-5\" />\n            </Button>\n          )}\n        </div>\n\n        <ThemeToggle />\n      </div>\n    </header>\n  );\n}\n```\n\n2. Create `hooks/use-debounce.ts`:\n```typescript\nimport { useState, useEffect } from 'react';\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n```",
        "testStrategy": "Component and interaction testing:\n- Test ⌘K shortcut opens search and focuses input\n- Test Ctrl+K works on Windows/Linux\n- Test Escape closes search\n- Test debounce waits 300ms before updating URL\n- Test URL updates with ?q=query on search\n- Test clear button (X) removes query and resets URL\n- Test search results display in timeline format\n- Test filter bar is disabled when search is active\n- Mobile: test search icon expands to full-screen input\n- Mobile: test Cancel button closes search overlay\n- Test logo links to /timeline",
        "priority": "high",
        "dependencies": [
          "12",
          "15"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and implement useDebounce hook",
            "description": "Create the custom useDebounce hook in hooks/use-debounce.ts to handle debounced search input with 300ms delay for URL synchronization.",
            "dependencies": [],
            "details": "Implement the provided useDebounce hook code exactly as specified. Ensure it properly manages state and timeout cleanup to prevent memory leaks during rapid typing.",
            "status": "pending",
            "testStrategy": "Test that hook returns initial value immediately, debounced value updates only after 300ms delay, and cleanup prevents stale updates on unmount.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Header component structure and UI",
            "description": "Create components/layout/header.tsx with logo, desktop search bar, mobile search overlay, and theme toggle using provided UI components.",
            "dependencies": [
              1
            ],
            "details": "Copy the exact Header component code provided. Ensure proper imports for Search/X icons, Input, Button, ThemeToggle, useDebounce, and cn utility. Verify responsive layout with Tailwind classes.",
            "status": "pending",
            "testStrategy": "Test desktop search bar renders with search icon and clear button when query exists. Test mobile shows search icon button initially. Test theme toggle renders correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add keyboard shortcuts (⌘K and Escape)",
            "description": "Implement global keyboard event listeners for ⌘K/Ctrl+K to open search and focus input, and Escape to close search.",
            "dependencies": [
              2
            ],
            "details": "Use useEffect to add/remove document keydown listener. Handle both metaKey (Mac) and ctrlKey (Windows/Linux) for K key. Focus inputRef on open, blur on Escape. Ensure preventDefault stops browser default.",
            "status": "pending",
            "testStrategy": "Test ⌘K opens mobile/desktop search and focuses input. Test Ctrl+K works cross-platform. Test Escape closes search and blurs input. Test no interference with other shortcuts.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement debounced search with URL sync",
            "description": "Sync search input with URL params using debounced query, updating ?q=query and removing category filter during search.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use useSearchParams and useRouter for initial sync and updates. In debounced effect: create URLSearchParams copy, set 'q' param or delete it, remove 'category', then router.push to /timeline with new params.",
            "status": "pending",
            "testStrategy": "Test typing updates URL only after 300ms debounce. Test initial load reads ?q= from URL. Test clears category filter on search. Test empty query removes ?q= param.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add search clear functionality and integrate",
            "description": "Implement clearSearch function for X button (desktop) and Cancel button (mobile), resetting query and closing search overlay.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create clearSearch handler that sets query to '' and isSearchOpen to false. Wire to desktop X button click and mobile Cancel button. Ensure URL syncs to empty state automatically via debounce.",
            "status": "pending",
            "testStrategy": "Test desktop X button clears input and URL. Test mobile Cancel closes overlay and clears input. Test both restore category filter visibility. Test Escape also clears properly.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-02T10:08:05.680Z"
      },
      {
        "id": 17,
        "title": "Build News Ingestion Pipeline",
        "description": "Create the backend crawling system that fetches news from RSS feeds and web sources, deduplicates content, cleans articles, and stores them in the database.",
        "details": "1. Create `lib/crawl.ts` - Multi-source crawler:\n```typescript\nimport Parser from 'rss-parser';\n\nconst parser = new Parser();\n\ninterface RawArticle {\n  title: string;\n  body: string;\n  sourceUrl: string;\n  source: string;\n  publishedAt: string;\n}\n\nconst RSS_SOURCES = [\n  { url: 'https://techcrunch.com/feed/', source: 'TechCrunch', categories: ['ai', 'startup'] },\n  { url: 'https://www.theverge.com/rss/index.xml', source: 'The Verge', categories: ['ai', 'dev'] },\n  { url: 'https://feeds.arstechnica.com/arstechnica/science', source: 'Ars Technica', categories: ['science', 'space'] },\n  // Add more sources per category\n];\n\nexport async function crawlAllSources(): Promise<RawArticle[]> {\n  const articles: RawArticle[] = [];\n  \n  for (const source of RSS_SOURCES) {\n    try {\n      const feed = await parser.parseURL(source.url);\n      for (const item of feed.items.slice(0, 10)) { // Latest 10 per source\n        if (item.title && item.link && item.contentSnippet) {\n          articles.push({\n            title: item.title,\n            body: item.contentSnippet || item.content || '',\n            sourceUrl: item.link,\n            source: source.source,\n            publishedAt: item.pubDate ? new Date(item.pubDate).toISOString() : new Date().toISOString(),\n          });\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to crawl ${source.source}:`, error);\n      // Graceful degradation - continue with other sources\n    }\n  }\n  \n  return articles;\n}\n```\n\n2. Create `lib/dedupe.ts` - Deduplication logic:\n```typescript\nimport { db } from './db';\n\ninterface RawArticle {\n  title: string;\n  sourceUrl: string;\n}\n\nexport async function deduplicateArticles(articles: RawArticle[]): Promise<RawArticle[]> {\n  // Get existing URLs from DB\n  const { data: existing } = await db\n    .from('news_items')\n    .select('source_url')\n    .in('source_url', articles.map(a => a.sourceUrl));\n  \n  const existingUrls = new Set(existing?.map(e => e.source_url) || []);\n  \n  // Filter out duplicates by URL\n  const unique = articles.filter(a => !existingUrls.has(a.sourceUrl));\n  \n  // Additional title similarity check (Levenshtein distance)\n  const dedupedByTitle: RawArticle[] = [];\n  for (const article of unique) {\n    const isDuplicate = dedupedByTitle.some(\n      existing => similarityScore(existing.title, article.title) > 0.85\n    );\n    if (!isDuplicate) {\n      dedupedByTitle.push(article);\n    }\n  }\n  \n  return dedupedByTitle;\n}\n\nfunction similarityScore(a: string, b: string): number {\n  const aLower = a.toLowerCase();\n  const bLower = b.toLowerCase();\n  // Simple Jaccard similarity on words\n  const aWords = new Set(aLower.split(/\\s+/));\n  const bWords = new Set(bLower.split(/\\s+/));\n  const intersection = [...aWords].filter(w => bWords.has(w)).length;\n  const union = new Set([...aWords, ...bWords]).size;\n  return intersection / union;\n}\n```\n\n3. Create `lib/clean.ts` - Content cleaning:\n```typescript\nexport function cleanArticleBody(body: string): string {\n  return body\n    // Remove HTML tags\n    .replace(/<[^>]*>/g, '')\n    // Remove ad markers\n    .replace(/\\[ad\\]|\\[advertisement\\]|sponsored/gi, '')\n    // Remove excessive whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove common boilerplate\n    .replace(/subscribe to our newsletter.*/gi, '')\n    .replace(/follow us on.*/gi, '')\n    .trim();\n}\n```\n\n4. Create `app/api/cron/ingest/route.ts` - Cron endpoint:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { crawlAllSources } from '@/lib/crawl';\nimport { deduplicateArticles } from '@/lib/dedupe';\nimport { cleanArticleBody } from '@/lib/clean';\nimport { generateSummary, classifyCategory } from '@/lib/ai';\nimport { db } from '@/lib/db';\n\nexport async function GET(request: Request) {\n  // Verify cron secret\n  const authHeader = request.headers.get('authorization');\n  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  try {\n    // 1. Crawl\n    const rawArticles = await crawlAllSources();\n    console.log(`Crawled ${rawArticles.length} articles`);\n\n    // 2. Deduplicate\n    const uniqueArticles = await deduplicateArticles(rawArticles);\n    console.log(`${uniqueArticles.length} unique articles after deduplication`);\n\n    // 3. Clean, summarize, classify, store\n    for (const article of uniqueArticles) {\n      const cleanBody = cleanArticleBody(article.body);\n      const [summary, category] = await Promise.all([\n        generateSummary(article.title, cleanBody),\n        classifyCategory(article.title, cleanBody),\n      ]);\n\n      await db.from('news_items').insert({\n        title: article.title,\n        summary,\n        body: cleanBody,\n        category,\n        source: article.source,\n        source_url: article.sourceUrl,\n        published_at: article.publishedAt,\n      });\n    }\n\n    return NextResponse.json({ processed: uniqueArticles.length });\n  } catch (error) {\n    console.error('Ingestion failed:', error);\n    return NextResponse.json({ error: 'Ingestion failed' }, { status: 500 });\n  }\n}\n```\n\n5. Configure `vercel.json` for cron:\n```json\n{\n  \"crons\": [{\n    \"path\": \"/api/cron/ingest\",\n    \"schedule\": \"0 * * * *\"\n  }]\n}\n```",
        "testStrategy": "Pipeline testing:\n- Test crawlAllSources returns articles from multiple sources\n- Test graceful degradation when one source fails\n- Test deduplication removes exact URL matches\n- Test title similarity catches near-duplicates (>85% similar)\n- Test cleanArticleBody removes HTML, ads, boilerplate\n- Test cron endpoint requires authorization header\n- Test full pipeline end-to-end with mock data\n- Monitor: set up alerts for pipeline failures\n- Verify articles appear in timeline after ingestion",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-02T10:20:30.873Z"
      },
      {
        "id": 18,
        "title": "Implement AI Summary and Category Classification",
        "description": "Build the AI processing layer that generates 2-3 line summaries and classifies articles into categories using OpenAI or Anthropic API.",
        "details": "1. Create `lib/ai.ts` - AI integration:\n```typescript\nimport OpenAI from 'openai';\nimport { Category } from '@/types/news';\nimport { CATEGORIES } from '@/lib/constants';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nconst SUMMARY_PROMPT = `You are a news summarizer for a tech news platform. Generate a 2-3 line summary of the following article.\n\nRules:\n- Focus on \"what happened\" and \"why it matters\"\n- Be factual and objective - no opinion or interpretation\n- Keep it under 280 characters\n- Use present tense for recent events\n- Do not start with \"This article\" or similar phrases\n\nTitle: {title}\n\nArticle:\n{body}\n\nSummary:`;\n\nconst CLASSIFY_PROMPT = `Classify the following news article into exactly ONE category.\n\nCategories:\n- ai: Artificial intelligence, machine learning, LLMs\n- startup: Startups, funding, M&A\n- science: Scientific research, medical breakthroughs\n- design: Product design, UX, visual design\n- space: Space exploration, aerospace\n- dev: Software development, open source, infrastructure\n\nTitle: {title}\n\nArticle excerpt:\n{body}\n\nRespond with only the category ID (ai, startup, science, design, space, or dev):`;\n\nexport async function generateSummary(title: string, body: string): Promise<string> {\n  try {\n    const prompt = SUMMARY_PROMPT\n      .replace('{title}', title)\n      .replace('{body}', body.slice(0, 2000)); // Limit context\n\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4o-mini',\n      messages: [{ role: 'user', content: prompt }],\n      max_tokens: 150,\n      temperature: 0.3,\n    });\n\n    const summary = response.choices[0]?.message?.content?.trim() || '';\n    \n    // Quality validation\n    if (summary.length < 50 || summary.length > 300) {\n      console.warn('Summary length out of range:', summary.length);\n      return title; // Fallback to title\n    }\n    \n    return summary;\n  } catch (error) {\n    console.error('Summary generation failed:', error);\n    return title; // Fallback to title-only display\n  }\n}\n\nexport async function classifyCategory(title: string, body: string): Promise<Category> {\n  try {\n    const prompt = CLASSIFY_PROMPT\n      .replace('{title}', title)\n      .replace('{body}', body.slice(0, 1000));\n\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4o-mini',\n      messages: [{ role: 'user', content: prompt }],\n      max_tokens: 10,\n      temperature: 0,\n    });\n\n    const category = response.choices[0]?.message?.content?.trim().toLowerCase() as Category;\n    \n    // Validate category\n    const validCategories = CATEGORIES.map(c => c.id);\n    if (!validCategories.includes(category)) {\n      console.warn('Invalid category returned:', category);\n      return 'dev'; // Default fallback\n    }\n    \n    return category;\n  } catch (error) {\n    console.error('Classification failed:', error);\n    return 'dev'; // Default fallback\n  }\n}\n```\n\n2. Create `lib/ai-batch.ts` for batch processing (cost optimization):\n```typescript\nimport { generateSummary, classifyCategory } from './ai';\n\ninterface ArticleToProcess {\n  title: string;\n  body: string;\n}\n\ninterface ProcessedArticle {\n  summary: string;\n  category: Category;\n}\n\nexport async function processArticlesBatch(\n  articles: ArticleToProcess[],\n  concurrency: number = 3\n): Promise<ProcessedArticle[]> {\n  const results: ProcessedArticle[] = [];\n  \n  // Process in batches to avoid rate limits\n  for (let i = 0; i < articles.length; i += concurrency) {\n    const batch = articles.slice(i, i + concurrency);\n    const batchResults = await Promise.all(\n      batch.map(async (article) => {\n        const [summary, category] = await Promise.all([\n          generateSummary(article.title, article.body),\n          classifyCategory(article.title, article.body),\n        ]);\n        return { summary, category };\n      })\n    );\n    results.push(...batchResults);\n    \n    // Rate limit delay\n    if (i + concurrency < articles.length) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n  \n  return results;\n}\n```\n\n3. Add retry logic with exponential backoff:\n```typescript\nasync function withRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3\n): Promise<T> {\n  let lastError: Error;\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  throw lastError!;\n}\n```",
        "testStrategy": "AI quality testing:\n- Test summary generation produces 2-3 lines (50-300 chars)\n- Test summaries are factual without opinion phrases\n- Test classification returns valid category IDs\n- Test fallback to title when summary fails\n- Test fallback to 'dev' when classification fails\n- Test retry logic handles transient API failures\n- Test batch processing respects rate limits\n- Monitor: track API costs per article\n- Quality audit: manually review sample of 20 summaries for tone/accuracy",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-02T10:22:37.491Z"
      },
      {
        "id": 19,
        "title": "Build Landing Page",
        "description": "Create the conversion-focused landing page with hero section, feature showcase, live timeline preview, how it works section, and CTAs.",
        "details": "1. Create `app/page.tsx` - Landing page:\n```typescript\nimport { Button } from '@/components/ui/button';\nimport { TimelinePreview } from '@/components/landing/timeline-preview';\nimport { ArrowRight, Clock, Search, Filter } from 'lucide-react';\n\nexport default function LandingPage() {\n  return (\n    <div className=\"min-h-screen bg-background\">\n      {/* Hero Section */}\n      <section className=\"max-w-4xl mx-auto px-4 py-20 text-center\">\n        <h1 className=\"text-4xl md:text-6xl font-bold text-foreground mb-6\">\n          Know what's changing.\n          <br />\n          <span className=\"text-muted-foreground\">Without reading everything.</span>\n        </h1>\n        <p className=\"text-xl text-muted-foreground mb-8 max-w-2xl mx-auto\">\n          AI-summarized news in a timeline. Scan tech, science, and startup news in minutes, not hours. No login required.\n        </p>\n        <Button asChild size=\"lg\" className=\"text-lg px-8\">\n          <a href=\"/timeline\">\n            Go to Timeline\n            <ArrowRight className=\"ml-2 h-5 w-5\" />\n          </a>\n        </Button>\n      </section>\n\n      {/* Feature Showcase */}\n      <section className=\"bg-muted/50 py-16\">\n        <div className=\"max-w-4xl mx-auto px-4\">\n          <h2 className=\"text-2xl font-bold text-center mb-12\">Why upday?</h2>\n          <div className=\"grid md:grid-cols-3 gap-8\">\n            <FeatureCard\n              icon={<Clock className=\"h-8 w-8\" />}\n              title=\"Time-based, not algorithm-based\"\n              description=\"News sorted by when it happened. See what's new at a glance without algorithmic manipulation.\"\n            />\n            <FeatureCard\n              icon={<Search className=\"h-8 w-8\" />}\n              title=\"AI summaries that matter\"\n              description=\"Every article gets a 2-3 line summary. Understand the news without clicking through.\"\n            />\n            <FeatureCard\n              icon={<Filter className=\"h-8 w-8\" />}\n              title=\"Filter by what you care about\"\n              description=\"AI, Startup, Science, Design, Space, Dev. Focus on your domains without losing context.\"\n            />\n          </div>\n        </div>\n      </section>\n\n      {/* Live Preview */}\n      <section className=\"py-16\">\n        <div className=\"max-w-2xl mx-auto px-4\">\n          <h2 className=\"text-2xl font-bold text-center mb-4\">See it in action</h2>\n          <p className=\"text-muted-foreground text-center mb-8\">\n            Real news, updated continuously\n          </p>\n          <TimelinePreview />\n        </div>\n      </section>\n\n      {/* How It Works */}\n      <section className=\"bg-muted/50 py-16\">\n        <div className=\"max-w-4xl mx-auto px-4\">\n          <h2 className=\"text-2xl font-bold text-center mb-12\">How it works</h2>\n          <div className=\"grid md:grid-cols-3 gap-8 text-center\">\n            <Step number={1} title=\"Open the timeline\" description=\"No signup, no login. Just open and start scanning.\" />\n            <Step number={2} title=\"Scan the summaries\" description=\"Each card shows what happened and why it matters.\" />\n            <Step number={3} title=\"Dive deeper if needed\" description=\"Click through to the original article when you want the full story.\" />\n          </div>\n        </div>\n      </section>\n\n      {/* Final CTA */}\n      <section className=\"py-20 text-center\">\n        <div className=\"max-w-2xl mx-auto px-4\">\n          <h2 className=\"text-3xl font-bold mb-4\">Ready to stay informed?</h2>\n          <p className=\"text-muted-foreground mb-8\">\n            Join thousands of professionals who scan upday every morning.\n          </p>\n          <Button asChild size=\"lg\" className=\"text-lg px-8\">\n            <a href=\"/timeline\">\n              Start scanning\n              <ArrowRight className=\"ml-2 h-5 w-5\" />\n            </a>\n          </Button>\n          <p className=\"text-sm text-muted-foreground mt-4\">\n            No account required. Ever.\n          </p>\n        </div>\n      </section>\n    </div>\n  );\n}\n\nfunction FeatureCard({ icon, title, description }: { icon: React.ReactNode; title: string; description: string }) {\n  return (\n    <div className=\"text-center\">\n      <div className=\"inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary/10 text-primary mb-4\">\n        {icon}\n      </div>\n      <h3 className=\"font-semibold text-lg mb-2\">{title}</h3>\n      <p className=\"text-muted-foreground\">{description}</p>\n    </div>\n  );\n}\n\nfunction Step({ number, title, description }: { number: number; title: string; description: string }) {\n  return (\n    <div>\n      <div className=\"inline-flex items-center justify-center w-10 h-10 rounded-full bg-primary text-primary-foreground font-bold mb-4\">\n        {number}\n      </div>\n      <h3 className=\"font-semibold text-lg mb-2\">{title}</h3>\n      <p className=\"text-muted-foreground\">{description}</p>\n    </div>\n  );\n}\n```\n\n2. Create `components/landing/timeline-preview.tsx`:\n```typescript\nimport { NewsCard } from '@/components/news/news-card';\nimport { db } from '@/lib/db';\n\nexport async function TimelinePreview() {\n  const { data: items } = await db\n    .from('news_items')\n    .select('id, title, summary, category, source, source_url, published_at')\n    .order('published_at', { ascending: false })\n    .limit(3);\n\n  return (\n    <div className=\"border border-border rounded-lg overflow-hidden shadow-lg\">\n      {items?.map((item) => (\n        <NewsCard\n          key={item.id}\n          item={{\n            id: item.id,\n            title: item.title,\n            summary: item.summary,\n            category: item.category,\n            source: item.source,\n            sourceUrl: item.source_url,\n            publishedAt: item.published_at,\n            createdAt: item.published_at,\n          }}\n        />\n      ))}\n      <div className=\"p-4 text-center border-t border-border\">\n        <a href=\"/timeline\" className=\"text-primary hover:underline\">\n          View full timeline →\n        </a>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "Landing page testing:\n- Test hero CTA links to /timeline\n- Test live preview displays 3 real news items\n- Test all sections render correctly on mobile\n- Test dark mode styling throughout\n- Test 'No account required' messaging is visible\n- Performance: verify LCP < 2 seconds\n- Accessibility: verify heading hierarchy (h1 → h2 → h3)\n- Test final CTA links to /timeline\n- Visual regression testing for all breakpoints",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-02T10:08:10.542Z"
      },
      {
        "id": 20,
        "title": "Implement Error Handling and Empty States",
        "description": "Add comprehensive error handling, loading states, and distinct empty state messages for search, filter, and error scenarios across the application.",
        "details": "1. Create `components/news/empty-states.tsx`:\n```typescript\nimport { SearchX, Filter, AlertCircle, Inbox } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\n\ninterface EmptyStateProps {\n  type: 'search' | 'filter' | 'error' | 'empty';\n  query?: string;\n  category?: string;\n  onReset?: () => void;\n}\n\nexport function EmptyState({ type, query, category, onReset }: EmptyStateProps) {\n  const states = {\n    search: {\n      icon: <SearchX className=\"h-12 w-12 text-muted-foreground\" />,\n      title: 'No results found',\n      description: query \n        ? `No news matching \"${query}\". Try a different search term.`\n        : 'Enter a search term to find news.',\n      action: onReset && (\n        <Button variant=\"outline\" onClick={onReset}>\n          Clear search\n        </Button>\n      ),\n    },\n    filter: {\n      icon: <Filter className=\"h-12 w-12 text-muted-foreground\" />,\n      title: 'No news in this category',\n      description: category\n        ? `No ${category} news available yet. Check back later or try another category.`\n        : 'Select a category to filter news.',\n      action: onReset && (\n        <Button variant=\"outline\" onClick={onReset}>\n          Show all news\n        </Button>\n      ),\n    },\n    error: {\n      icon: <AlertCircle className=\"h-12 w-12 text-destructive\" />,\n      title: 'Something went wrong',\n      description: 'We couldn\\'t load the news. Please try again.',\n      action: (\n        <Button variant=\"outline\" onClick={() => window.location.reload()}>\n          Retry\n        </Button>\n      ),\n    },\n    empty: {\n      icon: <Inbox className=\"h-12 w-12 text-muted-foreground\" />,\n      title: 'No news yet',\n      description: 'News will appear here once our sources are updated.',\n      action: null,\n    },\n  };\n\n  const state = states[type];\n\n  return (\n    <div className=\"flex flex-col items-center justify-center py-16 px-4 text-center\">\n      {state.icon}\n      <h3 className=\"mt-4 text-lg font-semibold text-foreground\">{state.title}</h3>\n      <p className=\"mt-2 text-sm text-muted-foreground max-w-sm\">{state.description}</p>\n      {state.action && <div className=\"mt-6\">{state.action}</div>}\n    </div>\n  );\n}\n```\n\n2. Create `app/error.tsx` - Global error boundary:\n```typescript\n'use client';\n\nimport { useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { AlertCircle } from 'lucide-react';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  useEffect(() => {\n    console.error('Application error:', error);\n  }, [error]);\n\n  return (\n    <div className=\"min-h-screen flex flex-col items-center justify-center p-4\">\n      <AlertCircle className=\"h-16 w-16 text-destructive mb-4\" />\n      <h1 className=\"text-2xl font-bold mb-2\">Something went wrong</h1>\n      <p className=\"text-muted-foreground mb-6 text-center max-w-md\">\n        We encountered an unexpected error. Our team has been notified.\n      </p>\n      <div className=\"flex gap-4\">\n        <Button onClick={reset}>Try again</Button>\n        <Button variant=\"outline\" asChild>\n          <a href=\"/\">Go home</a>\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\n3. Create `app/timeline/loading.tsx` - Loading state:\n```typescript\nimport { NewsCardSkeleton } from '@/components/news/news-card-skeleton';\nimport { Skeleton } from '@/components/ui/skeleton';\n\nexport default function TimelineLoading() {\n  return (\n    <div className=\"min-h-screen bg-background\">\n      {/* Header skeleton */}\n      <div className=\"sticky top-0 z-20 bg-background border-b border-border\">\n        <div className=\"max-w-2xl mx-auto px-4 py-3 flex items-center justify-between\">\n          <Skeleton className=\"h-8 w-20\" />\n          <Skeleton className=\"h-10 w-64\" />\n          <Skeleton className=\"h-10 w-10 rounded-full\" />\n        </div>\n      </div>\n      \n      {/* Filter bar skeleton */}\n      <div className=\"sticky top-[57px] z-10 bg-background border-b border-border px-4 py-3\">\n        <div className=\"flex gap-2\">\n          {[1, 2, 3, 4, 5, 6, 7].map((i) => (\n            <Skeleton key={i} className=\"h-8 w-16 rounded-md\" />\n          ))}\n        </div>\n      </div>\n      \n      {/* News cards skeleton */}\n      <div className=\"max-w-2xl mx-auto\">\n        <Skeleton className=\"h-8 w-48 m-4\" /> {/* Date separator */}\n        {[1, 2, 3, 4, 5].map((i) => (\n          <NewsCardSkeleton key={i} />\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n4. Update `components/news/timeline-feed.tsx` to use EmptyState:\n```typescript\nimport { EmptyState } from './empty-states';\n\n// In TimelineFeed component:\nif (error) {\n  return <EmptyState type=\"error\" />;\n}\n\nif (items.length === 0) {\n  const searchQuery = searchParams.get('q');\n  const category = searchParams.get('category');\n  \n  if (searchQuery) {\n    return (\n      <EmptyState \n        type=\"search\" \n        query={searchQuery} \n        onReset={() => router.push('/timeline')} \n      />\n    );\n  }\n  \n  if (category) {\n    return (\n      <EmptyState \n        type=\"filter\" \n        category={category} \n        onReset={() => router.push('/timeline')} \n      />\n    );\n  }\n  \n  return <EmptyState type=\"empty\" />;\n}\n```",
        "testStrategy": "Error and empty state testing:\n- Test search empty state displays when no results found\n- Test filter empty state displays for empty category\n- Test error state displays on API failure\n- Test 'Clear search' button resets to full timeline\n- Test 'Show all news' button removes category filter\n- Test 'Retry' button reloads the page\n- Test loading skeleton matches final layout dimensions\n- Test global error boundary catches unhandled errors\n- Test error logging captures error details\n- Accessibility: verify empty states are announced to screen readers",
        "priority": "medium",
        "dependencies": [
          "15",
          "16"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-02T10:24:20.896Z"
      },
      {
        "id": 21,
        "title": "Comprehensive SEO Optimization for React SPA News App",
        "description": "Implement full SEO optimization plan in 5 phases: Phase 1 (Diagnosis & Quick Wins), Phase 2 (Pre-rendering), Phase 3 (Dynamic Sitemap), Phase 4 (Core Web Vitals), and Phase 5 (SSR Evaluation) to improve Google indexing and search visibility for the Vite/React news application.",
        "status": "in-progress",
        "dependencies": [
          "13",
          "16",
          "17",
          "18",
          "19",
          "20"
        ],
        "priority": "high",
        "details": "## Phase-based SEO Optimization Approach\n\n### **Phase 1: Diagnosis & Quick Wins**\n- Audit current SEO status using Lighthouse, Google Search Console\n- Implement basic `robots.txt` in `public/` directory\n- Add static metadata with `react-helmet-async`\n- Fix semantic HTML structure (headings, alt text)\n- Add canonical URLs to prevent duplicate content\n\n### **Phase 2: Pre-rendering Introduction**\n- Evaluate pre-rendering options:\n  - `vite-ssg` for static site generation\n  - `prerender-spa-plugin` for build-time rendering\n  - Prerender.io service for dynamic pre-rendering\n- Implement chosen pre-rendering solution\n- Verify HTML content is visible in page source (not empty `<div id=\"root\">`)\n\n### **Phase 3: Dynamic Sitemap**\n- Install and configure `vite-plugin-sitemap`:\n```bash\nnpm install vite-plugin-sitemap\n```\n```typescript\n// vite.config.ts\nimport { sitemap } from 'vite-plugin-sitemap';\n\nexport default {\n  plugins: [sitemap({\n    hostname: 'https://yourdomain.com',\n    dynamicRoutes: async () => {\n      // Fetch news article URLs from API\n      return articleUrls;\n    }\n  })]\n};\n```\n- Implement dynamic route generation for news articles\n- Submit sitemap to Google Search Console\n- Add structured data (JSON-LD) for NewsArticle schema\n\n### **Phase 4: Core Web Vitals Optimization**\n- Target metrics: LCP < 2.5s, CLS < 0.1, INP < 200ms\n- Implement lazy loading for images: `loading=\"lazy\"`\n- Add `preload` for critical resources (fonts, hero images)\n- Bundle analysis with `vite-bundle-visualizer`\n- Code splitting and tree shaking optimization\n- Image optimization (WebP, responsive images)\n\n### **Phase 5: SSR Evaluation**\n- Evaluate migration to **Next.js 15** (App Router) for hybrid SSR/SSG:\n  - Benefits: Automatic SSR, `generateMetadata()`, ISR for news timeline\n  - Cost-benefit analysis of migration effort\n- Alternative: Keep Vite with enhanced pre-rendering\n- Document decision and implementation roadmap\n\n**Implementation Priority**: Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5",
        "testStrategy": "### **Phase 1 Testing (Diagnosis & Quick Wins)**:\n- Lighthouse SEO audit baseline score documented\n- `curl -I yourdomain.com` returns 200\n- `robots.txt` accessible at `/robots.txt`\n- Verify semantic HTML with WAVE/axe tools\n- All images have descriptive `alt` attributes\n\n### **Phase 2 Testing (Pre-rendering)**:\n- `curl yourdomain.com` returns fully rendered HTML content\n- View Source shows actual content (not just JS bundle)\n- Google Mobile-Friendly Test passes\n- Search Console URL Inspection shows 'Page is indexable'\n\n### **Phase 3 Testing (Dynamic Sitemap)**:\n- `sitemap.xml` accessible and contains all news article URLs\n- Google Search Console: Submit sitemap, verify indexing status\n- Google Rich Results Test validates NewsArticle JSON-LD schema\n- Structured Data Testing Tool confirms all required fields\n\n### **Phase 4 Testing (Core Web Vitals)**:\n- PageSpeed Insights: LCP ≤2.5s, CLS ≤0.1, INP ≤200ms\n- Web Vitals Chrome Extension confirms metrics\n- Lighthouse Performance score ≥90/100\n- Network tab confirms lazy loading behavior\n\n### **Phase 5 Testing (SSR Evaluation)**:\n- If migrated: Next.js SSR verified with curl showing server-rendered content\n- `generateMetadata()` produces correct meta tags per route\n- ISR revalidation working for news timeline\n- Document comparison metrics before/after migration",
        "subtasks": [
          {
            "id": 1,
            "title": "Phase 1: SEO Diagnosis and Quick Wins Implementation",
            "description": "Audit current SEO status and implement quick wins including robots.txt, basic metadata, semantic HTML fixes, and canonical URLs.",
            "dependencies": [],
            "details": "1. Run Lighthouse SEO audit and document baseline score\n2. Create public/robots.txt with User-agent: * Allow: / Sitemap: https://yourdomain.com/sitemap.xml\n3. Install react-helmet-async and create basic SEO component for title, description, canonical\n4. Audit and fix semantic HTML (proper heading hierarchy, article tags)\n5. Add alt text to all images\n6. Add canonical URLs to prevent duplicate content issues\n<info added on 2026-02-03T12:42:27.712Z>\nUpdated project status reflection:\n- robots.txt already exists (review only needed)\n- SEO.tsx component exists (useEffect-based approach - has issues)\n- Basic meta tags present in index.html\n- Google/Naver verification codes are in placeholder state\n\nActual required tasks:\n1. Use Google Search Console URL Inspection to verify current indexing status\n2. Replace Google/Naver verification codes with actual values\n3. Expand JSON-LD schema in index.html to NewsMediaOrganization\n4. Document the client-side rendering limitations of current SEO.tsx approach\n5. Measure Lighthouse SEO score baseline\n</info added on 2026-02-03T12:42:27.712Z>",
            "status": "done",
            "testStrategy": "Verify robots.txt accessible via curl, run Lighthouse SEO audit showing improvement, check semantic HTML with WAVE tool, confirm all images have alt attributes.",
            "updatedAt": "2026-02-03T12:56:57.865Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Phase 2: Pre-rendering Solution Implementation",
            "description": "Evaluate and implement pre-rendering solution to ensure HTML content is visible to search engine crawlers without JavaScript execution.",
            "dependencies": [
              1
            ],
            "details": "1. Evaluate pre-rendering options: vite-ssg, prerender-spa-plugin, or Prerender.io service\n2. Choose and implement the most suitable solution for the news app\n3. Configure pre-rendering for main routes (home, category pages, article pages)\n4. Test that page source shows actual content instead of empty div#root\n5. Verify Google can crawl and index the pre-rendered content\n<info added on 2026-02-03T12:42:44.298Z>\nPre-rendering Implementation Detailed Plan:\n\nResearch-based Options:\n1. vite-plugin-prerender (Puppeteer-based) - Simplest approach\n2. Vike (formerly vite-plugin-ssr) - Flexible but complex\n3. React Router v7 SSG - Latest but requires migration\n\nRecommended Approach: vite-plugin-prerender\n- Install packages: npm install @prerenderer/rollup-plugin @prerenderer/renderer-puppeteer\n- Add prerender configuration to vite.config.ts\n- Specify main routes: /, /timeline, /timeline?category=ai, etc.\n- Generate static HTML for each route during build\n- Verify pre-rendered HTML files in dist folder\n\nVerification Methods:\n- Check HTML content using curl\n- Confirm actual content is visible in View Source\n</info added on 2026-02-03T12:42:44.298Z>",
            "status": "done",
            "testStrategy": "curl yourdomain.com returns fully rendered HTML, View Source shows content, Google Mobile-Friendly Test passes, Search Console URL Inspection shows indexable.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T12:56:59.332Z"
          },
          {
            "id": 3,
            "title": "Phase 3: Dynamic Sitemap and Structured Data",
            "description": "Implement dynamic sitemap generation with vite-plugin-sitemap and add JSON-LD structured data for NewsArticle schema.",
            "dependencies": [
              2
            ],
            "details": "1. Install vite-plugin-sitemap: npm install vite-plugin-sitemap\n2. Configure dynamic route generation to include all news article URLs\n3. Implement NewsArticleSchema.tsx component with JSON-LD structured data\n4. Include headline, description, datePublished, author, publisher, image fields\n5. Submit sitemap to Google Search Console\n6. Monitor indexing status in Search Console\n<info added on 2026-02-03T12:42:50.969Z>\nDynamic Sitemap Implementation Detailed Plan:\n\nCurrent State:\n- Static sitemap.xml exists (category pages only)\n- news-sitemap.xml exists but not dynamic\n\nImplementation Approach:\n1. Supabase Edge Function for Dynamic Sitemap Generation\n   - Create /api/sitemap.xml endpoint\n   - Query latest news URLs from articles table\n   - Return in XML format\n\n2. news-sitemap.xml Enhancement\n   - Comply with Google News sitemap format\n   - Include publication, title, publication_date fields\n\n3. JSON-LD Structured Data Enhancement\n   - Move NewsArticle schema to server-side (integrate with pre-render)\n   - Add ItemList schema for category/list pages\n\n4. Submit new sitemaps to Search Console\n</info added on 2026-02-03T12:42:50.969Z>",
            "status": "done",
            "testStrategy": "Verify sitemap.xml contains all article URLs, Google Rich Results Test validates NewsArticle schema, Search Console shows sitemap submitted and URLs indexed.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T12:57:24.223Z"
          },
          {
            "id": 4,
            "title": "Phase 4: Core Web Vitals Optimization",
            "description": "Optimize performance metrics targeting LCP < 2.5s, CLS < 0.1, INP < 200ms through lazy loading, preloading, and bundle optimization.",
            "dependencies": [
              3
            ],
            "details": "1. Add loading='lazy' to all non-critical images\n2. Preload critical resources (fonts, hero images) in index.html\n3. Install and run vite-bundle-visualizer for bundle analysis\n4. Implement code splitting for route-based chunks\n5. Optimize images (WebP format, responsive srcset)\n6. Minimize render-blocking JavaScript\n7. Implement font-display: swap for web fonts\n<info added on 2026-02-03T12:43:05.631Z>\nCore Web Vitals Optimization Detailed Plan:\n\nTarget Metrics:\n- LCP (Largest Contentful Paint) < 2.5s\n- CLS (Cumulative Layout Shift) < 0.1\n- INP (Interaction to Next Paint) < 200ms\n\nImplementation Tasks:\n\n8. Current State Measurement\n   - Record PageSpeed Insights score\n   - Record Lighthouse Performance score\n\n9. Image Optimization Verification\n   - Verify loading=lazy is applied correctly\n   - Consider WebP format conversion\n   - Specify appropriate width/height attributes to prevent CLS\n\n10. Bundle Optimization\n    - Analyze bundle with vite-bundle-visualizer\n    - Optimize code splitting\n    - Remove unnecessary dependencies\n\n11. Critical CSS Implementation\n    - Inline above-the-fold CSS\n    - Add font preload\n\n12. Re-measurement and Comparison\n    - Run PageSpeed Insights and Lighthouse again\n    - Compare before/after scores\n    - Document improvements achieved\n</info added on 2026-02-03T12:43:05.631Z>",
            "status": "in-progress",
            "testStrategy": "PageSpeed Insights shows LCP ≤2.5s, CLS ≤0.1, INP ≤200ms, Lighthouse Performance score ≥90, network tab confirms lazy loading behavior.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T12:57:25.714Z"
          },
          {
            "id": 5,
            "title": "Phase 5: SSR Migration Evaluation and Decision",
            "description": "Evaluate Next.js 15 migration for SSR/SSG benefits versus keeping enhanced Vite pre-rendering, document decision and create implementation roadmap if migrating.",
            "dependencies": [
              4
            ],
            "details": "1. Document current SEO metrics and performance baseline\n2. Evaluate Next.js 15 App Router benefits: automatic SSR, generateMetadata(), ISR\n3. Estimate migration effort and timeline\n4. Perform cost-benefit analysis comparing migration vs enhanced Vite setup\n5. Make documented decision with stakeholder input\n6. If migrating: create detailed migration roadmap\n7. If staying with Vite: document optimization plan for continued improvement\n<info added on 2026-02-03T12:43:12.985Z>\nSSR Migration Detailed Evaluation Plan:\n\nEvaluation Criteria:\n1. Are current pre-rendering results sufficient?\n2. Cost-effectiveness of migration\n\nOption Comparison:\n\nOption 1: Next.js 15 (App Router)\n- Advantages: Stable SSR, generateMetadata() support, ISR support\n- Disadvantages: Requires complete rewrite, Vercel dependency\n\nOption 2: Vike (formerly vite-plugin-ssr)\n- Advantages: Maintains Vite ecosystem, enables incremental migration\n- Disadvantages: Learning curve, smaller community\n\nOption 3: Maintain Current Vite + Pre-rendering\n- Advantages: Minimal changes required, fast implementation\n- Disadvantages: Dynamic content limitations\n\nDecision Framework:\n- Measure SEO improvements after completing Phases 1-4\n- If indexing rate is 50% or higher: maintain current approach\n- If indexing rate is below 50%: proceed with SSR migration\n</info added on 2026-02-03T12:43:12.985Z>",
            "status": "pending",
            "testStrategy": "Decision document completed with metrics comparison, if migrated: verify SSR with curl, generateMetadata() working, ISR revalidation functional.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-03T12:57:25.714Z"
      },
      {
        "id": 22,
        "title": "Cloudflare Workers Cron Triggers 활성화",
        "description": "wrangler.toml에서 주석 처리된 cron triggers를 4시간 간격으로 활성화하여 크롤링 주기를 12시간에서 4시간으로 단축",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. wrangler.toml 파일 수정:\n```toml\n[triggers]\ncrons = [\"0 */4 * * *\"]\n```\n\n2. 환경 변수 확인 및 설정:\n- SUPABASE_URL\n- SUPABASE_SERVICE_ROLE_KEY\n- ANTHROPIC_API_KEY 또는 OPENAI_API_KEY\n\n3. wrangler deploy 명령으로 배포\n\n4. Cloudflare Dashboard에서 cron trigger 활성화 확인",
        "testStrategy": "1. Cloudflare Dashboard에서 cron trigger 등록 확인\n2. 수동으로 worker 실행하여 정상 동작 검증\n3. 4시간 후 자동 실행 로그 확인\n4. 하루 6회 실행 여부 모니터링",
        "subtasks": [],
        "updatedAt": "2026-02-03T13:51:23.929Z"
      },
      {
        "id": 23,
        "title": "[Crawl] workers/ingest.ts 에러 핸들링 및 로깅 강화",
        "description": "Cloudflare Workers의 ingest.ts 파일에 에러 핸들링 강화, 실행 로그 추가, 타임아웃 설정 검토",
        "details": "1. 에러 핸들링 강화:\n```typescript\nexport default {\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    const startTime = Date.now();\n    const stats = { processed: 0, skipped: 0, errors: 0 };\n    \n    try {\n      console.log(`[CRON] Starting crawl at ${new Date().toISOString()}`);\n      \n      // 개별 피드 처리 with isolation\n      for (const feed of RSS_FEEDS) {\n        try {\n          const result = await processFeed(feed, env);\n          stats.processed += result.processed;\n          stats.skipped += result.skipped;\n        } catch (feedError) {\n          stats.errors++;\n          console.error(`[ERROR] Feed ${feed.url} failed:`, feedError);\n          // 개별 피드 실패가 전체에 영향 없도록 계속 진행\n        }\n      }\n      \n      const duration = Date.now() - startTime;\n      console.log(`[CRON] Completed in ${duration}ms. Stats:`, stats);\n    } catch (error) {\n      console.error('[CRON] Critical error:', error);\n      throw error;\n    }\n  }\n};\n```\n\n2. 타임아웃 설정 (Cloudflare Workers 기본 30초, Cron은 최대 15분):\n- 개별 피드 처리에 타임아웃 적용\n- AbortController 사용하여 fetch 타임아웃 구현",
        "testStrategy": "1. 의도적으로 잘못된 RSS URL로 테스트하여 에러 격리 확인\n2. 로그 출력 형식 및 내용 검증\n3. 타임아웃 시나리오 테스트\n4. 전체 실행 시간이 2분 이내인지 확인",
        "priority": "high",
        "dependencies": [
          "22"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T13:54:14.301Z"
      },
      {
        "id": 24,
        "title": "[Crawl] 중복 기사 AI 처리 스킵 로직 구현",
        "description": "deduplication 단계에서 이미 존재하는 기사는 AI 처리를 완전히 스킵하고, 새로운 기사만 AI 요약/분류 수행하도록 최적화",
        "details": "1. Supabase에서 기존 기사 URL 조회:\n```typescript\nasync function getExistingArticleUrls(urls: string[], supabase: SupabaseClient): Promise<Set<string>> {\n  const { data, error } = await supabase\n    .from('articles')\n    .select('url')\n    .in('url', urls);\n  \n  if (error) throw error;\n  return new Set(data.map(a => a.url));\n}\n```\n\n2. 크롤링 파이프라인 수정:\n```typescript\nasync function processArticles(rawArticles: RawArticle[], env: Env) {\n  const urls = rawArticles.map(a => a.url);\n  const existingUrls = await getExistingArticleUrls(urls, supabase);\n  \n  const newArticles = rawArticles.filter(a => !existingUrls.has(a.url));\n  const skippedCount = rawArticles.length - newArticles.length;\n  \n  console.log(`[DEDUP] ${skippedCount} articles skipped (already exist), ${newArticles.length} new articles to process`);\n  \n  // 새 기사만 AI 처리\n  if (newArticles.length > 0) {\n    const processedArticles = await processWithAI(newArticles, env);\n    await saveArticles(processedArticles, supabase);\n  }\n  \n  return { processed: newArticles.length, skipped: skippedCount };\n}\n```\n\n3. URL 정규화 함수 추가 (쿼리 파라미터 제거 등)",
        "testStrategy": "1. 동일 기사 URL로 두 번 크롤링 시 두 번째에서 AI 호출 없음 확인\n2. AI API 호출 횟수 로깅으로 실제 절감 효과 측정\n3. 새 기사와 기존 기사 혼합 시나리오 테스트\n4. URL 정규화 로직 단위 테스트",
        "priority": "high",
        "dependencies": [
          "23"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T13:55:48.618Z"
      },
      {
        "id": 25,
        "title": "[Crawl] AI 응답 캐싱 시스템 구현",
        "description": "동일 도메인/유사 컨텐츠에 대한 AI 분류 결과를 캐싱하여 API 호출 비용 절감 (캐시 키: 컨텐츠 해시, TTL: 24시간)",
        "details": "1. 컨텐츠 해시 생성 함수:\n```typescript\nasync function generateContentHash(content: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(content.trim().toLowerCase());\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);\n}\n```\n\n2. Supabase에 캐시 테이블 생성:\n```sql\nCREATE TABLE ai_response_cache (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  content_hash VARCHAR(32) UNIQUE NOT NULL,\n  summary TEXT,\n  category VARCHAR(100),\n  created_at TIMESTAMP DEFAULT NOW(),\n  expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '24 hours')\n);\n\nCREATE INDEX idx_cache_hash ON ai_response_cache(content_hash);\nCREATE INDEX idx_cache_expires ON ai_response_cache(expires_at);\n```\n\n3. 캐시 조회/저장 로직:\n```typescript\nasync function getOrProcessWithAI(article: RawArticle, env: Env) {\n  const contentHash = await generateContentHash(article.content);\n  \n  // 캐시 조회\n  const { data: cached } = await supabase\n    .from('ai_response_cache')\n    .select('summary, category')\n    .eq('content_hash', contentHash)\n    .gt('expires_at', new Date().toISOString())\n    .single();\n  \n  if (cached) {\n    console.log(`[CACHE HIT] ${article.url}`);\n    return { ...article, summary: cached.summary, category: cached.category };\n  }\n  \n  // AI 처리\n  const result = await callAI(article, env);\n  \n  // 캐시 저장\n  await supabase.from('ai_response_cache').upsert({\n    content_hash: contentHash,\n    summary: result.summary,\n    category: result.category\n  });\n  \n  return result;\n}\n```\n\n4. 만료된 캐시 정리 (선택적 cron job)",
        "testStrategy": "1. 동일 컨텐츠 두 번 처리 시 두 번째에서 캐시 히트 확인\n2. 24시간 후 캐시 만료 확인\n3. 캐시 히트율 로깅 및 모니터링\n4. 해시 충돌 시나리오 테스트",
        "priority": "medium",
        "dependencies": [
          "24"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T13:57:07.294Z"
      },
      {
        "id": 26,
        "title": "[Crawl] AI API 배치 처리 및 Rate Limiting 최적화",
        "description": "AI API 호출 배치 크기 조정 및 rate limiting 개선 (현재 3개 동시 처리에서 최적화)",
        "details": "1. 배치 처리 유틸리티:\n```typescript\nasync function processBatch<T, R>(\n  items: T[],\n  processor: (item: T) => Promise<R>,\n  options: { concurrency: number; delayMs: number }\n): Promise<R[]> {\n  const results: R[] = [];\n  const { concurrency, delayMs } = options;\n  \n  for (let i = 0; i < items.length; i += concurrency) {\n    const batch = items.slice(i, i + concurrency);\n    const batchResults = await Promise.allSettled(\n      batch.map(item => processor(item))\n    );\n    \n    for (const result of batchResults) {\n      if (result.status === 'fulfilled') {\n        results.push(result.value);\n      } else {\n        console.error('[BATCH] Item failed:', result.reason);\n      }\n    }\n    \n    // Rate limiting delay between batches\n    if (i + concurrency < items.length) {\n      await new Promise(resolve => setTimeout(resolve, delayMs));\n    }\n  }\n  \n  return results;\n}\n```\n\n2. AI 처리에 적용:\n```typescript\nconst AI_BATCH_CONFIG = {\n  concurrency: 5, // 3에서 5로 증가 (API 한도 내에서)\n  delayMs: 1000   // 배치 간 1초 대기\n};\n\nasync function processArticlesWithAI(articles: RawArticle[], env: Env) {\n  return processBatch(\n    articles,\n    (article) => getOrProcessWithAI(article, env),\n    AI_BATCH_CONFIG\n  );\n}\n```\n\n3. Anthropic/OpenAI API 한도에 맞춰 동적 조정 고려",
        "testStrategy": "1. 다양한 배치 크기로 성능 벤치마크\n2. Rate limit 에러 발생 여부 모니터링\n3. 전체 처리 시간 측정 (목표: 2분 이내)\n4. 동시성 증가 시 API 비용 영향 분석",
        "priority": "medium",
        "dependencies": [
          "24"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:03:48.262Z"
      },
      {
        "id": 27,
        "title": "[Crawl] 처리 통계 로깅 시스템 구현",
        "description": "크롤링당 처리된 기사 수, AI API 호출 횟수, 캐시 히트율, 실행 시간 등 통계 로깅",
        "details": "1. 통계 수집 클래스:\n```typescript\nclass CrawlStats {\n  private startTime: number;\n  public articlesProcessed = 0;\n  public articlesSkipped = 0;\n  public aiApiCalls = 0;\n  public cacheHits = 0;\n  public errors = 0;\n  \n  constructor() {\n    this.startTime = Date.now();\n  }\n  \n  get duration(): number {\n    return Date.now() - this.startTime;\n  }\n  \n  get cacheHitRate(): number {\n    const total = this.aiApiCalls + this.cacheHits;\n    return total > 0 ? (this.cacheHits / total) * 100 : 0;\n  }\n  \n  toJSON() {\n    return {\n      timestamp: new Date().toISOString(),\n      duration_ms: this.duration,\n      articles_processed: this.articlesProcessed,\n      articles_skipped: this.articlesSkipped,\n      ai_api_calls: this.aiApiCalls,\n      cache_hits: this.cacheHits,\n      cache_hit_rate: this.cacheHitRate.toFixed(2) + '%',\n      errors: this.errors\n    };\n  }\n}\n```\n\n2. Supabase에 통계 테이블 생성:\n```sql\nCREATE TABLE crawl_stats (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  timestamp TIMESTAMP DEFAULT NOW(),\n  duration_ms INTEGER,\n  articles_processed INTEGER,\n  articles_skipped INTEGER,\n  ai_api_calls INTEGER,\n  cache_hits INTEGER,\n  cache_hit_rate DECIMAL(5,2),\n  errors INTEGER\n);\n```\n\n3. 크롤링 완료 시 통계 저장:\n```typescript\nasync function saveCrawlStats(stats: CrawlStats, supabase: SupabaseClient) {\n  const data = stats.toJSON();\n  console.log('[STATS]', JSON.stringify(data));\n  \n  await supabase.from('crawl_stats').insert(data);\n}\n```",
        "testStrategy": "1. 크롤링 실행 후 통계 테이블에 데이터 저장 확인\n2. 캐시 히트율 계산 정확성 검증\n3. 실행 시간 측정 정확성 확인\n4. 여러 번 실행 후 통계 추이 분석",
        "priority": "medium",
        "dependencies": [
          "25",
          "26"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:03:58.337Z"
      },
      {
        "id": 28,
        "title": "[Crawl] RSS 피드 재시도 로직 구현 (Exponential Backoff)",
        "description": "RSS 피드 실패 시 exponential backoff 재시도 로직 구현, 개별 피드 실패가 전체 크롤링에 영향 없도록 격리",
        "details": "1. Exponential backoff 재시도 함수:\n```typescript\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxRetries: number;\n    initialDelayMs: number;\n    maxDelayMs: number;\n  }\n): Promise<T> {\n  const { maxRetries, initialDelayMs, maxDelayMs } = options;\n  let lastError: Error;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      \n      if (attempt === maxRetries) break;\n      \n      const delay = Math.min(\n        initialDelayMs * Math.pow(2, attempt),\n        maxDelayMs\n      );\n      console.log(`[RETRY] Attempt ${attempt + 1} failed, retrying in ${delay}ms`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  \n  throw lastError!;\n}\n```\n\n2. RSS 피드 fetch에 적용:\n```typescript\nconst RETRY_CONFIG = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 10000\n};\n\nasync function fetchRSSFeed(feedUrl: string): Promise<RSSFeed> {\n  return fetchWithRetry(\n    async () => {\n      const response = await fetch(feedUrl, {\n        headers: { 'User-Agent': 'upday-crawler/1.0' },\n        signal: AbortSignal.timeout(10000) // 10초 타임아웃\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      return parseRSS(await response.text());\n    },\n    RETRY_CONFIG\n  );\n}\n```\n\n3. 개별 피드 실패 격리 (Task 23에서 구현된 try-catch 활용)",
        "testStrategy": "1. 일시적 네트워크 오류 시뮬레이션으로 재시도 동작 확인\n2. 최대 재시도 횟수 초과 시 적절한 에러 처리 확인\n3. Exponential backoff 지연 시간 검증\n4. 한 피드 실패 시 다른 피드 정상 처리 확인",
        "priority": "medium",
        "dependencies": [
          "23"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:04:36.187Z"
      },
      {
        "id": 29,
        "title": "[Crawl] 실패 알림 시스템 구현 (Webhook)",
        "description": "연속 실패 시 Discord/Slack webhook 또는 이메일로 알림 전송",
        "details": "1. 알림 서비스 인터페이스:\n```typescript\ninterface AlertService {\n  sendAlert(message: string, severity: 'info' | 'warning' | 'error'): Promise<void>;\n}\n\nclass DiscordAlertService implements AlertService {\n  constructor(private webhookUrl: string) {}\n  \n  async sendAlert(message: string, severity: 'info' | 'warning' | 'error') {\n    const colors = { info: 0x00ff00, warning: 0xffff00, error: 0xff0000 };\n    \n    await fetch(this.webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        embeds: [{\n          title: `[upday Crawler] ${severity.toUpperCase()}`,\n          description: message,\n          color: colors[severity],\n          timestamp: new Date().toISOString()\n        }]\n      })\n    });\n  }\n}\n```\n\n2. 연속 실패 감지 로직:\n```typescript\nasync function checkConsecutiveFailures(supabase: SupabaseClient): Promise<number> {\n  const { data } = await supabase\n    .from('crawl_stats')\n    .select('errors')\n    .order('timestamp', { ascending: false })\n    .limit(3);\n  \n  if (!data) return 0;\n  return data.filter(s => s.errors > 0).length;\n}\n\nasync function sendAlertIfNeeded(stats: CrawlStats, env: Env) {\n  const consecutiveFailures = await checkConsecutiveFailures(supabase);\n  \n  if (consecutiveFailures >= 3 || stats.errors > 5) {\n    const alertService = new DiscordAlertService(env.DISCORD_WEBHOOK_URL);\n    await alertService.sendAlert(\n      `크롤링 연속 실패 감지\\n- 연속 실패: ${consecutiveFailures}회\\n- 현재 에러: ${stats.errors}개`,\n      'error'\n    );\n  }\n}\n```\n\n3. 환경 변수에 DISCORD_WEBHOOK_URL 또는 SLACK_WEBHOOK_URL 추가",
        "testStrategy": "1. 의도적 실패 유발 후 알림 수신 확인\n2. 연속 실패 카운트 정확성 검증\n3. 알림 메시지 포맷 확인\n4. Webhook URL 미설정 시 graceful 처리 확인",
        "priority": "low",
        "dependencies": [
          "27",
          "28"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "[Crawl] GitHub Actions 백업 스케줄 업데이트",
        "description": "Cloudflare Workers 실패 대비용 GitHub Actions 스케줄을 하루 2회에서 1회로 축소 또는 수동 트리거만 유지",
        "details": "1. .github/workflows/crawl.yml 수정:\n```yaml\nname: Article Crawl (Backup)\n\non:\n  # 하루 1회 백업 실행 (UTC 12:00 = KST 21:00)\n  schedule:\n    - cron: '0 12 * * *'\n  # 수동 트리거 유지\n  workflow_dispatch:\n    inputs:\n      force:\n        description: 'Force crawl even if recently run'\n        required: false\n        default: 'false'\n\njobs:\n  crawl:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Check last Cloudflare run\n        id: check\n        run: |\n          # Supabase에서 마지막 성공 크롤링 시간 확인\n          # 4시간 이내 성공 기록 있으면 스킵\n          echo \"should_run=true\" >> $GITHUB_OUTPUT\n      \n      - name: Setup Node.js\n        if: steps.check.outputs.should_run == 'true'\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      \n      - name: Install dependencies\n        if: steps.check.outputs.should_run == 'true'\n        run: npm ci\n      \n      - name: Run crawler\n        if: steps.check.outputs.should_run == 'true'\n        env:\n          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}\n          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}\n          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n        run: npm run crawl\n```\n\n2. 중복 실행 방지 로직 추가 (Cloudflare에서 최근 성공 시 스킵)",
        "testStrategy": "1. GitHub Actions 스케줄 변경 후 실행 빈도 확인\n2. 수동 트리거 정상 동작 확인\n3. Cloudflare 성공 시 GitHub Actions 스킵 로직 검증\n4. Cloudflare 실패 시 GitHub Actions 백업 실행 확인",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:04:37.658Z"
      },
      {
        "id": 31,
        "title": "[Crawl] 일일 AI API 호출 한도 및 비용 알림 구현",
        "description": "일일 AI API 호출 한도 설정 및 한도 초과 시 알림 기능 구현 (선택사항)",
        "details": "1. 일일 API 호출 카운트 조회:\n```typescript\nasync function getDailyApiCallCount(supabase: SupabaseClient): Promise<number> {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  \n  const { data } = await supabase\n    .from('crawl_stats')\n    .select('ai_api_calls')\n    .gte('timestamp', today.toISOString());\n  \n  return data?.reduce((sum, s) => sum + s.ai_api_calls, 0) || 0;\n}\n```\n\n2. 한도 체크 및 알림:\n```typescript\nconst DAILY_API_LIMIT = 1000; // 일일 한도 설정\nconst WARNING_THRESHOLD = 0.8; // 80% 도달 시 경고\n\nasync function checkApiLimitAndAlert(currentCalls: number, env: Env) {\n  const dailyTotal = await getDailyApiCallCount(supabase);\n  const projectedTotal = dailyTotal + currentCalls;\n  \n  if (projectedTotal >= DAILY_API_LIMIT) {\n    await alertService.sendAlert(\n      `일일 AI API 한도 초과 예상\\n현재: ${dailyTotal}\\n예상 추가: ${currentCalls}\\n한도: ${DAILY_API_LIMIT}`,\n      'error'\n    );\n    // 선택: 처리 중단 또는 계속\n    return false;\n  }\n  \n  if (projectedTotal >= DAILY_API_LIMIT * WARNING_THRESHOLD) {\n    await alertService.sendAlert(\n      `일일 AI API 한도 80% 도달\\n현재: ${dailyTotal}/${DAILY_API_LIMIT}`,\n      'warning'\n    );\n  }\n  \n  return true;\n}\n```\n\n3. 환경 변수로 한도 설정 가능하게:\n```typescript\nconst DAILY_API_LIMIT = parseInt(env.DAILY_API_LIMIT || '1000');\n```",
        "testStrategy": "1. 한도 근접 시 경고 알림 발송 확인\n2. 한도 초과 시 에러 알림 발송 확인\n3. 일일 카운트 리셋 (자정 기준) 정상 동작 확인\n4. 환경 변수로 한도 조정 가능 여부 확인",
        "priority": "low",
        "dependencies": [
          "27",
          "29"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Replace window.location.href with React Router Link",
        "description": "Replace all window.location.href calls with React Router's Link component or useNavigate hook in LandingPage.tsx to prevent full page reloads and enable SPA navigation.",
        "details": "1. Open `upday/src/pages/LandingPage.tsx`\n2. Import React Router components: `import { Link, useNavigate } from 'react-router-dom';`\n3. Find all instances of `window.location.href = '/path'` or similar patterns\n4. For anchor-like navigation, replace with `<Link to=\"/path\">` component\n5. For programmatic navigation (e.g., in event handlers), use the `useNavigate` hook:\n   ```tsx\n   const navigate = useNavigate();\n   // Replace: window.location.href = '/timeline';\n   // With: navigate('/timeline');\n   ```\n6. Ensure all internal links use relative paths without the domain\n7. Keep external links (if any) using standard anchor tags with target=\"_blank\"\n8. Tag changes with `qa-improvement` in commit message\n9. Verify link destinations remain unchanged",
        "testStrategy": "1. Manual testing: Click all navigation links on LandingPage and verify no full page reload occurs (check network tab for document requests)\n2. Verify browser URL updates correctly without page flash\n3. Test browser back/forward buttons work correctly after navigation\n4. Verify all link destinations are unchanged from original behavior\n5. Test on both desktop and mobile viewports\n6. Accessibility: Ensure links are still keyboard navigable",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:13:57.256Z"
      },
      {
        "id": 33,
        "title": "Implement URL State Synchronization for Timeline Filters",
        "description": "Sync category filter and search query with URL parameters using useSearchParams from react-router-dom in TimelinePage.tsx so users can share URLs that restore the same filter/search state.",
        "details": "1. Open `upday/src/pages/TimelinePage.tsx`\n2. Import useSearchParams: `import { useSearchParams } from 'react-router-dom';`\n3. Initialize search params:\n   ```tsx\n   const [searchParams, setSearchParams] = useSearchParams();\n   ```\n4. Read initial state from URL on mount:\n   ```tsx\n   const initialCategory = searchParams.get('category') || 'all';\n   const initialQuery = searchParams.get('q') || '';\n   ```\n5. Update URL when category changes:\n   ```tsx\n   const handleCategoryChange = (category: string) => {\n     setSearchParams(prev => {\n       if (category === 'all') prev.delete('category');\n       else prev.set('category', category);\n       return prev;\n     });\n   };\n   ```\n6. Update URL when search query changes (debounce recommended):\n   ```tsx\n   const handleSearchChange = (query: string) => {\n     setSearchParams(prev => {\n       if (!query) prev.delete('q');\n       else prev.set('q', query);\n       return prev;\n     });\n   };\n   ```\n7. Ensure state syncs bidirectionally - URL changes should update component state\n8. Use useEffect to react to searchParams changes for browser back/forward support",
        "testStrategy": "1. Navigate to /timeline, select a category, verify URL updates to /timeline?category=categoryname\n2. Enter search text, verify URL updates to include ?q=searchtext\n3. Combine both: verify URL shows both params correctly\n4. Copy URL, open in new tab, verify same filters are applied\n5. Test browser back/forward buttons restore previous filter states\n6. Test clearing filters removes URL params\n7. Test direct URL entry with params applies correct filters on load",
        "priority": "high",
        "dependencies": [
          "32"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:14:31.972Z"
      },
      {
        "id": 34,
        "title": "Implement 404 Not Found Page",
        "description": "Create a user-friendly 404 page for unknown routes with clean, minimal design matching existing style and a link to return to homepage.",
        "details": "1. Create new file `upday/src/pages/NotFoundPage.tsx`:\n   ```tsx\n   import { Link } from 'react-router-dom';\n   \n   const NotFoundPage = () => {\n     return (\n       <main className=\"flex flex-col items-center justify-center min-h-[60vh] px-4 text-center\">\n         <h1 className=\"text-6xl font-bold mb-4\">404</h1>\n         <h2 className=\"text-2xl mb-4\">Page Not Found</h2>\n         <p className=\"text-gray-600 dark:text-gray-400 mb-8\">\n           The page you're looking for doesn't exist or has been moved.\n         </p>\n         <Link \n           to=\"/\" \n           className=\"px-6 py-3 bg-primary text-white rounded-lg hover:bg-primary-dark transition-colors\"\n         >\n           Return to Homepage\n         </Link>\n       </main>\n     );\n   };\n   \n   export default NotFoundPage;\n   ```\n2. Open `upday/src/App.tsx`\n3. Import NotFoundPage: `import NotFoundPage from './pages/NotFoundPage';`\n4. Add catch-all route at the END of your Routes:\n   ```tsx\n   <Route path=\"*\" element={<NotFoundPage />} />\n   ```\n5. Ensure styling matches existing design system (colors, fonts, spacing)\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Navigate to a non-existent route (e.g., /nonexistent-page) and verify 404 page displays\n2. Verify the design matches the existing site style\n3. Click 'Return to Homepage' link and verify navigation to home without page reload\n4. Test multiple invalid URLs to ensure catch-all works\n5. Verify the page is accessible (proper heading hierarchy, link is focusable)\n6. Test on mobile and desktop viewports",
        "priority": "high",
        "dependencies": [
          "32"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:15:02.526Z"
      },
      {
        "id": 35,
        "title": "Add ARIA Labels to Interactive Elements",
        "description": "Add proper ARIA labels for screen readers to Header.tsx and FilterBar.tsx components including search input, filter buttons, mobile search button, and theme toggle.",
        "details": "1. Open `upday/src/components/layout/Header.tsx`:\n   - Add aria-label to search input:\n     ```tsx\n     <input aria-label=\"Search news articles\" ... />\n     ```\n   - Add aria-label to mobile search button:\n     ```tsx\n     <button aria-label=\"Open search\" ... />\n     ```\n   - Add aria-label to theme toggle:\n     ```tsx\n     <button aria-label={isDark ? 'Switch to light mode' : 'Switch to dark mode'} ... />\n     ```\n   - Add aria-label to mobile menu button if present:\n     ```tsx\n     <button aria-label=\"Open navigation menu\" ... />\n     ```\n\n2. Open `upday/src/components/news/FilterBar.tsx`:\n   - Add aria-label to filter container:\n     ```tsx\n     <nav aria-label=\"News category filters\" ... />\n     ```\n   - For filter buttons, ensure visible text is descriptive or add aria-label:\n     ```tsx\n     <button aria-label={`Filter by ${category}`} ... />\n     ```\n\n3. Ensure all interactive elements have accessible names\n4. Tag changes with `qa-improvement`",
        "testStrategy": "1. Use screen reader (VoiceOver, NVDA, or browser accessibility tools) to navigate the header\n2. Verify search input announces 'Search news articles' or similar\n3. Verify mobile search button announces its purpose\n4. Verify theme toggle announces current action (switch to light/dark)\n5. Verify filter buttons announce their category\n6. Run axe DevTools or Lighthouse accessibility audit\n7. Test keyboard navigation through all labeled elements",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:16:00.825Z"
      },
      {
        "id": 36,
        "title": "Add aria-pressed State to FilterBar Buttons",
        "description": "Add aria-pressed attribute to category filter buttons in FilterBar.tsx to indicate selected state for screen readers.",
        "details": "1. Open `upday/src/components/news/FilterBar.tsx`\n2. Locate the category filter buttons\n3. Add aria-pressed attribute based on active state:\n   ```tsx\n   {categories.map((category) => (\n     <button\n       key={category.id}\n       aria-pressed={activeCategory === category.id}\n       onClick={() => onCategoryChange(category.id)}\n       className={/* existing classes */}\n     >\n       {category.name}\n     </button>\n   ))}\n   ```\n4. Ensure the visual styling for active state is maintained\n5. Consider adding role=\"group\" to the button container with aria-label:\n   ```tsx\n   <div role=\"group\" aria-label=\"Filter by category\">\n     {/* buttons */}\n   </div>\n   ```\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Use screen reader to navigate filter buttons\n2. Verify active button announces 'pressed' or 'selected' state\n3. Verify inactive buttons announce 'not pressed' state\n4. Click different filters and verify aria-pressed updates correctly\n5. Verify visual active state still displays correctly\n6. Run accessibility audit to confirm proper button semantics",
        "priority": "medium",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:16:02.437Z"
      },
      {
        "id": 37,
        "title": "Add Skip-to-Content Link",
        "description": "Add a skip link for keyboard users to bypass navigation and jump directly to main content area.",
        "details": "1. Open `upday/src/App.tsx` or the main layout component\n2. Add skip link as the first focusable element in the DOM:\n   ```tsx\n   <a\n     href=\"#main-content\"\n     className=\"sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-white focus:text-black focus:rounded focus:shadow-lg focus:outline-2 focus:outline-primary\"\n   >\n     Skip to main content\n   </a>\n   ```\n3. Add id to main content area:\n   ```tsx\n   <main id=\"main-content\" tabIndex={-1}>\n     {/* page content */}\n   </main>\n   ```\n4. CSS for sr-only (if not using Tailwind):\n   ```css\n   .sr-only {\n     position: absolute;\n     width: 1px;\n     height: 1px;\n     padding: 0;\n     margin: -1px;\n     overflow: hidden;\n     clip: rect(0, 0, 0, 0);\n     white-space: nowrap;\n     border: 0;\n   }\n   ```\n5. Ensure skip link appears on focus and is styled visibly\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Load page and press Tab key - skip link should be first focusable element\n2. Verify skip link becomes visible when focused\n3. Press Enter on skip link - focus should move to main content\n4. Verify skip link is visually hidden when not focused\n5. Test on multiple pages to ensure consistent behavior\n6. Test with screen reader to verify announcement",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:16:48.561Z"
      },
      {
        "id": 38,
        "title": "Fix Mobile Search Focus Management",
        "description": "Improve focus trap and management in mobile search overlay including auto-focus on open, focus return on close, escape key handling, and tab cycling within overlay.",
        "details": "1. Open `upday/src/components/layout/Header.tsx`\n2. Add ref for search input and trigger button:\n   ```tsx\n   const searchInputRef = useRef<HTMLInputElement>(null);\n   const searchTriggerRef = useRef<HTMLButtonElement>(null);\n   ```\n3. Focus input when overlay opens:\n   ```tsx\n   useEffect(() => {\n     if (isSearchOpen && searchInputRef.current) {\n       searchInputRef.current.focus();\n     }\n   }, [isSearchOpen]);\n   ```\n4. Return focus when overlay closes:\n   ```tsx\n   const closeSearch = () => {\n     setIsSearchOpen(false);\n     searchTriggerRef.current?.focus();\n   };\n   ```\n5. Handle Escape key:\n   ```tsx\n   useEffect(() => {\n     const handleEscape = (e: KeyboardEvent) => {\n       if (e.key === 'Escape' && isSearchOpen) {\n         closeSearch();\n       }\n     };\n     document.addEventListener('keydown', handleEscape);\n     return () => document.removeEventListener('keydown', handleEscape);\n   }, [isSearchOpen]);\n   ```\n6. Implement focus trap for tab cycling:\n   ```tsx\n   const handleKeyDown = (e: React.KeyboardEvent) => {\n     if (e.key === 'Tab') {\n       const focusableElements = overlayRef.current?.querySelectorAll(\n         'input, button, [tabindex]:not([tabindex=\"-1\"])'\n       );\n       // Implement tab cycling logic\n     }\n   };\n   ```\n7. Add aria-modal=\"true\" and role=\"dialog\" to overlay\n8. Tag with `qa-improvement`",
        "testStrategy": "1. Open mobile search overlay - verify input receives focus automatically\n2. Press Escape - verify overlay closes and focus returns to trigger button\n3. Tab through overlay - verify focus stays within overlay (doesn't escape to background)\n4. Shift+Tab - verify reverse tab cycling works\n5. Close overlay via close button - verify focus returns to trigger\n6. Test with screen reader to verify dialog announcement\n7. Test on actual mobile device for touch interactions",
        "priority": "medium",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:17:23.255Z"
      },
      {
        "id": 39,
        "title": "Add Live Region for Dynamic Content",
        "description": "Announce content changes to screen readers in TimelineFeed.tsx including loading state, results count, and error states using ARIA live regions.",
        "details": "1. Open `upday/src/components/news/TimelineFeed.tsx`\n2. Add a live region container for announcements:\n   ```tsx\n   const [announcement, setAnnouncement] = useState('');\n   \n   // In JSX, add visually hidden live region:\n   <div\n     role=\"status\"\n     aria-live=\"polite\"\n     aria-atomic=\"true\"\n     className=\"sr-only\"\n   >\n     {announcement}\n   </div>\n   ```\n3. Announce loading state:\n   ```tsx\n   useEffect(() => {\n     if (isLoading) {\n       setAnnouncement('Loading news articles...');\n     }\n   }, [isLoading]);\n   ```\n4. Announce results count after load:\n   ```tsx\n   useEffect(() => {\n     if (!isLoading && articles.length > 0) {\n       setAnnouncement(`Loaded ${articles.length} news articles`);\n     } else if (!isLoading && articles.length === 0) {\n       setAnnouncement('No articles found');\n     }\n   }, [isLoading, articles.length]);\n   ```\n5. Announce errors:\n   ```tsx\n   useEffect(() => {\n     if (error) {\n       setAnnouncement(`Error: ${error.message}`);\n     }\n   }, [error]);\n   ```\n6. Clear announcement after delay to prevent re-reading:\n   ```tsx\n   useEffect(() => {\n     if (announcement) {\n       const timer = setTimeout(() => setAnnouncement(''), 1000);\n       return () => clearTimeout(timer);\n     }\n   }, [announcement]);\n   ```\n7. Tag with `qa-improvement`",
        "testStrategy": "1. Enable screen reader and load TimelineFeed\n2. Verify 'Loading...' announcement when fetching\n3. Verify results count announced after load completes\n4. Apply filter and verify new count announced\n5. Trigger error state (if possible) and verify error announced\n6. Verify announcements don't interrupt other content excessively\n7. Test with different screen readers (VoiceOver, NVDA)",
        "priority": "low",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:17:53.617Z"
      },
      {
        "id": 40,
        "title": "Add Scroll-to-Top Button",
        "description": "Add a floating button to scroll back to top when user scrolls down more than 300px on TimelinePage, with smooth scroll animation and accessibility support.",
        "details": "1. Open `upday/src/pages/TimelinePage.tsx`\n2. Add state and scroll listener:\n   ```tsx\n   const [showScrollTop, setShowScrollTop] = useState(false);\n   \n   useEffect(() => {\n     const handleScroll = () => {\n       setShowScrollTop(window.scrollY > 300);\n     };\n     window.addEventListener('scroll', handleScroll, { passive: true });\n     return () => window.removeEventListener('scroll', handleScroll);\n   }, []);\n   ```\n3. Add scroll-to-top handler:\n   ```tsx\n   const scrollToTop = () => {\n     window.scrollTo({\n       top: 0,\n       behavior: 'smooth'\n     });\n   };\n   ```\n4. Add button component:\n   ```tsx\n   {showScrollTop && (\n     <button\n       onClick={scrollToTop}\n       aria-label=\"Scroll to top\"\n       className=\"fixed bottom-6 right-6 p-3 bg-primary text-white rounded-full shadow-lg hover:bg-primary-dark transition-all duration-300 z-40 focus:outline-2 focus:outline-offset-2\"\n     >\n       <ArrowUpIcon className=\"w-6 h-6\" />\n     </button>\n   )}\n   ```\n5. Add fade-in animation:\n   ```tsx\n   className={`... transition-opacity duration-300 ${showScrollTop ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}\n   ```\n6. Position button to not obstruct content (consider mobile safe areas)\n7. Tag with `qa-improvement`",
        "testStrategy": "1. Load TimelinePage and verify button is not visible initially\n2. Scroll down past 300px - verify button appears\n3. Scroll back up above 300px - verify button disappears\n4. Click button - verify smooth scroll to top\n5. Verify button is keyboard accessible (Tab to focus, Enter to activate)\n6. Verify button doesn't obstruct important content on mobile\n7. Test with screen reader - verify 'Scroll to top' announced",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:18:40.045Z"
      },
      {
        "id": 41,
        "title": "Implement Infinite Scroll",
        "description": "Replace 'Load more' button with automatic infinite scroll using IntersectionObserver in TimelineFeed.tsx while maintaining the button as a fallback.",
        "details": "1. Open `upday/src/components/news/TimelineFeed.tsx`\n2. Create a sentinel element ref:\n   ```tsx\n   const loadMoreRef = useRef<HTMLDivElement>(null);\n   ```\n3. Implement IntersectionObserver:\n   ```tsx\n   useEffect(() => {\n     if (!loadMoreRef.current || !hasMore || isLoading) return;\n     \n     const observer = new IntersectionObserver(\n       (entries) => {\n         if (entries[0].isIntersecting && hasMore && !isLoading) {\n           loadMore();\n         }\n       },\n       { rootMargin: '100px', threshold: 0 }\n     );\n     \n     observer.observe(loadMoreRef.current);\n     return () => observer.disconnect();\n   }, [hasMore, isLoading, loadMore]);\n   ```\n4. Add sentinel element at end of list:\n   ```tsx\n   <div ref={loadMoreRef} className=\"h-10\" />\n   ```\n5. Show loading indicator:\n   ```tsx\n   {isLoading && (\n     <div className=\"flex justify-center py-4\">\n       <Spinner aria-label=\"Loading more articles\" />\n     </div>\n   )}\n   ```\n6. Keep Load More button as fallback:\n   ```tsx\n   {hasMore && !isLoading && (\n     <button\n       onClick={loadMore}\n       className=\"...existing styles...\"\n     >\n       Load More\n     </button>\n   )}\n   ```\n7. Check for IntersectionObserver support:\n   ```tsx\n   const supportsObserver = 'IntersectionObserver' in window;\n   ```\n8. Tag with `qa-improvement`",
        "testStrategy": "1. Load TimelinePage with enough content to require pagination\n2. Scroll down - verify new content loads automatically before reaching bottom\n3. Verify loading indicator displays while fetching\n4. Verify Load More button still works when clicked\n5. Test in browser without IntersectionObserver support (or mock) - verify fallback works\n6. Verify no duplicate requests when scrolling quickly\n7. Test with slow network - verify loading states display correctly\n8. Verify date separators still work correctly with loaded content",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:19:17.207Z"
      },
      {
        "id": 42,
        "title": "Create About Page",
        "description": "Create an About page with honest, concise content about Upday including service introduction, technology overview, and mission statement.",
        "details": "1. Create new file `upday/src/pages/AboutPage.tsx`:\n   ```tsx\n   const AboutPage = () => {\n     return (\n       <main id=\"main-content\" className=\"container mx-auto px-4 py-8 max-w-3xl\">\n         <h1 className=\"text-3xl font-bold mb-6\">About Upday</h1>\n         \n         <section className=\"mb-8\">\n           <h2 className=\"text-xl font-semibold mb-3\">What is Upday?</h2>\n           <p className=\"text-gray-700 dark:text-gray-300\">\n             Upday is an AI-powered news aggregation service that helps you stay \n             informed about the topics that matter to you. We collect news from \n             various sources and present them in an easy-to-digest format.\n           </p>\n         </section>\n         \n         <section className=\"mb-8\">\n           <h2 className=\"text-xl font-semibold mb-3\">Our Technology</h2>\n           <p className=\"text-gray-700 dark:text-gray-300\">\n             We use artificial intelligence to summarize news articles, making it \n             easier for you to quickly understand the key points. Our AI helps \n             organize and categorize content, but we always link to original sources.\n           </p>\n         </section>\n         \n         <section className=\"mb-8\">\n           <h2 className=\"text-xl font-semibold mb-3\">Our Mission</h2>\n           <p className=\"text-gray-700 dark:text-gray-300\">\n             We believe staying informed shouldn't be time-consuming. Our mission \n             is to help users efficiently catch up on news while maintaining access \n             to diverse perspectives and original reporting.\n           </p>\n         </section>\n       </main>\n     );\n   };\n   \n   export default AboutPage;\n   ```\n2. Add route in `App.tsx`:\n   ```tsx\n   <Route path=\"/about\" element={<AboutPage />} />\n   ```\n3. Ensure styling matches existing pages\n4. Tag with `qa-improvement`",
        "testStrategy": "1. Navigate to /about and verify page renders correctly\n2. Verify content is honest and not exaggerated\n3. Verify styling matches existing site design\n4. Test responsive layout on mobile and desktop\n5. Verify proper heading hierarchy (h1, h2)\n6. Test navigation to About page from other pages\n7. Verify page is accessible (screen reader, keyboard navigation)",
        "priority": "medium",
        "dependencies": [
          "34"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:21:10.664Z"
      },
      {
        "id": 43,
        "title": "Create Feedback Page",
        "description": "Create a feedback submission page with a simple form including email and message fields, form validation, and thank you state after submission.",
        "details": "1. Create new file `upday/src/pages/FeedbackPage.tsx`:\n   ```tsx\n   import { useState } from 'react';\n   \n   const FeedbackPage = () => {\n     const [email, setEmail] = useState('');\n     const [message, setMessage] = useState('');\n     const [errors, setErrors] = useState<{email?: string; message?: string}>({});\n     const [submitted, setSubmitted] = useState(false);\n     \n     const validate = () => {\n       const newErrors: typeof errors = {};\n       if (!email) newErrors.email = 'Email is required';\n       else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n         newErrors.email = 'Please enter a valid email';\n       }\n       if (!message.trim()) newErrors.message = 'Message is required';\n       setErrors(newErrors);\n       return Object.keys(newErrors).length === 0;\n     };\n     \n     const handleSubmit = (e: React.FormEvent) => {\n       e.preventDefault();\n       if (validate()) {\n         // Submit logic here (API call or mailto)\n         setSubmitted(true);\n       }\n     };\n     \n     if (submitted) {\n       return (\n         <main className=\"container mx-auto px-4 py-8 max-w-xl text-center\">\n           <h1 className=\"text-3xl font-bold mb-4\">Thank You!</h1>\n           <p>Your feedback has been received. We appreciate your input.</p>\n         </main>\n       );\n     }\n     \n     return (\n       <main className=\"container mx-auto px-4 py-8 max-w-xl\">\n         <h1 className=\"text-3xl font-bold mb-6\">Send Feedback</h1>\n         <form onSubmit={handleSubmit} noValidate>\n           <div className=\"mb-4\">\n             <label htmlFor=\"email\" className=\"block mb-2 font-medium\">Email</label>\n             <input\n               id=\"email\"\n               type=\"email\"\n               value={email}\n               onChange={(e) => setEmail(e.target.value)}\n               aria-describedby={errors.email ? 'email-error' : undefined}\n               aria-invalid={!!errors.email}\n               className=\"w-full p-3 border rounded...\"\n             />\n             {errors.email && <p id=\"email-error\" className=\"text-red-500 mt-1\">{errors.email}</p>}\n           </div>\n           <div className=\"mb-4\">\n             <label htmlFor=\"message\" className=\"block mb-2 font-medium\">Message</label>\n             <textarea\n               id=\"message\"\n               value={message}\n               onChange={(e) => setMessage(e.target.value)}\n               rows={5}\n               aria-describedby={errors.message ? 'message-error' : undefined}\n               aria-invalid={!!errors.message}\n               className=\"w-full p-3 border rounded...\"\n             />\n             {errors.message && <p id=\"message-error\" className=\"text-red-500 mt-1\">{errors.message}</p>}\n           </div>\n           <button type=\"submit\" className=\"px-6 py-3 bg-primary text-white rounded...\">\n             Submit Feedback\n           </button>\n         </form>\n       </main>\n     );\n   };\n   ```\n2. Add route in `App.tsx`\n3. Tag with `qa-improvement`",
        "testStrategy": "1. Navigate to /feedback and verify form renders\n2. Submit empty form - verify validation errors display\n3. Enter invalid email - verify email validation error\n4. Enter valid data and submit - verify thank you state displays\n5. Verify form is accessible (labels, aria-invalid, aria-describedby)\n6. Test keyboard navigation through form\n7. Test on mobile devices for input usability",
        "priority": "medium",
        "dependencies": [
          "34"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:21:12.105Z"
      },
      {
        "id": 44,
        "title": "Persist Theme Preference to localStorage",
        "description": "Ensure theme selection persists across sessions by saving to localStorage and restoring on page load, with fallback to system preference.",
        "details": "1. Open `upday/src/components/ui/ThemeProvider.tsx`\n2. Define localStorage key constant:\n   ```tsx\n   const THEME_STORAGE_KEY = 'upday-theme-preference';\n   ```\n3. Initialize theme from localStorage or system preference:\n   ```tsx\n   const getInitialTheme = (): 'light' | 'dark' => {\n     // Check localStorage first\n     const stored = localStorage.getItem(THEME_STORAGE_KEY);\n     if (stored === 'light' || stored === 'dark') return stored;\n     \n     // Fall back to system preference\n     if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n       return 'dark';\n     }\n     return 'light';\n   };\n   \n   const [theme, setTheme] = useState<'light' | 'dark'>(getInitialTheme);\n   ```\n4. Save to localStorage when theme changes:\n   ```tsx\n   useEffect(() => {\n     localStorage.setItem(THEME_STORAGE_KEY, theme);\n     // Apply theme to document\n     document.documentElement.classList.toggle('dark', theme === 'dark');\n   }, [theme]);\n   ```\n5. Optional: Listen for system preference changes:\n   ```tsx\n   useEffect(() => {\n     const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n     const handleChange = (e: MediaQueryListEvent) => {\n       if (!localStorage.getItem(THEME_STORAGE_KEY)) {\n         setTheme(e.matches ? 'dark' : 'light');\n       }\n     };\n     mediaQuery.addEventListener('change', handleChange);\n     return () => mediaQuery.removeEventListener('change', handleChange);\n   }, []);\n   ```\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Toggle theme to dark mode, refresh page - verify dark mode persists\n2. Toggle theme to light mode, refresh page - verify light mode persists\n3. Clear localStorage, set system to dark mode, refresh - verify dark mode applied\n4. Clear localStorage, set system to light mode, refresh - verify light mode applied\n5. Verify no flash of wrong theme on page load\n6. Test in incognito mode - verify system preference is respected\n7. Verify theme toggle button state matches actual theme",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:21:39.241Z"
      },
      {
        "id": 45,
        "title": "Add Mobile Search Overlay Animation",
        "description": "Add smooth fade in/out transition animation when mobile search overlay opens/closes, respecting reduced motion preferences.",
        "details": "1. Open `upday/src/components/layout/Header.tsx`\n2. Add CSS transition classes to overlay:\n   ```tsx\n   <div\n     className={`\n       fixed inset-0 bg-white dark:bg-gray-900 z-50\n       transition-opacity duration-200 ease-in-out\n       motion-reduce:transition-none\n       ${isSearchOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}\n     `}\n     aria-hidden={!isSearchOpen}\n   >\n   ```\n3. For more complex animations, use state for animation phases:\n   ```tsx\n   const [animationState, setAnimationState] = useState<'closed' | 'opening' | 'open' | 'closing'>('closed');\n   \n   const openSearch = () => {\n     setAnimationState('opening');\n     setTimeout(() => setAnimationState('open'), 200);\n   };\n   \n   const closeSearch = () => {\n     setAnimationState('closing');\n     setTimeout(() => setAnimationState('closed'), 200);\n   };\n   ```\n4. Respect reduced motion preference:\n   ```tsx\n   const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n   \n   // Or use CSS:\n   @media (prefers-reduced-motion: reduce) {\n     .search-overlay {\n       transition: none;\n     }\n   }\n   ```\n5. Ensure no layout shift during animation\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Open mobile search - verify smooth fade-in animation\n2. Close mobile search - verify smooth fade-out animation\n3. Enable 'Reduce Motion' in OS settings - verify animation is instant/disabled\n4. Verify no layout shift or content jumping during animation\n5. Verify animation doesn't delay focus management\n6. Test animation performance on lower-end devices\n7. Verify overlay is properly hidden (pointer-events: none) when closed",
        "priority": "low",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Add FilterBar Scroll Indicators",
        "description": "Show visual fade gradient indicators on FilterBar edges when content can be scrolled horizontally, updating on scroll.",
        "details": "1. Open `upday/src/components/news/FilterBar.tsx`\n2. Add refs and state for scroll position:\n   ```tsx\n   const scrollContainerRef = useRef<HTMLDivElement>(null);\n   const [canScrollLeft, setCanScrollLeft] = useState(false);\n   const [canScrollRight, setCanScrollRight] = useState(false);\n   \n   const checkScroll = () => {\n     const el = scrollContainerRef.current;\n     if (!el) return;\n     setCanScrollLeft(el.scrollLeft > 0);\n     setCanScrollRight(el.scrollLeft < el.scrollWidth - el.clientWidth - 1);\n   };\n   \n   useEffect(() => {\n     checkScroll();\n     window.addEventListener('resize', checkScroll);\n     return () => window.removeEventListener('resize', checkScroll);\n   }, []);\n   ```\n3. Add scroll listener:\n   ```tsx\n   <div\n     ref={scrollContainerRef}\n     onScroll={checkScroll}\n     className=\"flex overflow-x-auto scrollbar-hide...\"\n   >\n   ```\n4. Add gradient overlays:\n   ```tsx\n   <div className=\"relative\">\n     {canScrollLeft && (\n       <div className=\"absolute left-0 top-0 bottom-0 w-8 bg-gradient-to-r from-white dark:from-gray-900 to-transparent pointer-events-none z-10\" />\n     )}\n     <div ref={scrollContainerRef} ...>\n       {/* filter buttons */}\n     </div>\n     {canScrollRight && (\n       <div className=\"absolute right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-white dark:from-gray-900 to-transparent pointer-events-none z-10\" />\n     )}\n   </div>\n   ```\n5. Ensure gradients match theme colors\n6. Tag with `qa-improvement`",
        "testStrategy": "1. View FilterBar on narrow screen where content overflows\n2. Verify right gradient shows when scrollable to right\n3. Scroll right - verify left gradient appears, right gradient updates\n4. Scroll to end - verify right gradient disappears\n5. Resize window wider - verify gradients disappear when no overflow\n6. Test in both light and dark themes\n7. Verify gradients don't interfere with button clicks",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Add Image Placeholder Loading",
        "description": "Show skeleton placeholder while images load in NewsCard.tsx with smooth transition to loaded image and graceful error handling.",
        "details": "1. Open `upday/src/components/news/NewsCard.tsx`\n2. Add state for image loading:\n   ```tsx\n   const [imageLoaded, setImageLoaded] = useState(false);\n   const [imageError, setImageError] = useState(false);\n   ```\n3. Create placeholder/skeleton component:\n   ```tsx\n   const ImagePlaceholder = () => (\n     <div className=\"w-full h-full bg-gray-200 dark:bg-gray-700 animate-pulse\" />\n   );\n   ```\n4. Implement image with placeholder:\n   ```tsx\n   <div className=\"relative aspect-video overflow-hidden\">\n     {!imageLoaded && !imageError && <ImagePlaceholder />}\n     {imageError ? (\n       <div className=\"w-full h-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center\">\n         <span className=\"text-gray-400\">Image unavailable</span>\n       </div>\n     ) : (\n       <img\n         src={article.imageUrl}\n         alt={article.title}\n         loading=\"lazy\"\n         onLoad={() => setImageLoaded(true)}\n         onError={() => setImageError(true)}\n         className={`\n           w-full h-full object-cover\n           transition-opacity duration-300\n           ${imageLoaded ? 'opacity-100' : 'opacity-0'}\n         `}\n       />\n     )}\n   </div>\n   ```\n5. Ensure fixed aspect ratio to prevent layout shift:\n   ```tsx\n   <div className=\"aspect-video\"> // or aspect-[16/9]\n   ```\n6. Tag with `qa-improvement`",
        "testStrategy": "1. Throttle network in DevTools to slow 3G\n2. Load page - verify skeleton placeholders show while images load\n3. Verify smooth fade-in transition when image loads\n4. Block image URL - verify error state displays gracefully\n5. Verify no layout shift when images load (fixed aspect ratio)\n6. Test with lazy loading - verify placeholders show for off-screen images\n7. Verify placeholder animation is smooth (not janky)",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Add Share Functionality to News Cards",
        "description": "Add ability to share news items via Web Share API with fallback to copy link, showing share button on hover/focus.",
        "details": "1. Open `upday/src/components/news/NewsCard.tsx`\n2. Check for Web Share API support:\n   ```tsx\n   const canShare = typeof navigator !== 'undefined' && !!navigator.share;\n   ```\n3. Implement share handler:\n   ```tsx\n   const [copied, setCopied] = useState(false);\n   \n   const handleShare = async () => {\n     const shareData = {\n       title: article.title,\n       text: article.summary,\n       url: article.sourceUrl,\n     };\n     \n     if (canShare) {\n       try {\n         await navigator.share(shareData);\n       } catch (err) {\n         if ((err as Error).name !== 'AbortError') {\n           // User cancelled, not an error\n           fallbackCopy();\n         }\n       }\n     } else {\n       fallbackCopy();\n     }\n   };\n   \n   const fallbackCopy = async () => {\n     await navigator.clipboard.writeText(article.sourceUrl);\n     setCopied(true);\n     setTimeout(() => setCopied(false), 2000);\n   };\n   ```\n4. Add share button (visible on hover/focus):\n   ```tsx\n   <button\n     onClick={handleShare}\n     aria-label={copied ? 'Link copied!' : 'Share article'}\n     className=\"\n       opacity-0 group-hover:opacity-100 focus:opacity-100\n       transition-opacity duration-200\n       p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800\n     \"\n   >\n     {copied ? <CheckIcon /> : <ShareIcon />}\n   </button>\n   ```\n5. Add `group` class to card container for hover state\n6. Ensure button is keyboard accessible\n7. Tag with `qa-improvement`",
        "testStrategy": "1. Hover over news card - verify share button appears\n2. Focus share button via keyboard - verify it becomes visible\n3. On mobile (with Web Share API) - click share, verify native share sheet opens\n4. On desktop (no Web Share API) - click share, verify link copied to clipboard\n5. Verify 'Link copied' feedback displays temporarily\n6. Verify shared URL is the original source URL, not internal URL\n7. Test keyboard accessibility of share button\n8. Verify button doesn't obstruct other card content",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "[Crawl] RSS 피드 소스 다양화 및 글로벌 테크 뉴스 소스 추가",
        "description": "TechCrunch 편중 문제를 해결하기 위해 Wired, MIT Technology Review, Reuters Tech, BBC Tech, Engadget, Rest of World 등 글로벌 신뢰성 있는 테크 뉴스 소스를 추가하고, Workers와 src/lib/crawl.ts 양쪽에 동기화하여 카테고리별 균형 있는 소스 배분을 구현",
        "details": "1. 추가할 RSS 피드 소스 목록 정의:\n```typescript\n// workers/ingest.ts 및 src/lib/crawl.ts에 동일하게 적용\nconst RSS_FEEDS = [\n  // 기존 소스\n  { url: 'https://techcrunch.com/feed/', source: 'TechCrunch', category: 'general' },\n  \n  // 신규 글로벌 소스 추가\n  { url: 'https://www.wired.com/feed/rss', source: 'Wired', category: 'general' },\n  { url: 'https://www.technologyreview.com/feed/', source: 'MIT Technology Review', category: 'research' },\n  { url: 'https://feeds.reuters.com/reuters/technologyNews', source: 'Reuters Tech', category: 'business' },\n  { url: 'https://feeds.bbci.co.uk/news/technology/rss.xml', source: 'BBC Tech', category: 'general' },\n  { url: 'https://www.engadget.com/rss.xml', source: 'Engadget', category: 'gadgets' },\n  { url: 'https://restofworld.org/feed/', source: 'Rest of World', category: 'global' },\n  \n  // AI/ML 특화 소스\n  { url: 'https://www.theverge.com/rss/ai-artificial-intelligence/index.xml', source: 'The Verge AI', category: 'ai' },\n  { url: 'https://venturebeat.com/category/ai/feed/', source: 'VentureBeat AI', category: 'ai' },\n  \n  // 스타트업/비즈니스 소스\n  { url: 'https://news.crunchbase.com/feed/', source: 'Crunchbase News', category: 'startup' },\n];\n```\n\n2. 카테고리 타입 정의 추가:\n```typescript\ntype FeedCategory = 'general' | 'ai' | 'gadgets' | 'business' | 'research' | 'startup' | 'global';\n\ninterface RSSFeed {\n  url: string;\n  source: string;\n  category: FeedCategory;\n  priority?: number; // 1-5, 높을수록 우선순위 높음\n  maxItems?: number; // 피드당 최대 아이템 수 제한\n}\n```\n\n3. 소스별 크롤링 제한 설정:\n```typescript\nconst FEED_CONFIG = {\n  maxItemsPerFeed: 10, // 피드당 최대 10개\n  maxTotalItems: 50, // 전체 최대 50개\n  categoryBalance: {\n    general: 0.3,  // 30%\n    ai: 0.25,      // 25%\n    business: 0.15, // 15%\n    gadgets: 0.1,  // 10%\n    research: 0.1, // 10%\n    startup: 0.05, // 5%\n    global: 0.05,  // 5%\n  }\n};\n```\n\n4. 공유 설정 파일 생성 (중복 방지):\n```typescript\n// src/lib/rss-feeds.ts (공유 설정)\nexport const RSS_FEEDS: RSSFeed[] = [...];\nexport const FEED_CONFIG = {...};\n\n// workers/ingest.ts에서 import\nimport { RSS_FEEDS, FEED_CONFIG } from '../src/lib/rss-feeds';\n```\n\n5. 피드 유효성 검증 로직 추가:\n```typescript\nasync function validateFeed(feed: RSSFeed): Promise<boolean> {\n  try {\n    const response = await fetch(feed.url, { \n      method: 'HEAD',\n      headers: { 'User-Agent': 'Upday News Aggregator/1.0' }\n    });\n    return response.ok && response.headers.get('content-type')?.includes('xml');\n  } catch {\n    console.warn(`[WARN] Feed validation failed: ${feed.source}`);\n    return false;\n  }\n}\n```\n\n6. 소스 균형 로직 구현:\n```typescript\nfunction balanceArticlesByCategory(articles: Article[]): Article[] {\n  const grouped = groupBy(articles, 'category');\n  const balanced: Article[] = [];\n  \n  for (const [category, ratio] of Object.entries(FEED_CONFIG.categoryBalance)) {\n    const categoryArticles = grouped[category] || [];\n    const targetCount = Math.floor(FEED_CONFIG.maxTotalItems * ratio);\n    balanced.push(...categoryArticles.slice(0, targetCount));\n  }\n  \n  return balanced.sort((a, b) => \n    new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()\n  );\n}\n```",
        "testStrategy": "1. 각 RSS 피드 URL 접근성 테스트:\n   - 모든 추가된 피드 URL이 200 응답 반환하는지 확인\n   - XML 파싱이 정상적으로 되는지 검증\n   - User-Agent 차단 여부 확인\n\n2. 소스 다양성 검증:\n   - 크롤링 후 DB에서 source별 아티클 수 쿼리\n   - TechCrunch 비율이 전체의 30% 이하인지 확인\n   - 최소 5개 이상의 다른 소스에서 아티클이 수집되는지 확인\n\n3. 카테고리 균형 테스트:\n   - 각 카테고리별 아티클 비율이 설정값 ±10% 이내인지 확인\n   - 특정 카테고리가 0개인 경우 경고 로그 확인\n\n4. Workers와 src/lib 동기화 검증:\n   - workers/ingest.ts와 src/lib/crawl.ts의 RSS_FEEDS 배열이 동일한지 diff 확인\n   - 공유 설정 파일 import가 양쪽에서 정상 동작하는지 확인\n\n5. 성능 테스트:\n   - 전체 크롤링 시간이 2분 이내인지 확인 (Task 23 기준)\n   - 개별 피드 실패 시 다른 피드 처리에 영향 없는지 확인\n\n6. 에러 핸들링 테스트:\n   - 의도적으로 잘못된 URL 추가 후 에러 격리 확인\n   - 피드 타임아웃 시 graceful degradation 확인",
        "status": "done",
        "dependencies": [
          "23"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-03T14:20:09.545Z"
      },
      {
        "id": 50,
        "title": "Design Information Architecture (IA) and UX Structure",
        "description": "Create comprehensive Information Architecture documentation for the upday service, including site structure, navigation flows, information hierarchy, user flow diagrams, and component interaction patterns based on PRD analysis.",
        "details": "1. **Service Core Analysis (Based on PRD)**\n   - Document core features: timeline-based news consumption, AI-generated summaries, category filtering\n   - Identify primary user goals: quick news scanning, deep research, topic exploration\n   - Map content types: news cards, date separators, category badges, search results\n\n2. **Site Structure and Navigation Flow**\n   ```\n   /                    → Landing Page (conversion-focused)\n   /timeline            → Main Timeline (primary experience)\n   /timeline?category=  → Filtered Timeline\n   /search?q=           → Search Results\n   /about               → About Page\n   /feedback            → Feedback Form\n   /*                   → 404 Not Found\n   ```\n\n3. **Information Hierarchy per Screen**\n   \n   **Landing Page:**\n   - L1: Hero headline + primary CTA\n   - L2: Value propositions (3 pillars)\n   - L3: Live timeline preview\n   - L4: How it works + secondary CTA\n   \n   **Timeline Page:**\n   - L1: Date separators (temporal anchoring)\n   - L2: News card titles (scannable headlines)\n   - L3: AI summaries (quick comprehension)\n   - L4: Metadata (time, category, source)\n   \n   **Search Page:**\n   - L1: Search input (persistent)\n   - L2: Active filters/query state\n   - L3: Results count + relevance\n   - L4: News cards (same hierarchy as timeline)\n\n4. **User Flow Diagrams for Key Personas**\n   \n   **Scanner Persona (80% of users):**\n   ```\n   Landing → Timeline → Scan headlines → Read summary → [Exit or Continue scanning]\n                     ↓\n              Filter by category → Focused scanning\n   ```\n   \n   **Researcher Persona (20% of users):**\n   ```\n   Landing → Timeline → Search → Review results → Click source link → External article\n                     ↓\n              Filter + Search → Cross-reference multiple articles\n   ```\n\n5. **Component Hierarchy and Interaction Patterns**\n   ```\n   App\n   ├── Header (persistent)\n   │   ├── Logo (→ /)\n   │   ├── Navigation (Timeline, About)\n   │   ├── SearchTrigger (mobile: overlay, desktop: inline)\n   │   └── ThemeToggle\n   ├── Main Content\n   │   ├── Landing: Hero → Features → Preview → CTA\n   │   ├── Timeline: CategoryFilter → DateSeparator[] → NewsCard[]\n   │   └── Search: SearchInput → FilterChips → Results[]\n   └── Footer (minimal)\n   ```\n   \n   **Interaction Patterns:**\n   - Infinite scroll for timeline (cursor-based pagination)\n   - Instant category filtering (client-side when possible)\n   - Debounced search (300ms delay)\n   - Skeleton loading states for perceived performance\n\n6. **Output: IA.txt Document Structure**\n   ```\n   # Upday Information Architecture v1.0\n   \n   ## 1. Service Overview\n   ## 2. Site Map\n   ## 3. Navigation Model\n   ## 4. Page Templates\n      - Landing Page IA\n      - Timeline Page IA\n      - Search Page IA\n   ## 5. User Flows\n      - Scanner Journey\n      - Researcher Journey\n   ## 6. Component Taxonomy\n   ## 7. Interaction Specifications\n   ## 8. Content Model\n   ## 9. Accessibility Considerations\n   ## 10. Future Expansion Points\n   ```\n\nCreate file at `docs/IA.txt` with complete specification.",
        "testStrategy": "1. **Document Completeness Check:**\n   - Verify IA.txt contains all 10 sections outlined\n   - Confirm each page (Landing, Timeline, Search) has documented hierarchy\n   - Verify both persona flows (Scanner, Researcher) are fully mapped\n\n2. **Consistency Validation:**\n   - Cross-reference IA with existing implemented pages (Landing, About, Feedback, 404)\n   - Verify component hierarchy matches actual component structure in codebase\n   - Confirm navigation paths align with React Router configuration\n\n3. **Stakeholder Review:**\n   - IA document should be understandable by non-technical stakeholders\n   - User flows should clearly show decision points and exit paths\n   - Information hierarchy should justify design decisions\n\n4. **Implementation Alignment:**\n   - Verify NewsCard component matches L2-L4 hierarchy specification\n   - Confirm DateSeparator usage aligns with L1 temporal anchoring\n   - Check category filtering matches documented interaction pattern\n\n5. **Accessibility Audit:**\n   - IA should document heading hierarchy (h1-h6) for each page\n   - Navigation flow should account for keyboard-only users\n   - Focus management patterns should be specified for overlays/modals\n\n6. **Future-Proofing:**\n   - Document should identify extension points for new features\n   - Component taxonomy should allow for new component additions\n   - Site map should show potential future routes (grayed out)",
        "status": "done",
        "dependencies": [
          "12",
          "14",
          "19",
          "34",
          "42",
          "43"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze PRD and Document Service Core Features",
            "description": "Conduct comprehensive analysis of the PRD to document core features, primary user goals, and content types for the upday service.",
            "dependencies": [],
            "details": "Review the PRD thoroughly and document: 1) Core features including timeline-based news consumption, AI-generated summaries, and category filtering. 2) Primary user goals: quick news scanning, deep research, topic exploration. 3) Content types mapping: news cards, date separators, category badges, search results. Create the initial structure for docs/IA.txt with Section 1 (Service Overview) and Section 8 (Content Model) populated based on this analysis.",
            "status": "done",
            "testStrategy": "Verify all core features from PRD are documented. Confirm user goals align with persona definitions. Validate content types are comprehensive and match existing component implementations from Task 12.",
            "updatedAt": "2026-02-03T16:08:43.663Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define Site Structure, Navigation Model, and Page Templates",
            "description": "Create detailed site map, navigation flow documentation, and page template specifications for all routes in the upday service.",
            "dependencies": [
              1
            ],
            "details": "Document the complete site structure: / (Landing Page), /timeline (Main Timeline), /timeline?category= (Filtered Timeline), /search?q= (Search Results), /about (About Page from Task 42), /feedback (Feedback Form from Task 43), /* (404 Not Found). Define navigation model including header navigation, logo behavior, and route transitions. Create page template specifications with information hierarchy levels (L1-L4) for Landing Page, Timeline Page, and Search Page. Populate Sections 2 (Site Map), 3 (Navigation Model), and 4 (Page Templates) in docs/IA.txt.",
            "status": "done",
            "testStrategy": "Cross-reference site structure with existing route implementations. Verify all pages from Tasks 42 and 43 are included. Confirm information hierarchy levels are consistent across all page templates.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T16:08:45.086Z"
          },
          {
            "id": 3,
            "title": "Design User Flow Diagrams for Key Personas",
            "description": "Create detailed user flow diagrams for Scanner and Researcher personas, mapping their complete journeys through the application.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design comprehensive user flows for: 1) Scanner Persona (80% of users): Landing → Timeline → Scan headlines → Read summary → Exit or Continue scanning, with branch for category filtering. 2) Researcher Persona (20% of users): Landing → Timeline → Search → Review results → Click source link → External article, with branch for cross-referencing multiple articles. Include decision points, alternative paths, and exit points. Document edge cases and error states. Populate Section 5 (User Flows) in docs/IA.txt with visual flow diagrams using ASCII art or structured notation.",
            "status": "done",
            "testStrategy": "Validate flows cover all primary use cases. Verify flows align with site structure from subtask 2. Test that all paths lead to valid pages. Confirm both persona journeys are complete and realistic.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T16:08:46.554Z"
          },
          {
            "id": 4,
            "title": "Document Component Taxonomy and Interaction Specifications",
            "description": "Create detailed component hierarchy documentation and specify all interaction patterns including infinite scroll, filtering, search, and loading states.",
            "dependencies": [
              1,
              2
            ],
            "details": "Document complete component taxonomy: App → Header (Logo, Navigation, SearchTrigger, ThemeToggle) → Main Content (Landing, Timeline, Search variations) → Footer. Reference existing components from Task 12 design system. Specify interaction patterns: infinite scroll with cursor-based pagination, instant category filtering (client-side when possible), debounced search (300ms delay), skeleton loading states for perceived performance. Include responsive behavior differences (mobile overlay vs desktop inline for search). Populate Sections 6 (Component Taxonomy) and 7 (Interaction Specifications) in docs/IA.txt.",
            "status": "done",
            "testStrategy": "Verify component hierarchy matches existing implementation from Task 12. Validate interaction patterns are technically feasible. Confirm responsive behaviors are documented for mobile and desktop breakpoints.",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T16:08:48.022Z"
          },
          {
            "id": 5,
            "title": "Complete IA Document with Accessibility and Future Expansion",
            "description": "Finalize the IA.txt document by adding accessibility considerations, future expansion points, and ensuring all sections are complete and consistent.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Complete the final sections of docs/IA.txt: Section 9 (Accessibility Considerations) - document keyboard navigation, screen reader support, focus management, ARIA labels, color contrast requirements, and skip links. Section 10 (Future Expansion Points) - identify potential growth areas like user accounts, saved articles, personalization, notifications, and additional content types. Review entire document for consistency, cross-reference accuracy, and completeness. Add version number (v1.0), last updated date, and table of contents. Ensure file is created at docs/IA.txt with proper formatting.",
            "status": "done",
            "testStrategy": "Verify IA.txt contains all 10 sections as outlined. Confirm document completeness check passes. Validate accessibility considerations align with WCAG guidelines. Cross-reference entire IA with existing implementations from dependent tasks (12, 42, 43).",
            "parentId": "undefined",
            "updatedAt": "2026-02-03T16:08:49.438Z"
          }
        ],
        "updatedAt": "2026-02-03T16:08:49.438Z"
      },
      {
        "id": 51,
        "title": "[Design] Sidebar 컴포넌트 구현 - Linear/Cursor 스타일",
        "description": "Linear/Cursor 스타일의 사이드바 컴포넌트를 구현하여 Feed 섹션(Live Feed)과 Companies 섹션(Pinned companies + Browse all)을 포함하고, Desktop에서는 200-240px 고정 너비, Tablet에서는 접을 수 있는 반응형 사이드바를 제공한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/layout/\n├── Sidebar.tsx           # 메인 사이드바 컴포넌트\n├── SidebarSection.tsx    # 섹션 컴포넌트 (Feed, Companies)\n├── SidebarItem.tsx       # 개별 아이템 컴포넌트\n└── SidebarContext.tsx    # 사이드바 상태 관리 (열림/닫힘)\n```\n\n### 2. Sidebar 컴포넌트 구현 (IA.txt 5.2 참고)\n```tsx\n// src/components/layout/Sidebar.tsx\n'use client';\nimport { useState, createContext, useContext } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { ChevronLeft, ChevronRight, Radio, Building2, Pin, List } from 'lucide-react';\n\ninterface SidebarContextType {\n  isCollapsed: boolean;\n  setIsCollapsed: (collapsed: boolean) => void;\n}\n\nconst SidebarContext = createContext<SidebarContextType | null>(null);\n\nexport const useSidebar = () => {\n  const context = useContext(SidebarContext);\n  if (!context) throw new Error('useSidebar must be used within SidebarProvider');\n  return context;\n};\n\nexport function Sidebar() {\n  const [isCollapsed, setIsCollapsed] = useState(false);\n  \n  return (\n    <SidebarContext.Provider value={{ isCollapsed, setIsCollapsed }}>\n      <aside\n        className={cn(\n          'h-screen bg-background border-r border-border flex flex-col transition-all duration-300',\n          'fixed left-0 top-0 z-40',\n          isCollapsed ? 'w-16' : 'w-[220px]',\n          // Tablet: 기본 접힘\n          'md:relative',\n          // Mobile: 오버레이\n          'max-md:shadow-lg'\n        )}\n      >\n        {/* 로고/브랜드 영역 */}\n        <div className=\"h-14 flex items-center px-4 border-b border-border\">\n          {!isCollapsed && <span className=\"font-semibold text-lg\">upday</span>}\n        </div>\n        \n        {/* Feed 섹션 */}\n        <SidebarSection title=\"Feed\" icon={<Radio className=\"w-4 h-4\" />}>\n          <SidebarItem icon={<Radio />} label=\"Live Feed\" href=\"/timeline\" active />\n        </SidebarSection>\n        \n        {/* Companies 섹션 */}\n        <SidebarSection title=\"Companies\" icon={<Building2 className=\"w-4 h-4\" />}>\n          <SidebarItem icon={<Pin />} label=\"Pinned\" href=\"/companies/pinned\" />\n          <SidebarItem icon={<List />} label=\"Browse all\" href=\"/companies\" />\n        </SidebarSection>\n        \n        {/* 접기/펼치기 버튼 */}\n        <div className=\"mt-auto p-2 border-t border-border\">\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setIsCollapsed(!isCollapsed)}\n            className=\"w-full justify-center\"\n            aria-label={isCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}\n          >\n            {isCollapsed ? <ChevronRight /> : <ChevronLeft />}\n          </Button>\n        </div>\n      </aside>\n    </SidebarContext.Provider>\n  );\n}\n```\n\n### 3. SidebarSection 컴포넌트\n```tsx\n// src/components/layout/SidebarSection.tsx\ninterface SidebarSectionProps {\n  title: string;\n  icon?: React.ReactNode;\n  children: React.ReactNode;\n}\n\nexport function SidebarSection({ title, icon, children }: SidebarSectionProps) {\n  const { isCollapsed } = useSidebar();\n  \n  return (\n    <div className=\"py-2\">\n      {!isCollapsed && (\n        <div className=\"px-4 py-2 text-xs font-medium text-muted-foreground uppercase tracking-wider flex items-center gap-2\">\n          {icon}\n          {title}\n        </div>\n      )}\n      <nav className=\"space-y-1 px-2\">\n        {children}\n      </nav>\n    </div>\n  );\n}\n```\n\n### 4. SidebarItem 컴포넌트\n```tsx\n// src/components/layout/SidebarItem.tsx\ninterface SidebarItemProps {\n  icon: React.ReactNode;\n  label: string;\n  href: string;\n  active?: boolean;\n}\n\nexport function SidebarItem({ icon, label, href, active }: SidebarItemProps) {\n  const { isCollapsed } = useSidebar();\n  \n  return (\n    <a\n      href={href}\n      className={cn(\n        'flex items-center gap-3 px-3 py-2 rounded-md text-sm transition-colors',\n        'hover:bg-accent hover:text-accent-foreground',\n        active && 'bg-accent text-accent-foreground font-medium',\n        isCollapsed && 'justify-center'\n      )}\n    >\n      <span className=\"w-5 h-5 flex-shrink-0\">{icon}</span>\n      {!isCollapsed && <span>{label}</span>}\n    </a>\n  );\n}\n```\n\n### 5. 반응형 동작\n- **Desktop (≥1024px)**: 220px 고정 너비, 항상 표시\n- **Tablet (768px-1023px)**: 접을 수 있는 사이드바, 기본 접힘 상태\n- **Mobile (<768px)**: 오버레이 형태, 햄버거 메뉴로 토글\n\n### 6. Linear/Cursor 스타일 특징 적용\n- 미니멀한 아이콘 + 텍스트 레이아웃\n- 부드러운 hover 트랜지션\n- 섹션 구분을 위한 subtle한 타이포그래피\n- 접힘 시 아이콘만 표시되는 compact 모드\n- 키보드 네비게이션 지원",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] Desktop(1024px+)에서 사이드바가 220px 너비로 고정 표시되는지 확인\n- [ ] Tablet(768px-1023px)에서 접기/펼치기 버튼이 동작하는지 확인\n- [ ] 접힘 상태에서 아이콘만 표시되고 너비가 64px(w-16)인지 확인\n- [ ] 펼침 상태에서 아이콘 + 라벨이 모두 표시되는지 확인\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n\n### 2. 기능 테스트\n- [ ] Feed 섹션의 \"Live Feed\" 클릭 시 /timeline으로 이동하는지 확인\n- [ ] Companies 섹션의 \"Pinned\" 클릭 시 /companies/pinned로 이동하는지 확인\n- [ ] Companies 섹션의 \"Browse all\" 클릭 시 /companies로 이동하는지 확인\n- [ ] 접기/펼치기 버튼 클릭 시 애니메이션이 부드럽게 동작하는지 확인\n- [ ] 현재 활성 페이지의 메뉴 아이템이 하이라이트되는지 확인\n\n### 3. 반응형 테스트\n- [ ] 브라우저 너비를 1024px 이상으로 설정 시 사이드바 고정 표시\n- [ ] 브라우저 너비를 768px-1023px로 설정 시 접기 가능한 사이드바\n- [ ] 브라우저 너비를 768px 미만으로 설정 시 오버레이 동작\n\n### 4. 접근성 테스트\n- [ ] Tab 키로 모든 메뉴 아이템 순회 가능한지 확인\n- [ ] Enter/Space 키로 메뉴 아이템 활성화 가능한지 확인\n- [ ] 접기/펼치기 버튼에 적절한 aria-label이 있는지 확인\n- [ ] 스크린 리더로 섹션 제목과 메뉴 아이템이 올바르게 읽히는지 확인\n\n### 5. 컴포넌트 통합 테스트\n- [ ] 기존 Button 컴포넌트가 올바르게 사용되는지 확인\n- [ ] Card 컴포넌트 스타일과 일관성 있는지 확인\n- [ ] cn() 유틸리티로 클래스 병합이 정상 동작하는지 확인\n\n### 6. 트랜지션 테스트\n- [ ] 접기/펼치기 시 width 트랜지션이 300ms로 부드럽게 동작하는지 확인\n- [ ] hover 시 배경색 변경 트랜지션이 자연스러운지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:41:10.258Z"
      },
      {
        "id": 52,
        "title": "[Design] Company Browser 페이지 구현 (/timeline/companies)",
        "description": "25개 회사를 4개 그룹(AI & LLM, Developer Tools, Productivity & SaaS, Commerce & Platform)으로 분류하여 표시하는 Company Browser 페이지를 구현하고, 그리드 레이아웃, 검색 기능, Pin/Unpin 토글(★/☆) 기능을 제공한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/app/timeline/companies/\n├── page.tsx              # Company Browser 메인 페이지\n└── loading.tsx           # 로딩 스켈레톤\n\nsrc/components/company/\n├── CompanyBrowser.tsx    # 메인 브라우저 컴포넌트\n├── CompanyGroup.tsx      # 그룹별 섹션 컴포넌트\n├── CompanyCard.tsx       # 개별 회사 카드 컴포넌트\n├── CompanySearch.tsx     # 검색 입력 컴포넌트\n└── PinButton.tsx         # Pin/Unpin 토글 버튼\n```\n\n### 2. 회사 데이터 구조 (IA.txt 6.1 참고)\n```typescript\n// src/types/company.ts\nexport interface Company {\n  id: string;\n  name: string;\n  slug: string;\n  logo?: string;\n  description?: string;\n  category: CompanyCategory;\n  isPinned: boolean;\n}\n\nexport type CompanyCategory = \n  | 'ai-llm' \n  | 'developer-tools' \n  | 'productivity-saas' \n  | 'commerce-platform';\n\nexport const COMPANY_GROUPS: Record<CompanyCategory, { label: string; companies: string[] }> = {\n  'ai-llm': {\n    label: 'AI & LLM',\n    companies: ['OpenAI', 'Anthropic', 'Google DeepMind', 'Meta AI', 'Mistral', 'Cohere', 'Stability AI']\n  },\n  'developer-tools': {\n    label: 'Developer Tools',\n    companies: ['GitHub', 'Vercel', 'Supabase', 'Cloudflare', 'Figma', 'Linear', 'Cursor']\n  },\n  'productivity-saas': {\n    label: 'Productivity & SaaS',\n    companies: ['Notion', 'Slack', 'Zoom', 'Airtable', 'Miro', 'Loom']\n  },\n  'commerce-platform': {\n    label: 'Commerce & Platform',\n    companies: ['Shopify', 'Stripe', 'Square', 'Klarna', 'Affirm']\n  }\n};\n```\n\n### 3. Company Browser 페이지 구현\n```tsx\n// src/app/timeline/companies/page.tsx\nimport { CompanyBrowser } from '@/components/company/CompanyBrowser';\n\nexport const metadata = {\n  title: 'Company Browser | upday',\n  description: 'Browse and pin companies to follow their news'\n};\n\nexport default function CompaniesPage() {\n  return (\n    <div className=\"container max-w-6xl mx-auto px-4 py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">Company Browser</h1>\n      <CompanyBrowser />\n    </div>\n  );\n}\n```\n\n### 4. CompanyBrowser 컴포넌트\n```tsx\n// src/components/company/CompanyBrowser.tsx\n'use client';\nimport { useState, useMemo } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { CompanyGroup } from './CompanyGroup';\nimport { COMPANY_GROUPS, Company, CompanyCategory } from '@/types/company';\nimport { Search } from 'lucide-react';\n\nexport function CompanyBrowser() {\n  const [searchQuery, setSearchQuery] = useState('');\n  const [pinnedCompanies, setPinnedCompanies] = useState<Set<string>>(new Set());\n\n  // localStorage에서 pinned 상태 로드\n  useEffect(() => {\n    const saved = localStorage.getItem('pinnedCompanies');\n    if (saved) setPinnedCompanies(new Set(JSON.parse(saved)));\n  }, []);\n\n  // pinned 상태 저장\n  const togglePin = (companyId: string) => {\n    setPinnedCompanies(prev => {\n      const next = new Set(prev);\n      if (next.has(companyId)) next.delete(companyId);\n      else next.add(companyId);\n      localStorage.setItem('pinnedCompanies', JSON.stringify([...next]));\n      return next;\n    });\n  };\n\n  // 검색 필터링\n  const filteredGroups = useMemo(() => {\n    if (!searchQuery.trim()) return COMPANY_GROUPS;\n    \n    const query = searchQuery.toLowerCase();\n    return Object.entries(COMPANY_GROUPS).reduce((acc, [key, group]) => {\n      const filtered = group.companies.filter(c => \n        c.toLowerCase().includes(query)\n      );\n      if (filtered.length > 0) {\n        acc[key as CompanyCategory] = { ...group, companies: filtered };\n      }\n      return acc;\n    }, {} as typeof COMPANY_GROUPS);\n  }, [searchQuery]);\n\n  return (\n    <div className=\"space-y-6\">\n      {/* 검색 입력 */}\n      <div className=\"relative\">\n        <Search className=\"absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n        <Input\n          type=\"search\"\n          placeholder=\"Search companies...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n          className=\"pl-10\"\n        />\n      </div>\n\n      {/* 그룹별 회사 목록 */}\n      <div className=\"space-y-8\">\n        {Object.entries(filteredGroups).map(([category, group]) => (\n          <CompanyGroup\n            key={category}\n            category={category as CompanyCategory}\n            label={group.label}\n            companies={group.companies}\n            pinnedCompanies={pinnedCompanies}\n            onTogglePin={togglePin}\n          />\n        ))}\n      </div>\n\n      {/* 검색 결과 없음 */}\n      {Object.keys(filteredGroups).length === 0 && (\n        <div className=\"text-center py-12 text-muted-foreground\">\n          No companies found for \"{searchQuery}\"\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n### 5. CompanyGroup 컴포넌트\n```tsx\n// src/components/company/CompanyGroup.tsx\nimport { Badge } from '@/components/ui/badge';\nimport { CompanyCard } from './CompanyCard';\nimport { CompanyCategory } from '@/types/company';\n\ninterface CompanyGroupProps {\n  category: CompanyCategory;\n  label: string;\n  companies: string[];\n  pinnedCompanies: Set<string>;\n  onTogglePin: (id: string) => void;\n}\n\nexport function CompanyGroup({ \n  category, label, companies, pinnedCompanies, onTogglePin \n}: CompanyGroupProps) {\n  return (\n    <section>\n      <div className=\"flex items-center gap-2 mb-4\">\n        <h2 className=\"text-lg font-semibold\">{label}</h2>\n        <Badge variant=\"secondary\">{companies.length}</Badge>\n      </div>\n      \n      {/* 그리드 레이아웃: 모바일 2열, 태블릿 3열, 데스크톱 4열 */}\n      <div className=\"grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3\">\n        {companies.map((company) => (\n          <CompanyCard\n            key={company}\n            name={company}\n            isPinned={pinnedCompanies.has(company)}\n            onTogglePin={() => onTogglePin(company)}\n          />\n        ))}\n      </div>\n    </section>\n  );\n}\n```\n\n### 6. CompanyCard 컴포넌트 (기존 Card 활용)\n```tsx\n// src/components/company/CompanyCard.tsx\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Star } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\ninterface CompanyCardProps {\n  name: string;\n  logo?: string;\n  isPinned: boolean;\n  onTogglePin: () => void;\n}\n\nexport function CompanyCard({ name, logo, isPinned, onTogglePin }: CompanyCardProps) {\n  return (\n    <Card className=\"group relative hover:shadow-md transition-shadow\">\n      <CardContent className=\"p-3 flex items-center gap-3\">\n        {/* 로고 또는 이니셜 */}\n        <div className=\"w-8 h-8 rounded-md bg-muted flex items-center justify-center text-sm font-medium shrink-0\">\n          {logo ? (\n            <img src={logo} alt={name} className=\"w-full h-full object-contain rounded-md\" />\n          ) : (\n            name.charAt(0).toUpperCase()\n          )}\n        </div>\n        \n        {/* 회사명 */}\n        <span className=\"text-sm font-medium truncate flex-1\">{name}</span>\n        \n        {/* Pin 버튼 */}\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          className={cn(\n            \"h-7 w-7 shrink-0\",\n            isPinned ? \"text-yellow-500\" : \"text-muted-foreground opacity-0 group-hover:opacity-100\"\n          )}\n          onClick={(e) => {\n            e.preventDefault();\n            onTogglePin();\n          }}\n          aria-label={isPinned ? 'Unpin company' : 'Pin company'}\n        >\n          <Star className={cn(\"h-4 w-4\", isPinned && \"fill-current\")} />\n        </Button>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n### 7. Sidebar 연동 (Task 51과 연계)\n- Sidebar의 \"Browse all companies\" 클릭 시 `/timeline/companies`로 이동\n- Pinned companies는 localStorage를 통해 Sidebar와 Company Browser 간 동기화\n- Sidebar에서 pinned company 클릭 시 해당 회사 뉴스 필터링 페이지로 이동",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] `/timeline/companies` 접속 시 페이지가 정상 렌더링되는지 확인\n- [ ] 4개 그룹(AI & LLM, Developer Tools, Productivity & SaaS, Commerce & Platform)이 모두 표시되는지 확인\n- [ ] 각 그룹에 올바른 회사들이 표시되는지 확인 (총 25개)\n- [ ] 그리드 레이아웃이 반응형으로 동작하는지 확인:\n  - 모바일(~639px): 2열\n  - 태블릿(640px~1023px): 3열\n  - 데스크톱(1024px+): 4열\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n\n### 2. 검색 기능 테스트\n- [ ] 검색창에 텍스트 입력 시 실시간 필터링이 동작하는지 확인\n- [ ] \"OpenAI\" 검색 시 AI & LLM 그룹에서 OpenAI만 표시되는지 확인\n- [ ] 대소문자 구분 없이 검색되는지 확인 (\"github\" = \"GitHub\")\n- [ ] 검색 결과가 없을 때 \"No companies found\" 메시지가 표시되는지 확인\n- [ ] 검색어 삭제 시 전체 목록이 다시 표시되는지 확인\n\n### 3. Pin/Unpin 기능 테스트\n- [ ] 회사 카드 hover 시 Pin 버튼(☆)이 나타나는지 확인\n- [ ] Pin 버튼 클릭 시 별이 채워지고(★) 노란색으로 변하는지 확인\n- [ ] Pinned 상태의 회사는 hover 없이도 별이 항상 표시되는지 확인\n- [ ] 페이지 새로고침 후에도 Pin 상태가 유지되는지 확인 (localStorage)\n- [ ] 여러 회사를 Pin/Unpin 해도 상태가 올바르게 관리되는지 확인\n\n### 4. 접근성 테스트\n- [ ] 키보드만으로 모든 회사 카드와 Pin 버튼에 접근 가능한지 확인\n- [ ] Pin 버튼에 적절한 aria-label이 있는지 확인\n- [ ] 검색창에 포커스 시 outline이 표시되는지 확인\n\n### 5. Sidebar 연동 테스트 (Task 51 완료 후)\n- [ ] Sidebar의 \"Browse all companies\" 클릭 시 `/timeline/companies`로 이동하는지 확인\n- [ ] Company Browser에서 Pin한 회사가 Sidebar의 Pinned companies에 반영되는지 확인\n- [ ] Sidebar에서 Unpin한 회사가 Company Browser에도 반영되는지 확인\n\n### 6. 성능 테스트\n- [ ] 25개 회사 카드가 빠르게 렌더링되는지 확인 (< 100ms)\n- [ ] 검색 입력 시 debounce 없이도 부드럽게 필터링되는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50",
          "51"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:42:32.469Z"
      },
      {
        "id": 53,
        "title": "[Design] Company Feed 헤더 및 필터 구현 (/timeline?company=openai)",
        "description": "회사 로고, 이름, Pin 버튼이 있는 헤더와 해당 회사 관련 뉴스만 필터링하는 Company Feed 페이지를 구현하고, 기존 NewsCard, Badge 컴포넌트를 활용하여 IA.txt 7.1 Company Feed Layout을 따른다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/company/\n├── CompanyFeedHeader.tsx    # 회사 헤더 컴포넌트 (로고, 이름, Pin 버튼)\n├── CompanyFeedFilter.tsx    # 회사별 뉴스 필터링 로직\n└── CompanyFeed.tsx          # 메인 Company Feed 컴포넌트\n\nsrc/app/timeline/\n└── page.tsx                 # ?company= 쿼리 파라미터 처리 추가\n```\n\n### 2. CompanyFeedHeader 컴포넌트 구현 (IA.txt 7.1 참고)\n```tsx\n// src/components/company/CompanyFeedHeader.tsx\n'use client';\nimport { useState } from 'react';\nimport Image from 'next/image';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Star, StarOff } from 'lucide-react';\nimport { Company } from '@/types/company';\nimport { cn } from '@/lib/utils';\n\ninterface CompanyFeedHeaderProps {\n  company: Company;\n  isPinned: boolean;\n  onPinToggle: (companyId: string) => void;\n}\n\nexport function CompanyFeedHeader({ company, isPinned, onPinToggle }: CompanyFeedHeaderProps) {\n  return (\n    <div className=\"flex items-center justify-between p-4 border-b border-border bg-card rounded-t-lg\">\n      <div className=\"flex items-center gap-3\">\n        {/* 회사 로고 */}\n        <div className=\"w-12 h-12 rounded-lg bg-muted flex items-center justify-center overflow-hidden\">\n          {company.logoUrl ? (\n            <Image \n              src={company.logoUrl} \n              alt={`${company.name} logo`}\n              width={48}\n              height={48}\n              className=\"object-contain\"\n            />\n          ) : (\n            <span className=\"text-xl font-bold text-muted-foreground\">\n              {company.name.charAt(0)}\n            </span>\n          )}\n        </div>\n        \n        {/* 회사 이름 및 카테고리 */}\n        <div>\n          <h1 className=\"text-xl font-semibold\">{company.name}</h1>\n          <Badge variant=\"secondary\" className=\"mt-1\">\n            {company.category}\n          </Badge>\n        </div>\n      </div>\n      \n      {/* Pin 버튼 */}\n      <Button\n        variant={isPinned ? \"default\" : \"outline\"}\n        size=\"sm\"\n        onClick={() => onPinToggle(company.id)}\n        className=\"gap-2\"\n      >\n        {isPinned ? (\n          <>\n            <Star className=\"w-4 h-4 fill-current\" />\n            Pinned\n          </>\n        ) : (\n          <>\n            <StarOff className=\"w-4 h-4\" />\n            Pin\n          </>\n        )}\n      </Button>\n    </div>\n  );\n}\n```\n\n### 3. Company Feed 필터링 로직\n```tsx\n// src/components/company/CompanyFeed.tsx\n'use client';\nimport { useSearchParams } from 'next/navigation';\nimport { useMemo } from 'react';\nimport { CompanyFeedHeader } from './CompanyFeedHeader';\nimport { NewsCard } from '@/components/news/NewsCard';\nimport { usePinnedCompanies } from '@/hooks/usePinnedCompanies';\nimport { useNews } from '@/hooks/useNews';\nimport { getCompanyById } from '@/lib/companies';\n\nexport function CompanyFeed() {\n  const searchParams = useSearchParams();\n  const companySlug = searchParams.get('company');\n  const { pinnedCompanies, togglePin } = usePinnedCompanies();\n  \n  const company = useMemo(() => \n    companySlug ? getCompanyById(companySlug) : null, \n    [companySlug]\n  );\n  \n  // 회사 관련 뉴스만 필터링\n  const { news, isLoading, loadMore, hasMore } = useNews({\n    company: companySlug || undefined,\n  });\n  \n  if (!company) {\n    return null; // 또는 기본 타임라인으로 폴백\n  }\n  \n  const isPinned = pinnedCompanies.includes(company.id);\n  \n  return (\n    <div className=\"space-y-4\">\n      <CompanyFeedHeader \n        company={company}\n        isPinned={isPinned}\n        onPinToggle={togglePin}\n      />\n      \n      <div className=\"space-y-3\">\n        {news.map((item) => (\n          <NewsCard key={item.id} article={item} />\n        ))}\n      </div>\n      \n      {hasMore && (\n        <Button \n          onClick={loadMore} \n          disabled={isLoading}\n          variant=\"outline\"\n          className=\"w-full\"\n        >\n          {isLoading ? 'Loading...' : 'Load more'}\n        </Button>\n      )}\n    </div>\n  );\n}\n```\n\n### 4. Timeline 페이지 수정\n```tsx\n// src/app/timeline/page.tsx 수정\nimport { Suspense } from 'react';\nimport { CompanyFeed } from '@/components/company/CompanyFeed';\nimport { TimelineFeed } from '@/components/timeline/TimelineFeed';\n\nexport default function TimelinePage({\n  searchParams,\n}: {\n  searchParams: { company?: string };\n}) {\n  const hasCompanyFilter = !!searchParams.company;\n  \n  return (\n    <Suspense fallback={<TimelineSkeleton />}>\n      {hasCompanyFilter ? <CompanyFeed /> : <TimelineFeed />}\n    </Suspense>\n  );\n}\n```\n\n### 5. API 필터링 확장\n```typescript\n// src/app/api/news/route.ts 수정\n// 기존 쿼리에 company 필터 추가\nconst company = searchParams.get('company');\n\nlet query = db.select().from(news);\n\nif (company) {\n  // 회사명으로 뉴스 필터링 (title, summary, content에서 회사명 검색)\n  query = query.where(\n    or(\n      ilike(news.title, `%${company}%`),\n      ilike(news.summary, `%${company}%`),\n      eq(news.companyId, company)\n    )\n  );\n}\n```\n\n### 6. URL 상태 동기화\n- `/timeline?company=openai` 형태로 URL 관리\n- 브라우저 뒤로가기/앞으로가기 지원\n- 사이드바에서 회사 클릭 시 해당 URL로 이동",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] `/timeline?company=openai` 접속 시 Company Feed 헤더가 정상 렌더링되는지 확인\n- [ ] 회사 로고가 올바르게 표시되는지 확인 (로고 없는 경우 이니셜 표시)\n- [ ] 회사 이름과 카테고리 Badge가 표시되는지 확인\n- [ ] Pin 버튼이 올바른 상태(Pinned/Pin)로 표시되는지 확인\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n- [ ] 반응형 레이아웃 테스트:\n  - 모바일(~639px): 헤더가 세로 스택으로 변경되는지 확인\n  - 태블릿/데스크톱: 가로 레이아웃 유지 확인\n\n### 2. 기능 테스트\n- [ ] `/timeline?company=openai` 접속 시 OpenAI 관련 뉴스만 표시되는지 확인\n- [ ] `/timeline?company=anthropic` 접속 시 Anthropic 관련 뉴스만 표시되는지 확인\n- [ ] Pin 버튼 클릭 시 상태가 토글되는지 확인\n- [ ] Pin 상태가 localStorage에 저장되고 새로고침 후에도 유지되는지 확인\n- [ ] 존재하지 않는 회사 slug로 접속 시 적절한 처리(기본 타임라인 또는 404)가 되는지 확인\n\n### 3. 필터링 테스트\n- [ ] API에서 company 파라미터로 필터링이 정상 동작하는지 확인\n- [ ] 필터링된 결과가 해당 회사와 관련된 뉴스만 포함하는지 확인\n- [ ] 페이지네이션(Load more)이 필터링 상태를 유지하며 동작하는지 확인\n- [ ] 필터링 결과가 없을 때 빈 상태 메시지가 표시되는지 확인\n\n### 4. URL 상태 테스트\n- [ ] 사이드바에서 회사 클릭 시 `/timeline?company={slug}` URL로 이동하는지 확인\n- [ ] 브라우저 뒤로가기 시 이전 필터 상태로 복원되는지 확인\n- [ ] URL 직접 입력으로 접속 시 올바른 회사 피드가 표시되는지 확인\n\n### 5. 통합 테스트\n- [ ] 기존 NewsCard 컴포넌트가 Company Feed에서 정상 동작하는지 확인\n- [ ] 기존 Badge 컴포넌트가 카테고리 표시에 정상 동작하는지 확인\n- [ ] Task 52의 CompanyCard에서 클릭 시 해당 Company Feed로 이동하는지 확인\n- [ ] Task 51의 Sidebar에서 Pinned company 클릭 시 해당 Company Feed로 이동하는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "15",
          "50",
          "51",
          "52"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:44:09.453Z"
      },
      {
        "id": 54,
        "title": "[Design] Pin 기능 구현 (usePinnedCompanies hook)",
        "description": "LocalStorage 기반 회사 핀 관리를 위한 usePinnedCompanies 커스텀 훅을 구현하여 핀 추가/삭제, 핀된 회사 목록 조회 기능을 제공하고, Sidebar, Company Browser, Company Feed에서 공통으로 사용할 수 있도록 한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/hooks/\n└── usePinnedCompanies.ts    # Pin 관리 커스텀 훅\n\nsrc/components/ui/\n└── toast.tsx                # Toast 알림 컴포넌트 (Undo 지원)\n\nsrc/lib/\n└── storage.ts               # LocalStorage 유틸리티 함수\n```\n\n### 2. LocalStorage 유틸리티 구현\n```typescript\n// src/lib/storage.ts\nconst PINNED_COMPANIES_KEY = 'upday_pinned_companies';\n\nexport const storage = {\n  getPinnedCompanies: (): string[] => {\n    if (typeof window === 'undefined') return [];\n    try {\n      const stored = localStorage.getItem(PINNED_COMPANIES_KEY);\n      return stored ? JSON.parse(stored) : [];\n    } catch {\n      return [];\n    }\n  },\n  \n  setPinnedCompanies: (companies: string[]): void => {\n    if (typeof window === 'undefined') return;\n    localStorage.setItem(PINNED_COMPANIES_KEY, JSON.stringify(companies));\n  },\n  \n  addPinnedCompany: (companyId: string): string[] => {\n    const current = storage.getPinnedCompanies();\n    if (!current.includes(companyId)) {\n      const updated = [...current, companyId];\n      storage.setPinnedCompanies(updated);\n      return updated;\n    }\n    return current;\n  },\n  \n  removePinnedCompany: (companyId: string): string[] => {\n    const current = storage.getPinnedCompanies();\n    const updated = current.filter(id => id !== companyId);\n    storage.setPinnedCompanies(updated);\n    return updated;\n  }\n};\n```\n\n### 3. usePinnedCompanies 훅 구현 (IA.txt 8장 참고)\n```typescript\n// src/hooks/usePinnedCompanies.ts\n'use client';\nimport { useState, useEffect, useCallback } from 'react';\nimport { storage } from '@/lib/storage';\nimport { useToast } from '@/components/ui/use-toast';\n\ninterface UsePinnedCompaniesReturn {\n  pinnedCompanies: string[];\n  isPinned: (companyId: string) => boolean;\n  pinCompany: (companyId: string, companyName: string) => void;\n  unpinCompany: (companyId: string, companyName: string) => void;\n  togglePin: (companyId: string, companyName: string) => void;\n  isLoading: boolean;\n}\n\nexport function usePinnedCompanies(): UsePinnedCompaniesReturn {\n  const [pinnedCompanies, setPinnedCompanies] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const { toast } = useToast();\n\n  // 초기 로드 (hydration 이슈 방지)\n  useEffect(() => {\n    setPinnedCompanies(storage.getPinnedCompanies());\n    setIsLoading(false);\n  }, []);\n\n  const isPinned = useCallback(\n    (companyId: string) => pinnedCompanies.includes(companyId),\n    [pinnedCompanies]\n  );\n\n  const pinCompany = useCallback(\n    (companyId: string, companyName: string) => {\n      const updated = storage.addPinnedCompany(companyId);\n      setPinnedCompanies(updated);\n      \n      toast({\n        title: `${companyName} pinned`,\n        description: 'Company added to your pinned list',\n        action: (\n          <button\n            onClick={() => {\n              const reverted = storage.removePinnedCompany(companyId);\n              setPinnedCompanies(reverted);\n            }}\n            className=\"text-sm font-medium underline\"\n          >\n            Undo\n          </button>\n        ),\n        duration: 5000,\n      });\n    },\n    [toast]\n  );\n\n  const unpinCompany = useCallback(\n    (companyId: string, companyName: string) => {\n      const previousState = [...pinnedCompanies];\n      const updated = storage.removePinnedCompany(companyId);\n      setPinnedCompanies(updated);\n      \n      toast({\n        title: `${companyName} unpinned`,\n        description: 'Company removed from your pinned list',\n        action: (\n          <button\n            onClick={() => {\n              storage.setPinnedCompanies(previousState);\n              setPinnedCompanies(previousState);\n            }}\n            className=\"text-sm font-medium underline\"\n          >\n            Undo\n          </button>\n        ),\n        duration: 5000,\n      });\n    },\n    [pinnedCompanies, toast]\n  );\n\n  const togglePin = useCallback(\n    (companyId: string, companyName: string) => {\n      if (isPinned(companyId)) {\n        unpinCompany(companyId, companyName);\n      } else {\n        pinCompany(companyId, companyName);\n      }\n    },\n    [isPinned, pinCompany, unpinCompany]\n  );\n\n  return {\n    pinnedCompanies,\n    isPinned,\n    pinCompany,\n    unpinCompany,\n    togglePin,\n    isLoading,\n  };\n}\n```\n\n### 4. Toast 컴포넌트 설정 (shadcn/ui 기반)\n```bash\nnpx shadcn-ui@latest add toast\n```\n\n### 5. 사용 예시 (Sidebar, Company Browser, Company Feed)\n```tsx\n// Sidebar에서 사용\nconst { pinnedCompanies, isLoading } = usePinnedCompanies();\n\n// Company Browser에서 사용\nconst { isPinned, togglePin } = usePinnedCompanies();\n<PinButton \n  isPinned={isPinned(company.id)} \n  onClick={() => togglePin(company.id, company.name)} \n/>\n\n// Company Feed Header에서 사용\nconst { isPinned, togglePin } = usePinnedCompanies();\n<Button onClick={() => togglePin(companyId, companyName)}>\n  {isPinned(companyId) ? '★ Pinned' : '☆ Pin'}\n</Button>\n```\n\n### 6. 핀 개수 제한 (선택적)\n```typescript\nconst MAX_PINNED_COMPANIES = 10;\n\nconst pinCompany = useCallback(\n  (companyId: string, companyName: string) => {\n    if (pinnedCompanies.length >= MAX_PINNED_COMPANIES) {\n      toast({\n        title: 'Pin limit reached',\n        description: `You can pin up to ${MAX_PINNED_COMPANIES} companies`,\n        variant: 'destructive',\n      });\n      return;\n    }\n    // ... 기존 로직\n  },\n  [pinnedCompanies.length, toast]\n);\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 단위 테스트 (usePinnedCompanies 훅)\n- [ ] 초기 로드 시 LocalStorage에서 핀된 회사 목록을 정상적으로 불러오는지 확인\n- [ ] `isPinned(companyId)` 함수가 핀 상태를 정확히 반환하는지 확인\n- [ ] `pinCompany()` 호출 시 LocalStorage에 회사가 추가되는지 확인\n- [ ] `unpinCompany()` 호출 시 LocalStorage에서 회사가 제거되는지 확인\n- [ ] `togglePin()` 함수가 핀 상태를 올바르게 토글하는지 확인\n- [ ] 중복 핀 추가 시 중복이 발생하지 않는지 확인\n\n### 2. LocalStorage 테스트\n- [ ] 브라우저 새로고침 후에도 핀 상태가 유지되는지 확인\n- [ ] LocalStorage가 비어있을 때 빈 배열을 반환하는지 확인\n- [ ] 잘못된 JSON 데이터가 저장되어 있을 때 에러 없이 빈 배열을 반환하는지 확인\n- [ ] SSR 환경(window undefined)에서 에러 없이 동작하는지 확인\n\n### 3. Toast 알림 테스트\n- [ ] 회사 핀 추가 시 \"Company pinned\" Toast가 표시되는지 확인\n- [ ] 회사 핀 해제 시 \"Company unpinned\" Toast가 표시되는지 확인\n- [ ] Toast에 Undo 버튼이 표시되는지 확인\n- [ ] Undo 버튼 클릭 시 이전 상태로 복원되는지 확인\n- [ ] Toast가 5초 후 자동으로 사라지는지 확인\n\n### 4. 통합 테스트 (컴포넌트 연동)\n- [ ] Sidebar에서 핀된 회사 목록이 정상적으로 표시되는지 확인\n- [ ] Company Browser에서 Pin 버튼(★/☆) 클릭 시 상태가 변경되는지 확인\n- [ ] Company Feed Header에서 Pin 버튼이 올바른 상태로 표시되는지 확인\n- [ ] 한 컴포넌트에서 핀 상태 변경 시 다른 컴포넌트에도 반영되는지 확인 (페이지 이동 후)\n\n### 5. Hydration 테스트\n- [ ] SSR 렌더링과 클라이언트 렌더링 간 불일치(hydration mismatch)가 발생하지 않는지 확인\n- [ ] `isLoading` 상태를 활용하여 초기 로딩 중 스켈레톤이 표시되는지 확인\n\n### 6. 엣지 케이스 테스트\n- [ ] 핀 개수 제한(10개) 도달 시 경고 Toast가 표시되는지 확인 (선택적 구현 시)\n- [ ] 존재하지 않는 회사 ID로 핀 해제 시도 시 에러가 발생하지 않는지 확인\n- [ ] 빠른 연속 클릭 시 상태가 올바르게 유지되는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50",
          "51",
          "52",
          "53"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:46:03.343Z"
      },
      {
        "id": 55,
        "title": "[Design] Mobile Bottom Sheet 네비게이션 구현",
        "description": "모바일에서 햄버거 메뉴 클릭 시 하단에서 올라오는 Bottom Sheet 네비게이션을 구현하여 Feed 섹션, Companies 섹션(Pinned + Browse all)을 포함하고, 반투명 오버레이와 스와이프로 닫기 기능을 제공한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/mobile/\n├── BottomSheet.tsx           # 재사용 가능한 Bottom Sheet 컴포넌트\n├── MobileNavSheet.tsx        # 네비게이션용 Bottom Sheet\n└── MobileNavContent.tsx      # 네비게이션 콘텐츠 (Feed, Companies)\n```\n\n### 2. BottomSheet 기본 컴포넌트 구현 (IA.txt 9.3 참고)\n```tsx\n// src/components/mobile/BottomSheet.tsx\n'use client';\nimport { useEffect, useRef, useState } from 'react';\nimport { cn } from '@/lib/utils';\n\ninterface BottomSheetProps {\n  isOpen: boolean;\n  onClose: () => void;\n  children: React.ReactNode;\n  className?: string;\n}\n\nexport function BottomSheet({ isOpen, onClose, children, className }: BottomSheetProps) {\n  const sheetRef = useRef<HTMLDivElement>(null);\n  const [dragY, setDragY] = useState(0);\n  const [isDragging, setIsDragging] = useState(false);\n  const startY = useRef(0);\n\n  // 스와이프로 닫기 로직\n  const handleTouchStart = (e: React.TouchEvent) => {\n    startY.current = e.touches[0].clientY;\n    setIsDragging(true);\n  };\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (!isDragging) return;\n    const currentY = e.touches[0].clientY;\n    const diff = currentY - startY.current;\n    if (diff > 0) {\n      setDragY(diff);\n    }\n  };\n\n  const handleTouchEnd = () => {\n    setIsDragging(false);\n    if (dragY > 100) {\n      onClose();\n    }\n    setDragY(0);\n  };\n\n  // ESC 키로 닫기\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && isOpen) {\n        onClose();\n      }\n    };\n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [isOpen, onClose]);\n\n  // 스크롤 잠금\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n    }\n    return () => {\n      document.body.style.overflow = '';\n    };\n  }, [isOpen]);\n\n  if (!isOpen) return null;\n\n  return (\n    <>\n      {/* 반투명 오버레이 */}\n      <div\n        className=\"fixed inset-0 bg-black/50 z-40 transition-opacity duration-300\"\n        onClick={onClose}\n        aria-hidden=\"true\"\n      />\n      \n      {/* Bottom Sheet */}\n      <div\n        ref={sheetRef}\n        className={cn(\n          \"fixed bottom-0 left-0 right-0 z-50\",\n          \"bg-white dark:bg-gray-900\",\n          \"rounded-t-2xl shadow-xl\",\n          \"transform transition-transform duration-300 ease-out\",\n          \"motion-reduce:transition-none\",\n          isOpen ? \"translate-y-0\" : \"translate-y-full\",\n          className\n        )}\n        style={{ transform: `translateY(${dragY}px)` }}\n        onTouchStart={handleTouchStart}\n        onTouchMove={handleTouchMove}\n        onTouchEnd={handleTouchEnd}\n        role=\"dialog\"\n        aria-modal=\"true\"\n      >\n        {/* 드래그 핸들 */}\n        <div className=\"flex justify-center pt-3 pb-2\">\n          <div className=\"w-10 h-1 bg-gray-300 dark:bg-gray-600 rounded-full\" />\n        </div>\n        \n        {children}\n      </div>\n    </>\n  );\n}\n```\n\n### 3. MobileNavSheet 구현\n```tsx\n// src/components/mobile/MobileNavSheet.tsx\n'use client';\nimport { BottomSheet } from './BottomSheet';\nimport { MobileNavContent } from './MobileNavContent';\n\ninterface MobileNavSheetProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nexport function MobileNavSheet({ isOpen, onClose }: MobileNavSheetProps) {\n  return (\n    <BottomSheet isOpen={isOpen} onClose={onClose}>\n      <MobileNavContent onItemClick={onClose} />\n    </BottomSheet>\n  );\n}\n```\n\n### 4. MobileNavContent 구현 (IA.txt 9.3 참고)\n```tsx\n// src/components/mobile/MobileNavContent.tsx\n'use client';\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\nimport { usePinnedCompanies } from '@/hooks/usePinnedCompanies';\nimport { COMPANIES } from '@/data/companies';\nimport { cn } from '@/lib/utils';\nimport { Rss, Building2, Star, Grid3X3 } from 'lucide-react';\n\ninterface MobileNavContentProps {\n  onItemClick: () => void;\n}\n\nexport function MobileNavContent({ onItemClick }: MobileNavContentProps) {\n  const pathname = usePathname();\n  const { pinnedCompanies } = usePinnedCompanies();\n  \n  const pinnedCompanyData = COMPANIES.filter(c => pinnedCompanies.includes(c.id));\n\n  return (\n    <nav className=\"px-4 pb-8 max-h-[70vh] overflow-y-auto\">\n      {/* Feed 섹션 */}\n      <section className=\"mb-6\">\n        <h3 className=\"text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2\">\n          Feed\n        </h3>\n        <Link\n          href=\"/timeline\"\n          onClick={onItemClick}\n          className={cn(\n            \"flex items-center gap-3 px-3 py-2.5 rounded-lg\",\n            \"text-sm font-medium\",\n            pathname === '/timeline' && !pathname.includes('company')\n              ? \"bg-primary/10 text-primary\"\n              : \"text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800\"\n          )}\n        >\n          <Rss className=\"w-5 h-5\" />\n          Live Feed\n        </Link>\n      </section>\n\n      {/* Companies 섹션 */}\n      <section>\n        <h3 className=\"text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2\">\n          Companies\n        </h3>\n        \n        {/* Pinned Companies */}\n        {pinnedCompanyData.length > 0 && (\n          <div className=\"mb-3\">\n            {pinnedCompanyData.map(company => (\n              <Link\n                key={company.id}\n                href={`/timeline?company=${company.id}`}\n                onClick={onItemClick}\n                className={cn(\n                  \"flex items-center gap-3 px-3 py-2.5 rounded-lg\",\n                  \"text-sm font-medium\",\n                  pathname.includes(`company=${company.id}`)\n                    ? \"bg-primary/10 text-primary\"\n                    : \"text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800\"\n                )}\n              >\n                <Star className=\"w-4 h-4 text-yellow-500 fill-yellow-500\" />\n                {company.name}\n              </Link>\n            ))}\n          </div>\n        )}\n        \n        {/* Browse all */}\n        <Link\n          href=\"/timeline/companies\"\n          onClick={onItemClick}\n          className={cn(\n            \"flex items-center gap-3 px-3 py-2.5 rounded-lg\",\n            \"text-sm font-medium\",\n            pathname === '/timeline/companies'\n              ? \"bg-primary/10 text-primary\"\n              : \"text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800\"\n          )}\n        >\n          <Grid3X3 className=\"w-5 h-5\" />\n          Browse all companies\n        </Link>\n      </section>\n    </nav>\n  );\n}\n```\n\n### 5. Header에 햄버거 메뉴 연동\n```tsx\n// src/components/layout/Header.tsx 수정\nimport { MobileNavSheet } from '@/components/mobile/MobileNavSheet';\nimport { Menu } from 'lucide-react';\n\n// 컴포넌트 내부\nconst [isNavOpen, setIsNavOpen] = useState(false);\n\n// 모바일에서만 표시되는 햄버거 버튼\n<Button\n  variant=\"ghost\"\n  size=\"icon\"\n  className=\"md:hidden\"\n  onClick={() => setIsNavOpen(true)}\n  aria-label=\"메뉴 열기\"\n>\n  <Menu className=\"w-5 h-5\" />\n</Button>\n\n<MobileNavSheet isOpen={isNavOpen} onClose={() => setIsNavOpen(false)} />\n```\n\n### 6. 애니메이션 및 접근성 고려사항\n- `motion-reduce:transition-none` 클래스로 reduced motion 지원\n- `role=\"dialog\"`, `aria-modal=\"true\"` 속성으로 스크린 리더 지원\n- 포커스 트랩 구현 (열릴 때 첫 번째 링크로 포커스 이동)\n- ESC 키로 닫기 지원",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] 모바일 뷰포트(~767px)에서 햄버거 메뉴 버튼이 표시되는지 확인\n- [ ] 햄버거 메뉴 클릭 시 Bottom Sheet가 하단에서 올라오는지 확인\n- [ ] 반투명 오버레이(bg-black/50)가 정상 표시되는지 확인\n- [ ] 드래그 핸들이 상단 중앙에 표시되는지 확인\n- [ ] Feed 섹션과 Companies 섹션이 올바르게 표시되는지 확인\n- [ ] Pinned companies가 있을 경우 별 아이콘과 함께 표시되는지 확인\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n- [ ] 현재 활성 페이지가 하이라이트되는지 확인\n\n### 2. 인터랙션 테스트\n- [ ] 오버레이 클릭 시 Bottom Sheet가 닫히는지 확인\n- [ ] 아래로 스와이프(100px 이상) 시 Bottom Sheet가 닫히는지 확인\n- [ ] 스와이프 중 드래그 거리에 따라 시트가 따라 움직이는지 확인\n- [ ] 100px 미만 스와이프 시 원래 위치로 돌아오는지 확인\n- [ ] ESC 키 입력 시 Bottom Sheet가 닫히는지 확인\n- [ ] 메뉴 아이템 클릭 시 해당 페이지로 이동하고 시트가 닫히는지 확인\n\n### 3. 접근성 테스트\n- [ ] 스크린 리더에서 dialog로 인식되는지 확인\n- [ ] Bottom Sheet 열릴 때 배경 스크롤이 잠기는지 확인\n- [ ] Bottom Sheet 닫힐 때 스크롤 잠금이 해제되는지 확인\n- [ ] 키보드로 모든 메뉴 아이템에 접근 가능한지 확인\n- [ ] 'Reduce Motion' 설정 시 애니메이션이 비활성화되는지 확인\n\n### 4. 반응형 테스트\n- [ ] 태블릿(768px+)에서 햄버거 메뉴가 숨겨지는지 확인\n- [ ] 데스크톱에서 Sidebar가 대신 표시되는지 확인\n- [ ] 화면 회전 시 Bottom Sheet가 정상 동작하는지 확인\n\n### 5. 통합 테스트\n- [ ] usePinnedCompanies 훅과 연동하여 핀된 회사가 표시되는지 확인\n- [ ] 회사 핀/언핀 후 Bottom Sheet 재오픈 시 목록이 업데이트되는지 확인\n- [ ] 다양한 모바일 기기(iOS Safari, Android Chrome)에서 터치 이벤트가 정상 동작하는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50",
          "51",
          "54"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:46:04.767Z"
      },
      {
        "id": 56,
        "title": "[Design] Category 시스템 UI 업데이트 (6개→5개)",
        "description": "FilterBar에서 기존 6개 카테고리(ai, startup, science, design, space, dev)를 5개(ai, startups, dev, product, research)로 변경하고, Badge 색상 매핑을 업데이트한다. migration-v2.md 문서를 참고하여 구현한다.",
        "details": "## 구현 상세\n\n### 1. 변경 사항 요약\n- **기존 카테고리 (6개):** ai, startup, science, design, space, dev\n- **신규 카테고리 (5개):** ai, startups, dev, product, research\n\n### 2. FilterBar 카테고리 업데이트\n```typescript\n// src/components/news/FilterBar.tsx\nconst CATEGORIES = [\n  { id: 'all', label: 'All' },\n  { id: 'ai', label: 'AI' },\n  { id: 'startups', label: 'Startups' },  // startup → startups (복수형)\n  { id: 'dev', label: 'Dev' },\n  { id: 'product', label: 'Product' },    // 신규 (design 대체)\n  { id: 'research', label: 'Research' },  // 신규 (science, space 통합)\n] as const;\n\nexport type CategoryId = typeof CATEGORIES[number]['id'];\n```\n\n### 3. Badge 색상 매핑 업데이트\n```typescript\n// src/components/ui/badge.tsx 또는 src/lib/category-colors.ts\nexport const CATEGORY_COLORS: Record<string, { bg: string; text: string; border?: string }> = {\n  ai: {\n    bg: 'bg-purple-100 dark:bg-purple-900/30',\n    text: 'text-purple-700 dark:text-purple-300',\n  },\n  startups: {\n    bg: 'bg-green-100 dark:bg-green-900/30',\n    text: 'text-green-700 dark:text-green-300',\n  },\n  dev: {\n    bg: 'bg-blue-100 dark:bg-blue-900/30',\n    text: 'text-blue-700 dark:text-blue-300',\n  },\n  product: {\n    bg: 'bg-orange-100 dark:bg-orange-900/30',\n    text: 'text-orange-700 dark:text-orange-300',\n  },\n  research: {\n    bg: 'bg-cyan-100 dark:bg-cyan-900/30',\n    text: 'text-cyan-700 dark:text-cyan-300',\n  },\n};\n```\n\n### 4. CategoryBadge 컴포넌트 업데이트\n```tsx\n// src/components/news/CategoryBadge.tsx\nimport { Badge } from '@/components/ui/badge';\nimport { CATEGORY_COLORS } from '@/lib/category-colors';\nimport { cn } from '@/lib/utils';\n\ninterface CategoryBadgeProps {\n  category: string;\n  className?: string;\n}\n\nexport function CategoryBadge({ category, className }: CategoryBadgeProps) {\n  const colors = CATEGORY_COLORS[category.toLowerCase()] || {\n    bg: 'bg-gray-100 dark:bg-gray-800',\n    text: 'text-gray-700 dark:text-gray-300',\n  };\n\n  return (\n    <Badge className={cn(colors.bg, colors.text, className)}>\n      {category}\n    </Badge>\n  );\n}\n```\n\n### 5. 타입 정의 업데이트\n```typescript\n// src/types/news.ts 또는 src/types/category.ts\nexport type Category = 'ai' | 'startups' | 'dev' | 'product' | 'research';\n\nexport const VALID_CATEGORIES: Category[] = ['ai', 'startups', 'dev', 'product', 'research'];\n\nexport function isValidCategory(value: string): value is Category {\n  return VALID_CATEGORIES.includes(value as Category);\n}\n```\n\n### 6. URL 파라미터 호환성 처리\n```typescript\n// src/lib/category-utils.ts\n// 기존 URL에서 사용된 카테고리를 새 카테고리로 매핑\nexport const CATEGORY_MIGRATION_MAP: Record<string, string> = {\n  startup: 'startups',    // 단수 → 복수\n  science: 'research',    // science → research\n  space: 'research',      // space → research\n  design: 'product',      // design → product\n};\n\nexport function migrateCategory(category: string): string {\n  return CATEGORY_MIGRATION_MAP[category] || category;\n}\n```\n\n### 7. migration-v2.md 참고 사항\n- 기존 데이터의 카테고리 값이 변경되었을 수 있으므로 API 응답 처리 시 마이그레이션 매핑 적용\n- 북마크나 저장된 필터 설정이 있다면 마이그레이션 로직 추가 필요",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] FilterBar에 5개 카테고리(All, AI, Startups, Dev, Product, Research)가 표시되는지 확인\n- [ ] 기존 6개 카테고리(science, design, space)가 더 이상 표시되지 않는지 확인\n- [ ] 각 카테고리 Badge가 올바른 색상으로 표시되는지 확인:\n  - AI: 보라색 계열\n  - Startups: 초록색 계열\n  - Dev: 파란색 계열\n  - Product: 주황색 계열\n  - Research: 청록색 계열\n- [ ] Light/Dark 모드에서 Badge 색상이 올바르게 적용되는지 확인\n\n### 2. 기능 테스트\n- [ ] 각 카테고리 클릭 시 필터링이 정상 동작하는지 확인\n- [ ] 카테고리 선택 시 URL 파라미터가 올바르게 업데이트되는지 확인 (예: ?category=startups)\n- [ ] 기존 URL 파라미터 호환성 테스트:\n  - `/timeline?category=startup` → `startups`로 자동 마이그레이션\n  - `/timeline?category=science` → `research`로 자동 마이그레이션\n  - `/timeline?category=space` → `research`로 자동 마이그레이션\n  - `/timeline?category=design` → `product`로 자동 마이그레이션\n\n### 3. 반응형 테스트\n- [ ] 모바일 뷰포트에서 FilterBar 가로 스크롤이 정상 동작하는지 확인\n- [ ] 태블릿/데스크톱에서 모든 카테고리가 한 줄에 표시되는지 확인\n\n### 4. 통합 테스트\n- [ ] NewsCard에 표시되는 CategoryBadge가 새 색상 매핑을 사용하는지 확인\n- [ ] Company Feed에서 카테고리 필터링이 새 카테고리로 동작하는지 확인\n- [ ] 검색 결과에서 카테고리 Badge가 올바르게 표시되는지 확인\n\n### 5. 타입 안전성 테스트\n- [ ] TypeScript 컴파일 에러가 없는지 확인\n- [ ] 잘못된 카테고리 값 입력 시 기본값(all)으로 폴백되는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "33",
          "46",
          "50"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:46:06.190Z"
      },
      {
        "id": 57,
        "title": "[Design] Timeline 페이지 레이아웃 리뉴얼 - 사이드바 + 콘텐츠 2컬럼 레이아웃",
        "description": "기존 TimelinePage.tsx를 사이드바 + 메인 콘텐츠 2컬럼 레이아웃으로 리뉴얼하여 Desktop에서는 사이드바 고정, Tablet에서는 접히는 사이드바를 제공하고, IA.txt 5.1 Desktop Layout 가이드라인을 따른다.",
        "details": "## 구현 상세\n\n### 1. 파일 수정 대상\n```\nsrc/app/timeline/\n├── page.tsx              # 메인 Timeline 페이지 레이아웃 수정\n└── layout.tsx            # Timeline 전용 레이아웃 (신규 생성 또는 수정)\n```\n\n### 2. 2컬럼 레이아웃 구조 (IA.txt 5.1 참고)\n```tsx\n// src/app/timeline/layout.tsx\n'use client';\nimport { Sidebar } from '@/components/layout/Sidebar';\nimport { SidebarProvider } from '@/components/layout/SidebarContext';\n\nexport default function TimelineLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <SidebarProvider>\n      <div className=\"flex min-h-screen\">\n        {/* Sidebar - Desktop: 고정, Tablet: 접히는 사이드바 */}\n        <Sidebar />\n        \n        {/* Main Content Area */}\n        <main className=\"flex-1 min-w-0\">\n          {children}\n        </main>\n      </div>\n    </SidebarProvider>\n  );\n}\n```\n\n### 3. TimelinePage.tsx 수정\n```tsx\n// src/app/timeline/page.tsx\nimport { TimelineFeed } from '@/components/news/TimelineFeed';\nimport { FilterBar } from '@/components/news/FilterBar';\n\nexport default function TimelinePage() {\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* 상단 필터 영역 */}\n      <div className=\"sticky top-0 z-10 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b\">\n        <div className=\"px-4 md:px-6 py-3\">\n          <FilterBar />\n        </div>\n      </div>\n      \n      {/* 메인 콘텐츠 영역 */}\n      <div className=\"flex-1 overflow-auto\">\n        <div className=\"max-w-3xl mx-auto px-4 md:px-6 py-6\">\n          <TimelineFeed />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n### 4. 반응형 레이아웃 브레이크포인트\n```css\n/* Desktop (1024px+): 사이드바 고정 + 메인 콘텐츠 */\n@media (min-width: 1024px) {\n  .sidebar { width: 220px; position: fixed; }\n  .main-content { margin-left: 220px; }\n}\n\n/* Tablet (768px - 1023px): 접히는 사이드바 */\n@media (min-width: 768px) and (max-width: 1023px) {\n  .sidebar { \n    width: 64px; /* 접힌 상태 */\n    /* 펼침 상태: width: 220px */\n  }\n  .main-content { margin-left: 64px; }\n}\n\n/* Mobile (~767px): 사이드바 숨김, Bottom Sheet 사용 */\n@media (max-width: 767px) {\n  .sidebar { display: none; }\n  .main-content { margin-left: 0; }\n}\n```\n\n### 5. Tailwind CSS 클래스 적용\n```tsx\n// 레이아웃 컨테이너\n<div className=\"flex min-h-screen\">\n  {/* Sidebar */}\n  <aside className=\"hidden md:flex md:w-16 lg:w-[220px] flex-shrink-0 border-r bg-sidebar\">\n    <Sidebar />\n  </aside>\n  \n  {/* Main Content */}\n  <main className=\"flex-1 min-w-0 md:ml-16 lg:ml-[220px]\">\n    {children}\n  </main>\n</div>\n```\n\n### 6. 기존 컴포넌트 통합\n- Task 51에서 구현한 Sidebar 컴포넌트 import\n- Task 15에서 구현한 TimelineFeed, FilterBar 컴포넌트 유지\n- Task 56에서 업데이트된 카테고리 시스템 반영\n\n### 7. 스크롤 동작 처리\n```tsx\n// 메인 콘텐츠 영역 스크롤 설정\n<main className=\"flex-1 overflow-y-auto h-screen\">\n  {/* 사이드바는 고정, 메인 콘텐츠만 스크롤 */}\n</main>\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] `/timeline` 접속 시 2컬럼 레이아웃이 정상 렌더링되는지 확인\n- [ ] Desktop(1024px+)에서 사이드바가 220px 너비로 고정 표시되는지 확인\n- [ ] Desktop에서 메인 콘텐츠가 사이드바 옆에 올바르게 배치되는지 확인\n- [ ] Tablet(768px-1023px)에서 접히는 사이드바가 동작하는지 확인\n- [ ] Tablet에서 사이드바 접힘 시 64px 너비로 아이콘만 표시되는지 확인\n- [ ] Mobile(~767px)에서 사이드바가 숨겨지는지 확인\n- [ ] Light/Dark 모드에서 레이아웃 스타일이 올바르게 적용되는지 확인\n\n### 2. 레이아웃 기능 테스트\n- [ ] 사이드바가 스크롤 시에도 고정 위치를 유지하는지 확인\n- [ ] 메인 콘텐츠 영역만 독립적으로 스크롤되는지 확인\n- [ ] FilterBar가 상단에 sticky로 고정되는지 확인\n- [ ] 뉴스 카드들이 max-w-3xl 내에서 중앙 정렬되는지 확인\n\n### 3. 반응형 테스트\n- [ ] 브라우저 창 크기 조절 시 레이아웃이 부드럽게 전환되는지 확인\n- [ ] Desktop → Tablet 전환 시 사이드바가 접히는지 확인\n- [ ] Tablet → Mobile 전환 시 사이드바가 숨겨지는지 확인\n- [ ] Mobile → Tablet → Desktop 역방향 전환도 정상 동작하는지 확인\n\n### 4. 통합 테스트\n- [ ] Sidebar 컴포넌트(Task 51)가 정상적으로 통합되는지 확인\n- [ ] Feed 섹션 클릭 시 /timeline으로 이동하는지 확인\n- [ ] Companies 섹션의 Pinned companies가 표시되는지 확인\n- [ ] \"Browse all\" 클릭 시 /timeline/companies로 이동하는지 확인\n- [ ] FilterBar 카테고리 필터가 정상 동작하는지 확인\n- [ ] 무한 스크롤/Load more 기능이 정상 동작하는지 확인\n\n### 5. 접근성 테스트\n- [ ] 키보드 네비게이션으로 사이드바 항목 접근 가능한지 확인\n- [ ] 스크린 리더에서 레이아웃 구조가 올바르게 인식되는지 확인\n- [ ] 사이드바 접기/펼치기 버튼에 적절한 aria-label이 있는지 확인\n\n### 6. 성능 테스트\n- [ ] 레이아웃 전환 시 깜빡임이나 레이아웃 시프트가 없는지 확인\n- [ ] 스크롤 성능이 부드러운지 확인 (60fps 유지)\n- [ ] 사이드바 애니메이션이 부드럽게 동작하는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "15",
          "50",
          "51",
          "56"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:46:07.602Z"
      },
      {
        "id": 58,
        "title": "[Design] Toast 컴포넌트 구현 - 액션 피드백용",
        "description": "핀 추가/삭제 등 사용자 액션에 대한 피드백을 제공하는 Toast 컴포넌트를 구현하고, Undo 버튼 지원, 화면 우하단 표시, 3초 후 자동 사라짐 기능을 포함한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/ui/\n├── toast.tsx              # Toast 컴포넌트\n├── toaster.tsx            # Toast 컨테이너 (여러 Toast 관리)\n└── use-toast.ts           # Toast 상태 관리 훅\n\nsrc/lib/\n└── toast-context.tsx      # Toast Context Provider\n```\n\n### 2. Toast 타입 정의\n```typescript\n// src/components/ui/use-toast.ts\nexport interface Toast {\n  id: string;\n  message: string;\n  type?: 'success' | 'error' | 'info' | 'warning';\n  duration?: number;  // 기본값 3000ms\n  action?: {\n    label: string;    // 예: \"Undo\"\n    onClick: () => void;\n  };\n}\n\nexport interface ToastState {\n  toasts: Toast[];\n}\n```\n\n### 3. Toast 컴포넌트 구현\n```tsx\n// src/components/ui/toast.tsx\n'use client';\nimport { useEffect, useState } from 'react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { X, CheckCircle, AlertCircle, Info, AlertTriangle } from 'lucide-react';\n\ninterface ToastProps {\n  id: string;\n  message: string;\n  type?: 'success' | 'error' | 'info' | 'warning';\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  onClose: (id: string) => void;\n  duration?: number;\n}\n\nconst iconMap = {\n  success: CheckCircle,\n  error: AlertCircle,\n  info: Info,\n  warning: AlertTriangle,\n};\n\nconst styleMap = {\n  success: 'bg-green-50 dark:bg-green-950 border-green-200 dark:border-green-800 text-green-800 dark:text-green-200',\n  error: 'bg-red-50 dark:bg-red-950 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200',\n  info: 'bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800 text-blue-800 dark:text-blue-200',\n  warning: 'bg-yellow-50 dark:bg-yellow-950 border-yellow-200 dark:border-yellow-800 text-yellow-800 dark:text-yellow-200',\n};\n\nexport function Toast({ id, message, type = 'info', action, onClose, duration = 3000 }: ToastProps) {\n  const [isVisible, setIsVisible] = useState(true);\n  const [isExiting, setIsExiting] = useState(false);\n  const Icon = iconMap[type];\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsExiting(true);\n      setTimeout(() => onClose(id), 300); // 애니메이션 후 제거\n    }, duration);\n\n    return () => clearTimeout(timer);\n  }, [id, duration, onClose]);\n\n  const handleClose = () => {\n    setIsExiting(true);\n    setTimeout(() => onClose(id), 300);\n  };\n\n  return (\n    <div\n      className={cn(\n        'flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg',\n        'transition-all duration-300 ease-in-out',\n        isExiting ? 'opacity-0 translate-x-4' : 'opacity-100 translate-x-0',\n        styleMap[type]\n      )}\n      role=\"alert\"\n    >\n      <Icon className=\"w-5 h-5 flex-shrink-0\" />\n      <span className=\"flex-1 text-sm font-medium\">{message}</span>\n      \n      {action && (\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={() => {\n            action.onClick();\n            handleClose();\n          }}\n          className=\"text-current hover:bg-black/10 dark:hover:bg-white/10\"\n        >\n          {action.label}\n        </Button>\n      )}\n      \n      <button\n        onClick={handleClose}\n        className=\"p-1 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors\"\n        aria-label=\"닫기\"\n      >\n        <X className=\"w-4 h-4\" />\n      </button>\n    </div>\n  );\n}\n```\n\n### 4. Toaster 컨테이너 구현\n```tsx\n// src/components/ui/toaster.tsx\n'use client';\nimport { Toast } from './toast';\nimport { useToast } from './use-toast';\n\nexport function Toaster() {\n  const { toasts, removeToast } = useToast();\n\n  return (\n    <div\n      className=\"fixed bottom-4 right-4 z-50 flex flex-col gap-2 max-w-sm w-full\"\n      aria-live=\"polite\"\n      aria-label=\"알림\"\n    >\n      {toasts.map((toast) => (\n        <Toast\n          key={toast.id}\n          {...toast}\n          onClose={removeToast}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n### 5. useToast 훅 구현\n```typescript\n// src/components/ui/use-toast.ts\n'use client';\nimport { create } from 'zustand';\n\ninterface Toast {\n  id: string;\n  message: string;\n  type?: 'success' | 'error' | 'info' | 'warning';\n  duration?: number;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n}\n\ninterface ToastStore {\n  toasts: Toast[];\n  addToast: (toast: Omit<Toast, 'id'>) => string;\n  removeToast: (id: string) => void;\n  clearToasts: () => void;\n}\n\nexport const useToast = create<ToastStore>((set, get) => ({\n  toasts: [],\n  addToast: (toast) => {\n    const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    set((state) => ({\n      toasts: [...state.toasts, { ...toast, id }],\n    }));\n    return id;\n  },\n  removeToast: (id) => {\n    set((state) => ({\n      toasts: state.toasts.filter((t) => t.id !== id),\n    }));\n  },\n  clearToasts: () => set({ toasts: [] }),\n}));\n\n// 편의 함수\nexport const toast = {\n  success: (message: string, options?: Partial<Omit<Toast, 'id' | 'message' | 'type'>>) =>\n    useToast.getState().addToast({ message, type: 'success', ...options }),\n  error: (message: string, options?: Partial<Omit<Toast, 'id' | 'message' | 'type'>>) =>\n    useToast.getState().addToast({ message, type: 'error', ...options }),\n  info: (message: string, options?: Partial<Omit<Toast, 'id' | 'message' | 'type'>>) =>\n    useToast.getState().addToast({ message, type: 'info', ...options }),\n  warning: (message: string, options?: Partial<Omit<Toast, 'id' | 'message' | 'type'>>) =>\n    useToast.getState().addToast({ message, type: 'warning', ...options }),\n};\n```\n\n### 6. Pin 기능과 연동 예시\n```typescript\n// usePinnedCompanies 훅에서 사용 예시\nimport { toast } from '@/components/ui/use-toast';\n\nconst pinCompany = (companyId: string, companyName: string) => {\n  // 핀 추가 로직...\n  const previousPinned = [...pinnedCompanies];\n  \n  toast.success(`${companyName} pinned`, {\n    action: {\n      label: 'Undo',\n      onClick: () => {\n        // Undo 로직: 이전 상태로 복원\n        setPinnedCompanies(previousPinned);\n      },\n    },\n  });\n};\n\nconst unpinCompany = (companyId: string, companyName: string) => {\n  // 핀 제거 로직...\n  const previousPinned = [...pinnedCompanies];\n  \n  toast.info(`${companyName} unpinned`, {\n    action: {\n      label: 'Undo',\n      onClick: () => {\n        setPinnedCompanies(previousPinned);\n      },\n    },\n  });\n};\n```\n\n### 7. 디자인 시스템 토큰 활용\n- 기존 CSS 변수 활용: `--background`, `--foreground`, `--border`, `--radius`\n- oklch 색상 시스템과 호환\n- Light/Dark 모드 자동 지원\n- 기존 Button, Card 컴포넌트 스타일과 일관성 유지",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] Toast가 화면 우하단(bottom-4 right-4)에 정상 표시되는지 확인\n- [ ] 4가지 타입(success, error, info, warning)별 스타일이 올바르게 적용되는지 확인\n- [ ] 각 타입별 아이콘이 올바르게 표시되는지 확인\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n- [ ] 여러 Toast가 동시에 표시될 때 세로로 쌓이는지 확인 (gap-2)\n- [ ] Toast 최대 너비가 max-w-sm으로 제한되는지 확인\n\n### 2. 기능 테스트\n- [ ] Toast가 3초(기본값) 후 자동으로 사라지는지 확인\n- [ ] duration 옵션으로 표시 시간을 변경할 수 있는지 확인\n- [ ] X 버튼 클릭 시 Toast가 즉시 사라지는지 확인\n- [ ] Undo 버튼 클릭 시 action.onClick이 호출되는지 확인\n- [ ] Undo 버튼 클릭 후 Toast가 닫히는지 확인\n- [ ] toast.success(), toast.error(), toast.info(), toast.warning() 함수가 정상 동작하는지 확인\n\n### 3. 애니메이션 테스트\n- [ ] Toast 등장 시 fade-in + slide-in 애니메이션이 적용되는지 확인\n- [ ] Toast 사라질 때 fade-out + slide-out 애니메이션이 적용되는지 확인\n- [ ] 애니메이션 duration이 300ms인지 확인\n\n### 4. 접근성 테스트\n- [ ] Toast 컨테이너에 aria-live=\"polite\" 속성이 있는지 확인\n- [ ] 각 Toast에 role=\"alert\" 속성이 있는지 확인\n- [ ] 닫기 버튼에 aria-label이 있는지 확인\n- [ ] 키보드로 Undo 버튼과 닫기 버튼에 접근 가능한지 확인\n\n### 5. 통합 테스트\n- [ ] Pin 추가 시 \"Company pinned\" Toast가 표시되는지 확인\n- [ ] Pin 제거 시 \"Company unpinned\" Toast가 표시되는지 확인\n- [ ] Undo 클릭 시 Pin 상태가 이전으로 복원되는지 확인\n- [ ] 여러 Pin 액션을 빠르게 수행해도 Toast가 정상 동작하는지 확인\n\n### 6. 반응형 테스트\n- [ ] 모바일에서 Toast가 화면 너비에 맞게 표시되는지 확인\n- [ ] 태블릿/데스크톱에서 Toast가 max-w-sm 너비로 표시되는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50",
          "54"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-04T01:49:35.270Z"
      },
      {
        "id": 59,
        "title": "[Design] Landing 페이지 Social Proof 섹션 추가",
        "description": "Landing 페이지에 사용자 수, 처리된 기사 수, 크롤링 소스 수 등 통계를 표시하는 Social Proof 섹션을 추가하여 서비스 신뢰도를 높이고, Hero 섹션 아래 또는 Features 섹션 위에 배치한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/landing/\n├── SocialProofSection.tsx    # Social Proof 메인 섹션 컴포넌트\n├── StatCard.tsx              # 개별 통계 카드 컴포넌트\n└── AnimatedCounter.tsx       # 숫자 애니메이션 컴포넌트 (선택적)\n```\n\n### 2. 통계 데이터 구조\n```typescript\n// src/types/stats.ts\nexport interface StatItem {\n  id: string;\n  label: string;\n  value: number;\n  suffix?: string;  // '+', 'K', 'M' 등\n  prefix?: string;  // '$' 등\n  icon?: React.ReactNode;\n}\n\n// 표시할 통계 항목\nconst SOCIAL_PROOF_STATS: StatItem[] = [\n  { id: 'users', label: 'Active Users', value: 10000, suffix: '+' },\n  { id: 'articles', label: 'Articles Processed', value: 500, suffix: 'K+' },\n  { id: 'sources', label: 'News Sources', value: 25, suffix: '+' },\n  { id: 'companies', label: 'Companies Tracked', value: 25, suffix: '' },\n];\n```\n\n### 3. SocialProofSection 컴포넌트 구현\n```tsx\n// src/components/landing/SocialProofSection.tsx\n'use client';\nimport { Card } from '@/components/ui/card';\nimport { cn } from '@/lib/utils';\n\ninterface SocialProofSectionProps {\n  className?: string;\n}\n\nexport function SocialProofSection({ className }: SocialProofSectionProps) {\n  return (\n    <section className={cn(\n      'py-12 md:py-16 lg:py-20',\n      'bg-muted/30',  // 배경 구분을 위한 subtle 배경색\n      className\n    )}>\n      <div className=\"container mx-auto px-4\">\n        {/* 섹션 헤더 (선택적) */}\n        <div className=\"text-center mb-8 md:mb-12\">\n          <p className=\"text-sm font-medium text-muted-foreground uppercase tracking-wider\">\n            Trusted by thousands\n          </p>\n        </div>\n        \n        {/* 통계 그리드 */}\n        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-6 lg:gap-8\">\n          {SOCIAL_PROOF_STATS.map((stat) => (\n            <StatCard key={stat.id} stat={stat} />\n          ))}\n        </div>\n      </div>\n    </section>\n  );\n}\n```\n\n### 4. StatCard 컴포넌트 구현 (기존 Card 활용)\n```tsx\n// src/components/landing/StatCard.tsx\n'use client';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { cn } from '@/lib/utils';\nimport { StatItem } from '@/types/stats';\n\ninterface StatCardProps {\n  stat: StatItem;\n  className?: string;\n}\n\nexport function StatCard({ stat, className }: StatCardProps) {\n  return (\n    <Card className={cn(\n      'text-center p-6',\n      'bg-background/50 backdrop-blur-sm',\n      'border-border/50',\n      'hover:border-primary/30 transition-colors',\n      className\n    )}>\n      <CardContent className=\"p-0\">\n        {/* 아이콘 (선택적) */}\n        {stat.icon && (\n          <div className=\"mb-3 flex justify-center text-primary\">\n            {stat.icon}\n          </div>\n        )}\n        \n        {/* 숫자 값 */}\n        <div className=\"text-3xl md:text-4xl lg:text-5xl font-bold text-foreground mb-2\">\n          {stat.prefix}\n          {stat.value.toLocaleString()}\n          {stat.suffix}\n        </div>\n        \n        {/* 라벨 */}\n        <p className=\"text-sm md:text-base text-muted-foreground\">\n          {stat.label}\n        </p>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n### 5. AnimatedCounter 컴포넌트 (선택적 - UX 향상)\n```tsx\n// src/components/landing/AnimatedCounter.tsx\n'use client';\nimport { useEffect, useState, useRef } from 'react';\n\ninterface AnimatedCounterProps {\n  value: number;\n  duration?: number;  // 애니메이션 지속 시간 (ms)\n}\n\nexport function AnimatedCounter({ value, duration = 2000 }: AnimatedCounterProps) {\n  const [count, setCount] = useState(0);\n  const ref = useRef<HTMLSpanElement>(null);\n  const hasAnimated = useRef(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && !hasAnimated.current) {\n          hasAnimated.current = true;\n          animateValue(0, value, duration);\n        }\n      },\n      { threshold: 0.5 }\n    );\n\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return () => observer.disconnect();\n  }, [value, duration]);\n\n  const animateValue = (start: number, end: number, duration: number) => {\n    const startTime = performance.now();\n    \n    const animate = (currentTime: number) => {\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      // easeOutQuart easing\n      const eased = 1 - Math.pow(1 - progress, 4);\n      const current = Math.floor(start + (end - start) * eased);\n      \n      setCount(current);\n      \n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n    \n    requestAnimationFrame(animate);\n  };\n\n  return <span ref={ref}>{count.toLocaleString()}</span>;\n}\n```\n\n### 6. Landing 페이지에 섹션 추가\n```tsx\n// src/app/page.tsx 또는 src/components/landing/LandingPage.tsx\nimport { HeroSection } from '@/components/landing/HeroSection';\nimport { SocialProofSection } from '@/components/landing/SocialProofSection';\nimport { FeaturesSection } from '@/components/landing/FeaturesSection';\n\nexport default function LandingPage() {\n  return (\n    <main>\n      <HeroSection />\n      <SocialProofSection />  {/* Hero 아래, Features 위에 배치 */}\n      <FeaturesSection />\n      {/* ... 기타 섹션 */}\n    </main>\n  );\n}\n```\n\n### 7. 디자인 가이드라인\n- **배경**: Hero와 Features 사이 시각적 구분을 위해 subtle한 배경색 사용 (bg-muted/30)\n- **간격**: 충분한 상하 패딩으로 섹션 구분 (py-12 ~ py-20)\n- **반응형**: 모바일 2열, 태블릿/데스크톱 4열 그리드\n- **카드 스타일**: 기존 Card 컴포넌트 활용, 투명도와 backdrop-blur로 모던한 느낌\n- **타이포그래피**: 숫자는 크고 bold하게, 라벨은 작고 muted하게",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 테스트\n- [ ] Landing 페이지(`/`)에서 Social Proof 섹션이 Hero 아래, Features 위에 정상 표시되는지 확인\n- [ ] 4개 통계 항목(Active Users, Articles Processed, News Sources, Companies Tracked)이 모두 표시되는지 확인\n- [ ] 각 통계 카드가 기존 Card 컴포넌트 스타일을 따르는지 확인\n- [ ] Light/Dark 모드에서 스타일이 올바르게 적용되는지 확인\n- [ ] 섹션 배경색이 Hero/Features와 시각적으로 구분되는지 확인\n\n### 2. 반응형 테스트\n- [ ] 모바일(~639px): 2열 그리드로 표시되는지 확인\n- [ ] 태블릿(640px~1023px): 4열 그리드로 표시되는지 확인\n- [ ] 데스크톱(1024px+): 4열 그리드로 표시되는지 확인\n- [ ] 각 브레이크포인트에서 카드 간격이 적절한지 확인 (gap-4 ~ gap-8)\n- [ ] 숫자 폰트 크기가 반응형으로 조절되는지 확인 (text-3xl ~ text-5xl)\n\n### 3. 기능 테스트\n- [ ] 숫자가 올바른 포맷으로 표시되는지 확인 (천 단위 구분자, suffix 등)\n- [ ] AnimatedCounter 구현 시: 스크롤하여 섹션이 뷰포트에 들어올 때 애니메이션이 시작되는지 확인\n- [ ] AnimatedCounter 구현 시: 애니메이션이 한 번만 실행되는지 확인 (재스크롤 시 재실행 안 됨)\n\n### 4. 접근성 테스트\n- [ ] 스크린 리더가 통계 값과 라벨을 올바르게 읽는지 확인\n- [ ] 충분한 색상 대비가 유지되는지 확인 (WCAG AA 기준)\n- [ ] 키보드 네비게이션이 가능한지 확인 (hover 효과가 있는 경우)\n\n### 5. 성능 테스트\n- [ ] AnimatedCounter 애니메이션이 60fps로 부드럽게 동작하는지 확인\n- [ ] IntersectionObserver가 메모리 누수 없이 정상 해제되는지 확인\n- [ ] 페이지 로드 시 레이아웃 시프트(CLS)가 발생하지 않는지 확인\n\n### 6. 통합 테스트\n- [ ] 기존 Landing 페이지 컴포넌트들과 충돌 없이 동작하는지 확인\n- [ ] 페이지 전체 스크롤 시 섹션 간 전환이 자연스러운지 확인\n- [ ] 다른 섹션의 스타일에 영향을 주지 않는지 확인",
        "status": "done",
        "dependencies": [
          "12",
          "50"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-04T02:03:46.600Z"
      },
      {
        "id": 60,
        "title": "[Infra] Twitter 자동 포스팅 파이프라인 구현 - RSS Feed 연동",
        "description": "Upday의 RSS Feed(/feed.xml)를 활용하여 새 기사가 발행될 때마다 자동으로 Twitter에 포스팅하는 시스템을 구축하고, Zapier/IFTTT 연동 가이드 또는 자체 스크립트를 구현하여 브랜드 검색량 증가와 소셜 시그널 확보를 목표로 한다.",
        "details": "## 구현 상세\n\n### 1. RSS Feed 확인 및 준비\n```\n/feed.xml 또는 /rss.xml 엔드포인트 확인\n- 기사 제목, 요약, URL, 발행일, 카테고리 포함 여부 확인\n- RSS 2.0 또는 Atom 형식 준수 여부 확인\n```\n\n### 2. 옵션 A: Zapier/IFTTT 연동 가이드 작성\n```markdown\n## Zapier 설정 가이드\n\n### Step 1: Trigger 설정\n- App: RSS by Zapier\n- Trigger Event: New Item in Feed\n- Feed URL: https://upday.ai/feed.xml\n\n### Step 2: Action 설정\n- App: Twitter\n- Action Event: Create Tweet\n- Message Template:\n  ```\n  📰 {{title}}\n  \n  {{description | truncate: 100}}\n  \n  🔗 {{link}}\n  \n  #AI뉴스 #테크뉴스 #Upday\n  ```\n\n### Step 3: 필터 설정 (선택)\n- 특정 카테고리만 포스팅\n- 특정 키워드 포함 기사만 포스팅\n```\n\n### 3. 옵션 B: 자체 스크립트 구현\n```typescript\n// scripts/twitter-auto-post.ts\nimport Parser from 'rss-parser';\nimport { TwitterApi } from 'twitter-api-v2';\n\ninterface FeedItem {\n  title: string;\n  link: string;\n  pubDate: string;\n  contentSnippet?: string;\n  categories?: string[];\n}\n\nconst RSS_FEED_URL = process.env.RSS_FEED_URL || 'https://upday.ai/feed.xml';\nconst TWITTER_API_KEY = process.env.TWITTER_API_KEY;\nconst TWITTER_API_SECRET = process.env.TWITTER_API_SECRET;\nconst TWITTER_ACCESS_TOKEN = process.env.TWITTER_ACCESS_TOKEN;\nconst TWITTER_ACCESS_SECRET = process.env.TWITTER_ACCESS_SECRET;\n\n// Twitter 클라이언트 초기화\nconst twitterClient = new TwitterApi({\n  appKey: TWITTER_API_KEY!,\n  appSecret: TWITTER_API_SECRET!,\n  accessToken: TWITTER_ACCESS_TOKEN!,\n  accessSecret: TWITTER_ACCESS_SECRET!,\n});\n\n// RSS 파서 초기화\nconst parser = new Parser();\n\n// 마지막 포스팅 시간 저장 (Redis 또는 파일)\nlet lastPostedTime: Date | null = null;\n\nasync function fetchNewArticles(): Promise<FeedItem[]> {\n  const feed = await parser.parseURL(RSS_FEED_URL);\n  \n  return feed.items\n    .filter(item => {\n      const pubDate = new Date(item.pubDate || '');\n      return !lastPostedTime || pubDate > lastPostedTime;\n    })\n    .map(item => ({\n      title: item.title || '',\n      link: item.link || '',\n      pubDate: item.pubDate || '',\n      contentSnippet: item.contentSnippet,\n      categories: item.categories,\n    }));\n}\n\nfunction formatTweet(article: FeedItem): string {\n  const maxTitleLength = 100;\n  const title = article.title.length > maxTitleLength \n    ? article.title.substring(0, maxTitleLength - 3) + '...'\n    : article.title;\n  \n  const hashtags = generateHashtags(article.categories);\n  \n  return `📰 ${title}\\n\\n🔗 ${article.link}\\n\\n${hashtags}`;\n}\n\nfunction generateHashtags(categories?: string[]): string {\n  const baseHashtags = ['#AI뉴스', '#테크뉴스', '#Upday'];\n  const categoryHashtags: Record<string, string> = {\n    'ai': '#인공지능',\n    'startups': '#스타트업',\n    'dev': '#개발',\n    'product': '#프로덕트',\n    'research': '#연구',\n  };\n  \n  const tags = [...baseHashtags];\n  categories?.forEach(cat => {\n    if (categoryHashtags[cat.toLowerCase()]) {\n      tags.push(categoryHashtags[cat.toLowerCase()]);\n    }\n  });\n  \n  return tags.slice(0, 5).join(' ');\n}\n\nasync function postToTwitter(article: FeedItem): Promise<void> {\n  const tweet = formatTweet(article);\n  \n  try {\n    await twitterClient.v2.tweet(tweet);\n    console.log(`✅ Posted: ${article.title}`);\n    lastPostedTime = new Date(article.pubDate);\n  } catch (error) {\n    console.error(`❌ Failed to post: ${article.title}`, error);\n    throw error;\n  }\n}\n\nexport async function runTwitterAutoPost(): Promise<void> {\n  console.log('🔄 Checking for new articles...');\n  \n  const newArticles = await fetchNewArticles();\n  \n  if (newArticles.length === 0) {\n    console.log('📭 No new articles found');\n    return;\n  }\n  \n  console.log(`📬 Found ${newArticles.length} new article(s)`);\n  \n  // 가장 오래된 것부터 포스팅 (시간순)\n  const sortedArticles = newArticles.sort(\n    (a, b) => new Date(a.pubDate).getTime() - new Date(b.pubDate).getTime()\n  );\n  \n  for (const article of sortedArticles) {\n    await postToTwitter(article);\n    // Rate limit 방지를 위한 딜레이\n    await new Promise(resolve => setTimeout(resolve, 5000));\n  }\n}\n```\n\n### 4. Cron Job 설정 (Vercel/GitHub Actions)\n```yaml\n# .github/workflows/twitter-auto-post.yml\nname: Twitter Auto Post\n\non:\n  schedule:\n    - cron: '*/30 * * * *'  # 30분마다 실행\n  workflow_dispatch:  # 수동 실행 가능\n\njobs:\n  post:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm ci\n      - run: npm run twitter:post\n        env:\n          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}\n          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}\n          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_SECRET: ${{ secrets.TWITTER_ACCESS_SECRET }}\n          RSS_FEED_URL: ${{ secrets.RSS_FEED_URL }}\n```\n\n### 5. 환경 변수 설정\n```env\n# .env.local\nTWITTER_API_KEY=your_api_key\nTWITTER_API_SECRET=your_api_secret\nTWITTER_ACCESS_TOKEN=your_access_token\nTWITTER_ACCESS_SECRET=your_access_secret\nRSS_FEED_URL=https://upday.ai/feed.xml\n```\n\n### 6. 문서화\n```\ndocs/\n└── twitter-auto-posting.md  # 설정 가이드 및 트러블슈팅\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. RSS Feed 테스트\n- [ ] `/feed.xml` 엔드포인트가 정상 응답하는지 확인\n- [ ] RSS Feed에 필수 필드(title, link, pubDate)가 포함되어 있는지 확인\n- [ ] RSS 파서가 Feed를 정상적으로 파싱하는지 확인\n- [ ] 새 기사 필터링 로직이 정상 동작하는지 확인\n\n### 2. Twitter API 테스트\n- [ ] Twitter API 인증이 정상적으로 되는지 확인\n- [ ] 테스트 트윗이 정상적으로 포스팅되는지 확인\n- [ ] 트윗 길이가 280자를 초과하지 않는지 확인\n- [ ] Rate limit 처리가 정상 동작하는지 확인\n\n### 3. 트윗 포맷 테스트\n- [ ] 제목이 100자 초과 시 말줄임 처리되는지 확인\n- [ ] 해시태그가 5개 이하로 제한되는지 확인\n- [ ] 카테고리별 해시태그가 올바르게 매핑되는지 확인\n- [ ] 링크가 올바르게 포함되는지 확인\n\n### 4. Cron Job 테스트\n- [ ] GitHub Actions 워크플로우가 정상 실행되는지 확인\n- [ ] 30분 간격으로 스케줄이 동작하는지 확인\n- [ ] 수동 실행(workflow_dispatch)이 가능한지 확인\n- [ ] 환경 변수가 올바르게 주입되는지 확인\n\n### 5. Zapier/IFTTT 연동 테스트 (옵션 A 선택 시)\n- [ ] Zapier에서 RSS Feed가 정상 인식되는지 확인\n- [ ] 새 기사 발행 시 Zap이 트리거되는지 확인\n- [ ] 트윗 템플릿이 올바르게 적용되는지 확인\n- [ ] 필터 조건이 정상 동작하는지 확인\n\n### 6. 중복 포스팅 방지 테스트\n- [ ] 동일 기사가 중복 포스팅되지 않는지 확인\n- [ ] lastPostedTime이 정상적으로 업데이트되는지 확인\n- [ ] 서버 재시작 후에도 상태가 유지되는지 확인 (Redis/파일 저장 시)\n\n### 7. 에러 핸들링 테스트\n- [ ] Twitter API 오류 시 적절한 에러 로깅이 되는지 확인\n- [ ] RSS Feed 접근 불가 시 graceful하게 처리되는지 확인\n- [ ] 네트워크 오류 시 재시도 로직이 동작하는지 확인\n\n### 8. 모니터링 테스트\n- [ ] 포스팅 성공/실패 로그가 기록되는지 확인\n- [ ] 일일 포스팅 통계를 확인할 수 있는지 확인\n- [ ] 알림 설정(Slack/Email)이 동작하는지 확인 (선택)",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "RSS Feed 검증 및 파싱 유틸리티 구현",
            "description": "Upday의 RSS Feed(/feed.xml) 엔드포인트를 검증하고, RSS 파서를 구현하여 기사 데이터를 추출하는 유틸리티를 개발한다.",
            "dependencies": [],
            "details": "1. /feed.xml 또는 /rss.xml 엔드포인트 접근성 확인\n2. RSS 2.0 또는 Atom 형식 준수 여부 검증\n3. rss-parser 라이브러리 설치 및 설정\n4. FeedItem 인터페이스 정의 (title, link, pubDate, contentSnippet, categories)\n5. fetchNewArticles() 함수 구현 - 마지막 포스팅 시간 이후의 새 기사만 필터링\n6. RSS Feed 필수 필드(title, link, pubDate) 포함 여부 확인 로직 추가",
            "status": "in-progress",
            "testStrategy": "1. /feed.xml 엔드포인트가 200 응답을 반환하는지 확인\n2. RSS 파서가 Feed를 정상적으로 파싱하는지 단위 테스트\n3. 필수 필드 누락 시 에러 처리 테스트\n4. 새 기사 필터링 로직이 정상 동작하는지 확인",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T02:09:53.958Z"
          },
          {
            "id": 2,
            "title": "Twitter API 클라이언트 설정 및 인증 구현",
            "description": "Twitter API v2를 사용하여 트윗을 게시할 수 있는 클라이언트를 설정하고, OAuth 인증을 구현한다.",
            "dependencies": [
              1
            ],
            "details": "1. twitter-api-v2 라이브러리 설치\n2. 환경 변수 설정 (TWITTER_API_KEY, TWITTER_API_SECRET, TWITTER_ACCESS_TOKEN, TWITTER_ACCESS_SECRET)\n3. TwitterApi 클라이언트 초기화 함수 구현\n4. 인증 검증 함수 구현 - API 키 유효성 확인\n5. Rate limit 처리 로직 추가 (5초 딜레이)\n6. 에러 핸들링 및 재시도 로직 구현",
            "status": "pending",
            "testStrategy": "1. Twitter API 인증이 정상적으로 되는지 확인\n2. 잘못된 API 키로 인증 시 적절한 에러 메시지 반환 테스트\n3. Rate limit 도달 시 재시도 로직 테스트",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "트윗 포맷팅 및 자동 포스팅 스크립트 구현",
            "description": "RSS Feed에서 가져온 기사를 트윗 형식으로 변환하고, 자동으로 Twitter에 포스팅하는 메인 스크립트를 구현한다.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. scripts/twitter-auto-post.ts 파일 생성\n2. formatTweet() 함수 구현 - 제목 100자 제한, URL 포함\n3. generateHashtags() 함수 구현 - 카테고리별 해시태그 매핑 (#AI뉴스, #테크뉴스, #Upday 등)\n4. postToTwitter() 함수 구현 - 트윗 게시 및 로깅\n5. runTwitterAutoPost() 메인 함수 구현 - 새 기사 확인 및 시간순 포스팅\n6. 마지막 포스팅 시간 저장 로직 (파일 또는 환경 변수 활용)",
            "status": "pending",
            "testStrategy": "1. 트윗 포맷이 280자 이내인지 확인\n2. 해시태그가 최대 5개로 제한되는지 테스트\n3. 테스트 트윗이 정상적으로 포스팅되는지 확인\n4. 여러 기사가 시간순으로 포스팅되는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "GitHub Actions Cron Job 설정 및 자동화 파이프라인 구축",
            "description": "GitHub Actions를 사용하여 30분마다 자동으로 Twitter 포스팅 스크립트를 실행하는 CI/CD 파이프라인을 구축한다.",
            "dependencies": [
              3
            ],
            "details": "1. .github/workflows/twitter-auto-post.yml 파일 생성\n2. Cron 스케줄 설정 (*/30 * * * * - 30분마다 실행)\n3. workflow_dispatch 트리거 추가 - 수동 실행 가능\n4. GitHub Secrets에 Twitter API 키 및 RSS_FEED_URL 등록\n5. Node.js 20 환경 설정 및 의존성 설치\n6. npm run twitter:post 스크립트 실행 단계 추가\n7. 실행 로그 및 에러 알림 설정",
            "status": "pending",
            "testStrategy": "1. workflow_dispatch로 수동 실행하여 정상 동작 확인\n2. Cron 스케줄이 30분마다 트리거되는지 확인\n3. Secrets가 올바르게 주입되는지 확인\n4. 실패 시 에러 로그가 기록되는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Zapier/IFTTT 연동 가이드 문서화 및 트러블슈팅 가이드 작성",
            "description": "Zapier/IFTTT를 사용한 대안적 연동 방법에 대한 가이드와 전체 시스템의 설정 및 트러블슈팅 문서를 작성한다.",
            "dependencies": [
              4
            ],
            "details": "1. docs/twitter-auto-posting.md 문서 생성\n2. Zapier 설정 가이드 작성 - RSS by Zapier 트리거, Twitter 액션 설정\n3. 트윗 메시지 템플릿 예시 제공 (📰 {{title}}, 🔗 {{link}}, 해시태그)\n4. IFTTT 대안 설정 가이드 작성\n5. 필터 설정 방법 (특정 카테고리/키워드만 포스팅)\n6. 환경 변수 설정 가이드 (.env.local 예시)\n7. 일반적인 에러 및 해결 방법 트러블슈팅 섹션 추가\n8. Twitter API Rate Limit 관련 주의사항 문서화",
            "status": "pending",
            "testStrategy": "1. 문서의 Zapier 설정 단계를 따라 실제 연동이 가능한지 확인\n2. 트러블슈팅 가이드가 일반적인 에러 케이스를 커버하는지 검토\n3. 환경 변수 설정 가이드가 명확한지 확인",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-04T02:09:53.958Z"
      },
      {
        "id": 61,
        "title": "[Design] Command Palette 검색 기능 개선 - 검색어 칩 + 추천 게시글",
        "description": "Command Palette에 이전 검색어를 칩 형태로 표시하고, 추천 게시글 섹션을 추가하여 검색 히스토리를 localStorage에 저장하고 최신 인기 기사를 추천 게시글로 표시한다.",
        "details": "## 구현 상세\n\n### 1. 파일 구조\n```\nsrc/components/ui/\n├── CommandPalette.tsx          # 기존 Command Palette 컴포넌트 수정\n├── SearchChip.tsx              # 검색어 칩 컴포넌트 (신규)\n└── RecommendedPosts.tsx        # 추천 게시글 섹션 (신규)\n\nsrc/hooks/\n└── useSearchHistory.ts         # 검색 히스토리 관리 커스텀 훅 (신규)\n\nsrc/lib/\n└── storage.ts                  # 기존 LocalStorage 유틸리티 확장\n```\n\n### 2. 검색 히스토리 훅 구현 (useSearchHistory)\n```typescript\n// src/hooks/useSearchHistory.ts\nexport const SEARCH_HISTORY_KEY = 'upday_search_history';\n\nexport const useSearchHistory = () => {\n  const [history, setHistory] = useState<string[]>([]);\n\n  const addSearchTerm = useCallback((term: string) => {\n    if (!term.trim()) return;\n    \n    setHistory(prev => {\n      const newHistory = [term, ...prev.filter(h => h !== term)]\n        .slice(0, 10); // 최대 10개 유지\n      localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(newHistory));\n      return newHistory;\n    });\n  }, []);\n\n  const removeSearchTerm = useCallback((term: string) => {\n    setHistory(prev => {\n      const newHistory = prev.filter(h => h !== term);\n      localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(newHistory));\n      return newHistory;\n    });\n  }, []);\n\n  const clearHistory = useCallback(() => {\n    setHistory([]);\n    localStorage.removeItem(SEARCH_HISTORY_KEY);\n  }, []);\n\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      const stored = localStorage.getItem(SEARCH_HISTORY_KEY);\n      if (stored) setHistory(JSON.parse(stored));\n    }\n  }, []);\n\n  return { history, addSearchTerm, removeSearchTerm, clearHistory };\n};\n```\n\n### 3. 검색어 칩 컴포넌트\n```tsx\n// src/components/ui/SearchChip.tsx\nconst SearchChip = ({ term, onRemove, onClick }: { term: string, onRemove: () => void, onClick: () => void }) => (\n  <div className=\"inline-flex items-center gap-1 px-3 py-1.5 bg-muted rounded-full text-sm cursor-pointer hover:bg-muted/80 transition-colors\"\n       onClick={onClick}>\n    {term}\n    <button onClick={(e) => { e.stopPropagation(); onRemove(); }}\n            className=\"ml-1 text-muted-foreground hover:text-foreground rounded-full w-4 h-4 flex items-center justify-center hover:bg-muted\">\n      ×\n    </button>\n  </div>\n);\n```\n\n### 4. 추천 게시글 섹션 (더미 데이터 사용, 실제 API 연동은 후속 태스크)\n```tsx\n// src/components/ui/RecommendedPosts.tsx\nconst RecommendedPosts = ({ onSelect }: { onSelect: (post: any) => void }) => {\n  const recentPosts = [\n    { id: 1, title: '최신 AI 트렌드 분석', category: 'ai', date: '2시간 전' },\n    { id: 2, title: '스타트업 투자 동향', category: 'startups', date: '5시간 전' },\n    // ... 더미 데이터\n  ];\n\n  return (\n    <CommandPalette.List heading=\"추천 게시글\">\n      {recentPosts.map(post => (\n        <CommandPalette.ListItem\n          key={post.id}\n          children={post.title}\n          subtitle={`${post.category} • ${post.date}`}\n          onSelect={() => onSelect(post)}\n        />\n      ))}\n    </CommandPalette.List>\n  );\n};\n```\n\n### 5. CommandPalette 수정\n```tsx\n// CommandPalette 내부 구조\nconst CommandPaletteContent = () => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const { history, addSearchTerm, removeSearchTerm, clearHistory } = useSearchHistory();\n\n  const filteredHistory = history.filter(h => \n    h.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  return (\n    <div className=\"max-h-[500px] overflow-y-auto\">\n      {/* 검색 히스토리 칩들 */}\n      {searchTerm === '' && history.length > 0 && (\n        <div className=\"p-4 border-b\">\n          <div className=\"flex flex-wrap gap-2 mb-2\">\n            {filteredHistory.slice(0, 5).map(term => (\n              <SearchChip \n                key={term}\n                term={term}\n                onRemove={() => removeSearchTerm(term)}\n                onClick={() => setSearchTerm(term)}\n              />\n            ))}\n          </div>\n          <button onClick={clearHistory} className=\"text-xs text-muted-foreground hover:text-foreground\">\n            검색 기록 지우기\n          </button>\n        </div>\n      )}\n\n      {/* 검색 결과 */}\n      <RecommendedPosts onSelect={(post) => {\n        // 게시글 이동 로직\n        router.push(`/timeline?search=${encodeURIComponent(post.title)}`);\n      }} />\n    </div>\n  );\n};\n```\n\n### 6. 키보드 단축키 개선 (Cmd/Ctrl + K)\n```typescript\nuseEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n      e.preventDefault();\n      setIsOpen(true);\n    }\n  };\n  window.addEventListener('keydown', handleKeyDown);\n  return () => window.removeEventListener('keydown', handleKeyDown);\n}, []);\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 검색 히스토리 기능 테스트\n- [ ] Command Palette 열기 (Cmd/Ctrl + K)\n- [ ] 검색어 입력 후 Enter → localStorage에 저장되는지 확인\n- [ ] 페이지 새로고침 후 이전 검색어가 칩 형태로 표시되는지 확인\n- [ ] 칩 클릭 시 검색 입력창에 자동 입력되는지 확인\n- [ ] 칩의 × 버튼 클릭 시 해당 검색어만 삭제되는지 확인\n- [ ] '검색 기록 지우기' 버튼으로 전체 히스토리 삭제 확인\n- [ ] 최대 10개까지만 저장되는지 확인 (11번째 입력 시 첫 번째 삭제)\n\n### 2. 추천 게시글 섹션 테스트\n- [ ] 검색어 입력 전/후 '추천 게시글' 섹션이 표시되는지 확인\n- [ ] 추천 게시글 항목들이 올바른 형식(제목, 카테고리, 시간)으로 표시되는지 확인\n- [ ] 추천 게시글 클릭 시 올바른 URL로 이동하는지 확인\n\n### 3. 반응형 및 접근성 테스트\n- [ ] Mobile/Tablet/Desktop에서 칩들이 적절히 wrap되는지 확인\n- [ ] 키보드만으로 칩 탐색 및 삭제 가능 (Tab, Enter, Backspace)\n- [ ] Screen Reader가 칩과 추천 게시글을 올바르게 읽는지 확인\n- [ ] Dark/Light 모드에서 칩 색상과 배경이 올바르게 적용되는지 확인\n\n### 4. LocalStorage 테스트\n- [ ] 개발자 도구 → Application → LocalStorage에서 `upday_search_history` 키 확인\n- [ ] 비정상 데이터(빈 배열, null) 처리 시 앱 크래시 없는지 확인\n- [ ] SSR 환경에서 hydration mismatch 발생하지 않는지 확인\n\n### 5. 성능 테스트\n- [ ] 10개 검색어 칩 표시 시 스크롤 성능 저하 없는지 확인\n- [ ] 검색어 필터링이 실시간으로 반응하는지 확인 (debounce 150ms 권장)",
        "status": "done",
        "dependencies": [
          "54",
          "58"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useSearchHistory custom hook",
            "description": "Create search history management hook that stores up to 10 recent search terms in localStorage with add, remove, and clear functionality.",
            "dependencies": [],
            "details": "Implement useSearchHistory.ts in src/hooks/ with SEARCH_HISTORY_KEY constant, useState for history, addSearchTerm (dedupe and limit to 10), removeSearchTerm, clearHistory functions, and useEffect for initial load from localStorage. Ensure SSR safety with window check.",
            "status": "pending",
            "testStrategy": "Unit test: initial load from localStorage, addSearchTerm (dedupe/limit), removeSearchTerm, clearHistory. Integration test: verify localStorage persistence across page refresh.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create SearchChip component",
            "description": "Build reusable SearchChip component displaying search terms as clickable chips with remove button (×) and hover effects.",
            "dependencies": [],
            "details": "Implement SearchChip.tsx in src/components/ui/ with props (term, onRemove, onClick), Tailwind classes for inline-flex chip styling (bg-muted, rounded-full), stopPropagation on remove button, and smooth hover transitions.",
            "status": "pending",
            "testStrategy": "Visual test: chip renders correctly, clickable area works, × button removes without triggering onClick. Accessibility test: proper keyboard navigation and focus management.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop RecommendedPosts component",
            "description": "Create RecommendedPosts section displaying dummy popular posts with title, category, date subtitle using CommandPalette.List structure.",
            "dependencies": [],
            "details": "Implement RecommendedPosts.tsx in src/components/ui/ with dummy recentPosts array (id, title, category, date), CommandPalette.List with heading '추천 게시글', and ListItem with onSelect callback passing post data.",
            "status": "pending",
            "testStrategy": "Visual test: posts render in CommandPalette list format, subtitle shows category•date, onSelect triggers correctly with post object. Responsive test: proper display in palette constraints.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update CommandPalette with search history chips",
            "description": "Modify existing CommandPalette to integrate search history chips, filtering, clear button, and conditional rendering when searchTerm is empty.",
            "dependencies": [
              1,
              2
            ],
            "details": "In CommandPaletteContent: add useSearchHistory hook, filter history by searchTerm, render chips section (p-4 border-b) with max 5 chips when searchTerm==='', include '검색 기록 지우기' button, integrate SearchChip with onClick setting searchTerm.",
            "status": "pending",
            "testStrategy": "Integration test: chips appear on empty input, filter by typing, chip click populates input, remove/clear buttons work. Edge case: max 5 chips display, empty history state.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add keyboard shortcut and integrate RecommendedPosts",
            "description": "Implement Cmd/Ctrl+K global shortcut to open palette and integrate RecommendedPosts section with router navigation on post selection.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add useEffect with window keydown listener for metaKey/ctrlKey + 'k' to setIsOpen(true). In CommandPaletteContent, add RecommendedPosts with onSelect using router.push(`/timeline?search=${encodeURIComponent(post.title)}`). Ensure max-h-[500px] overflow-y-auto container.",
            "status": "pending",
            "testStrategy": "E2E test: Cmd/Ctrl+K opens palette globally, post selection navigates to /timeline?search=..., Esc closes palette. Memory leak test: proper event listener cleanup.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-04T03:26:16.312Z"
      },
      {
        "id": 62,
        "title": "[Design] Landing Page 리디자인 - Hero 아래 섹션들 현대적 SaaS 스타일로 업데이트",
        "description": "Hero 섹션은 유지하고 Features, Live Preview, How It Works, Trusted Sources, Final CTA 섹션들을 Monet/Resend/Suno/Lemni 스타일의 현대적 SaaS 랜딩 페이지로 리디자인하며, 기존 Monet 디자인 시스템 컴포넌트를 활용한다.",
        "details": "## 구현 상세\n\n### 1. 디자인 레퍼런스 및 가이드라인 (2026 SaaS 트렌드 적용)[1][2]\n- **Monet/Resend/Suno/Lemni 스타일**: Product-led storytelling, conversion-focused minimalism, bold typography, micro-interactions\n- **키 특징**: Clean layouts, 1 primary CTA per section, social proof near CTAs, mobile-first, dark mode support\n- **색상/타이포**: 기존 Monet 디자인 시스템 (primary/secondary colors, heading/font weights)\n\n### 2. 파일 구조\n```\nsrc/components/landing/\n├── LandingPage.tsx                 # 메인 랜딩 페이지 (섹션 재배치)\n├── FeaturesSection.tsx             # 리디자인된 Features 섹션\n├── LivePreviewSection.tsx          # Live Timeline Preview (제품 스크린샷 중심)\n├── HowItWorksSection.tsx           # 3-4단계 워크플로우 + 아이콘\n├── TrustedSourcesSection.tsx       # 뉴스 소스 로고 그리드 + 통계\n├── FinalCTASection.tsx             # 최종 변환 CTA (Pricing/Waitlist)\n└── SocialProofSection.tsx          # Task 59 재사용\n\nsrc/components/ui/landing/          # 재사용 컴포넌트\n├── FeatureCard.tsx                 # 기능 카드\n├── StepCard.tsx                    # How It Works 스텝\n├── LogoGrid.tsx                    # Trusted Sources 로고\n└── GradientBackground.tsx          # 섹션 배경 그라디언트\n```\n\n### 3. 섹션별 리디자인 스펙\n\n**FeaturesSection.tsx** (Product-led, 3-4개 핵심 기능)\n```tsx\nimport { FeatureCard } from './ui/landing/FeatureCard';\n\nconst FEATURES = [\n  {\n    icon: Search,\n    title: \"실시간 AI 뉴스 큐레이션\",\n    description: \"수천 개 뉴스 소스를 실시간 분석하여 가장 중요한 기사만 선별\",\n    cta: \"기능 살펴보기\"\n  }\n];\n\nexport function FeaturesSection() {\n  return (\n    <section className=\"py-24 bg-gradient-to-br from-background/50 to-muted/50\">\n      <div className=\"max-w-6xl mx-auto px-6\">\n        <div className=\"text-center mb-20\">\n          <h2 className=\"text-4xl md:text-5xl font-bold bg-gradient-text bg-clip-text text-transparent\">왜 Upday인가?</h2>\n          <p className=\"mt-6 text-xl text-muted-foreground max-w-2xl mx-auto\">복잡한 뉴스 환경에서 핵심만 빠르게 파악하세요</p>\n        </div>\n        <div className=\"grid md:grid-cols-2 lg:grid-cols-3 gap-8\">\n          {FEATURES.map((feature) => (\n            <FeatureCard key={feature.title} {...feature} />\n          ))}\n        </div>\n      </div>\n    </section>\n  );\n}\n```\n\n**LivePreviewSection.tsx** (실제 제품 데모 GIF/스크린샷)\n- Hero-style product screenshot + overlay annotations\n- Interactive hover effects (Framer Motion)\n- \"실시간으로 작동 중\" 배지\n\n**HowItWorksSection.tsx** (3-4단계 numbered steps)\n```tsx\nconst STEPS = [\n  { number: 1, title: \"관심 주제 설정\", icon: Settings },\n  { number: 2, title: \"AI가 뉴스 분석\", icon: Brain },\n  { number: 3, title: \"핵심만 타임라인\", icon: Timeline },\n  { number: 4, title: \"즐겨찾기 저장\", icon: Bookmark }\n];\n```\n\n**TrustedSourcesSection.tsx** + SocialProof 통합\n- 뉴스 소스 로고 그리드 (Reuters, NYT, WSJ 등)\n- Task 59 SocialProofSection 재배치\n\n**FinalCTASection.tsx**\n- Full-width gradient background\n- Single prominent CTA (\"지금 시작하기 - 무료\")\n- Trust badges + \"No credit card required\"\n\n### 4. 반응형 & 애니메이션\n```tsx\n// Framer Motion 사용 (기존 패턴)\nimport { motion } from 'framer-motion';\n\n<motion.div\n  initial={{ opacity: 0, y: 30 }}\n  whileInView={{ opacity: 1, y: 0 }}\n  transition={{ duration: 0.6 }}\n  viewport={{ once: true }}\n>\n```\n\n### 5. 성능 최적화\n- Next.js Image 컴포넌트로 모든 이미지 최적화\n- Lazy loading for below-the-fold sections\n- LCP 최적화: Hero 다음 Features 섹션 우선 로드",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적/레이아웃 테스트\n- [ ] `/` 랜딩 페이지 로드 시 Hero 섹션 유지, 새 섹션들이 순서대로 표시 (Hero → Features → SocialProof → LivePreview → HowItWorks → TrustedSources → FinalCTA)\n- [ ] 각 섹션의 **bold typography**와 **gradient backgrounds**가 Monet 디자인 시스템과 일치\n- [ ] **Desktop(1440px)**: 3컬럼 Features 그리드, full-width 섹션들\n- [ ] **Tablet(768px)**: 2컬럼 Features, 접히는 카드들\n- [ ] **Mobile(375px)**: Single column, thumb-friendly CTAs (min-height 48px)\n- [ ] **Dark/Light mode** 전환 시 모든 섹션 스타일 정상 적용\n\n### 2. 인터랙션 테스트\n- [ ] FeaturesSection 호버 시 **micro-interactions** (scale, glow effect) 동작\n- [ ] LivePreviewSection에서 제품 GIF/스크린샷이 **autoplay loop**하며 로드\n- [ ] HowItWorks 스텝 카드 클릭 시 **상세 모달** 또는 **스크롤 애니메이션** 동작\n- [ ] FinalCTA 섹션의 **Primary CTA** 클릭 시 `/timeline` 또는 `/signup`로 정상 이동\n\n### 3. 콘텐츠/복사 테스트\n- [ ] 각 섹션 **headline이 pain point 중심** (예: \"복잡한 뉴스, 30초만에 파악\")\n- [ ] **Social proof 숫자**가 Task 59와 일치하고 실시간 업데이트\n- [ ] **Trusted Sources**에 실제 뉴스 로고 12+개 표시\n\n### 4. 성능 및 접근성\n- [ ] **Lighthouse Performance** 90+ (특히 LCP < 2s)\n- [ ] **Mobile-first**: Core Web Vitals 모든 메트릭 PASS\n- [ ] **Keyboard navigation**: Tab으로 모든 CTA 접근 가능\n- [ ] **Screen reader**: 각 섹션에 적절한 aria-label, heading hierarchy\n\n### 5. 크로스 브라우저\n- [ ] Chrome, Firefox, Safari, Edge에서 동일 렌더링\n- [ ] iOS Safari에서 touch interactions 정상 동작\n\n### 6. A/B 테스트 준비\n- [ ] 각 섹션에 `data-variant` 속성 추가 (headline, CTA text A/B 테스트용)",
        "status": "pending",
        "dependencies": [
          19,
          59
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create UI Components for Landing Page",
            "description": "Implement reusable UI components FeatureCard, StepCard, LogoGrid, and GradientBackground using Monet design system in src/components/ui/landing/",
            "dependencies": [],
            "details": "Use Tailwind CSS classes matching Monet primary/secondary colors, bold typography, and gradient backgrounds. Ensure mobile-first responsive design and dark mode support per 2026 SaaS trends[1][2].",
            "status": "pending",
            "testStrategy": "Verify components render correctly in Storybook, check responsive breakpoints (mobile: 1col, desktop: 3col), confirm dark mode color consistency with Monet system."
          },
          {
            "id": 2,
            "title": "Implement FeaturesSection with Product-led Design",
            "description": "Build FeaturesSection.tsx with 3-4 core features using FeatureCard components, gradient background, bold gradient-text headline, and single primary CTA.",
            "dependencies": [
              1
            ],
            "details": "Follow provided code spec with real-time AI curation features. Apply Framer Motion for scroll-triggered animations (opacity/y transitions). Ensure clean 2-3 column grid layout[1].",
            "status": "pending",
            "testStrategy": "Confirm 3-column grid on desktop, gradient text renders correctly, features match Upday value prop, animations trigger on scroll without layout shift."
          },
          {
            "id": 3,
            "title": "Develop LivePreviewSection and HowItWorksSection",
            "description": "Create LivePreviewSection.tsx with interactive product screenshots/GIFs and HowItWorksSection.tsx with 4-step numbered workflow using StepCard components.",
            "dependencies": [
              1
            ],
            "details": "Add hover micro-interactions (Framer Motion), '실시간으로 작동 중' badge for preview, numbered steps with icons (Settings, Brain, Timeline, Bookmark). Use Next.js Image optimization[2].",
            "status": "pending",
            "testStrategy": "Test interactive hover effects, verify step icons/numbers display correctly, confirm lazy loading for below-fold content, check LCP performance."
          },
          {
            "id": 4,
            "title": "Build TrustedSourcesSection and FinalCTASection",
            "description": "Implement TrustedSourcesSection.tsx integrating Task 59 SocialProof with news logo grid (Reuters/NYT/WSJ) and FinalCTASection.tsx with full-width gradient and prominent CTA.",
            "dependencies": [
              1,
              59
            ],
            "details": "Use LogoGrid for responsive logo display with stats, single '지금 시작하기 - 무료' CTA with trust badges. Apply conversion-focused minimalism with social proof near CTA[1][2].",
            "status": "pending",
            "testStrategy": "Validate logo grid responsiveness, confirm SocialProof integration from Task 59, test CTA button states and full-width gradient on all screen sizes."
          },
          {
            "id": 5,
            "title": "Integrate Sections into LandingPage.tsx and Optimize",
            "description": "Update LandingPage.tsx to compose all sections in order (Hero→Features→LivePreview→HowItWorks→TrustedSources→FinalCTA) with performance optimizations.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Maintain existing Hero section, add lazy loading for sections, use Next.js Image everywhere, implement viewport-based Framer Motion animations, ensure mobile-first layout[1].",
            "status": "pending",
            "testStrategy": "Full page load test: verify section sequence, Hero unchanged, LCP under 2.5s, all animations smooth, responsive on mobile/tablet/desktop, no hydration errors."
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-04T03:26:16.313Z",
      "taskCount": 51,
      "completedCount": 42,
      "tags": [
        "master"
      ],
      "created": "2026-02-04T07:28:00.956Z",
      "description": "Tasks for master context",
      "updated": "2026-02-04T07:28:19.157Z"
    }
  },
  "design": {
    "tasks": [
      {
        "id": 1,
        "title": "디자인 변경 롤백 체계 수립",
        "description": "Git 브랜치 전략을 활용하여 디자인 변경사항을 체계적으로 관리하고, 문제 발생 시 쉽게 롤백할 수 있는 구조를 구축합니다.",
        "details": "## 구현 단계\n\n### 1. 브랜치 전략 수립\n- `feature/design-refresh` 메인 피처 브랜치 생성\n- 각 섹션별 서브 브랜치 구조 정의:\n  - `feature/design-refresh/header`\n  - `feature/design-refresh/navigation`\n  - `feature/design-refresh/content`\n  - `feature/design-refresh/footer`\n\n### 2. 커밋 컨벤션 정의\n- 섹션별 커밋 분리를 위한 명명 규칙:\n  ```\n  [design][섹션명] 변경 내용 요약\n  예: [design][header] 로고 크기 및 위치 조정\n  ```\n- 각 커밋은 단일 섹션의 변경사항만 포함\n- 커밋 메시지에 변경 이유와 영향 범위 명시\n\n### 3. 롤백 프로세스 문서화\n- `git revert` 사용 가이드라인 작성\n- 섹션별 롤백 시나리오 정의\n- 긴급 롤백 절차 수립:\n  ```bash\n  # 특정 섹션 롤백\n  git revert <commit-hash>\n  \n  # 전체 디자인 변경 롤백\n  git revert --no-commit <start-hash>..<end-hash>\n  git commit -m \"[rollback] 디자인 변경 전체 롤백\"\n  ```\n\n### 4. 브랜치 보호 규칙 설정\n- `feature/design-refresh` 브랜치에 대한 PR 필수화\n- 코드 리뷰 최소 1명 승인 요구\n- CI/CD 파이프라인 통과 필수\n\n### 5. 태그 전략\n- 주요 마일스톤에 태그 생성:\n  ```bash\n  git tag -a design-v1.0-header -m \"헤더 디자인 완료\"\n  git tag -a design-v1.0-complete -m \"전체 디자인 리프레시 완료\"\n  ```",
        "testStrategy": "## 테스트 전략\n\n### 1. 브랜치 구조 검증\n- `feature/design-refresh` 브랜치가 정상적으로 생성되었는지 확인\n- 서브 브랜치들이 메인 피처 브랜치에서 분기되었는지 확인\n- `git branch -a` 명령으로 브랜치 목록 검증\n\n### 2. 커밋 분리 검증\n- 각 커밋이 단일 섹션의 변경사항만 포함하는지 검토\n- `git log --oneline` 으로 커밋 히스토리 확인\n- 커밋 메시지가 컨벤션을 따르는지 검증\n\n### 3. 롤백 시뮬레이션\n- 테스트 환경에서 특정 섹션 롤백 수행\n- 롤백 후 다른 섹션에 영향이 없는지 확인\n- 롤백된 상태에서 애플리케이션이 정상 동작하는지 검증\n\n### 4. 브랜치 보호 규칙 테스트\n- 직접 push가 차단되는지 확인\n- PR 없이 머지가 불가능한지 확인\n\n### 5. 문서화 검증\n- 롤백 가이드라인 문서가 팀원들에게 공유되었는지 확인\n- 가이드라인에 따라 실제 롤백이 가능한지 테스트",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-02-03T13:22:32.100Z"
      },
      {
        "id": 2,
        "title": "UI 컴포넌트 디자인 개선 (Button, Card, FeatureCard)",
        "description": "Button 컴포넌트에 호버/액티브 효과 추가, Card 컴포넌트에 glass morphism 옵션 구현, 새로운 FeatureCard 컴포넌트 생성. 모든 구현은 shadcn/ui 패턴을 준수합니다.",
        "details": "## 구현 단계\n\n### 1. Button 컴포넌트 호버/액티브 효과 개선\n```tsx\n// components/ui/button.tsx\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium transition-all duration-200 ease-in-out focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90 hover:scale-[1.02] hover:shadow-md active:scale-[0.98] active:shadow-sm\",\n        destructive: \"bg-destructive text-destructive-foreground hover:bg-destructive/90 hover:scale-[1.02] active:scale-[0.98]\",\n        outline: \"border border-input bg-background hover:bg-accent hover:text-accent-foreground hover:border-primary/50 active:bg-accent/80\",\n        secondary: \"bg-secondary text-secondary-foreground hover:bg-secondary/80 hover:shadow-sm active:bg-secondary/70\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground active:bg-accent/80\",\n        link: \"text-primary underline-offset-4 hover:underline active:text-primary/80\",\n      },\n      // ... size variants\n    },\n  }\n)\n```\n\n### 2. Card 컴포넌트 Glass Morphism 옵션 추가\n```tsx\n// components/ui/card.tsx\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nconst cardVariants = cva(\n  \"rounded-lg border text-card-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-card shadow-sm\",\n        glass: \"bg-white/10 backdrop-blur-md border-white/20 shadow-xl\",\n        glassDark: \"bg-black/10 backdrop-blur-md border-black/20 shadow-xl\",\n        glassColored: \"bg-gradient-to-br from-white/20 to-white/5 backdrop-blur-lg border-white/30 shadow-2xl\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\ninterface CardProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof cardVariants> {}\n\nconst Card = React.forwardRef<HTMLDivElement, CardProps>(\n  ({ className, variant, ...props }, ref) => (\n    <div\n      ref={ref}\n      className={cn(cardVariants({ variant, className }))}\n      {...props}\n    />\n  )\n)\n```\n\n### 3. FeatureCard 신규 컴포넌트 생성\n```tsx\n// components/ui/feature-card.tsx\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"@/lib/utils\"\n\nconst featureCardVariants = cva(\n  \"group relative overflow-hidden rounded-xl p-6 transition-all duration-300\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-card border shadow-sm hover:shadow-lg hover:-translate-y-1\",\n        gradient: \"bg-gradient-to-br from-primary/10 to-secondary/10 border border-primary/20 hover:from-primary/20 hover:to-secondary/20\",\n        glass: \"bg-white/10 backdrop-blur-md border border-white/20 hover:bg-white/20\",\n        outlined: \"border-2 border-dashed border-muted-foreground/30 hover:border-primary/50 hover:bg-accent/50\",\n      },\n      size: {\n        sm: \"p-4\",\n        default: \"p-6\",\n        lg: \"p-8\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\ninterface FeatureCardProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof featureCardVariants> {\n  icon?: React.ReactNode\n  title: string\n  description: string\n}\n\nconst FeatureCard = React.forwardRef<HTMLDivElement, FeatureCardProps>(\n  ({ className, variant, size, icon, title, description, children, ...props }, ref) => (\n    <div\n      ref={ref}\n      className={cn(featureCardVariants({ variant, size, className }))}\n      {...props}\n    >\n      {icon && (\n        <div className=\"mb-4 inline-flex h-12 w-12 items-center justify-center rounded-lg bg-primary/10 text-primary transition-transform group-hover:scale-110\">\n          {icon}\n        </div>\n      )}\n      <h3 className=\"mb-2 text-lg font-semibold tracking-tight\">{title}</h3>\n      <p className=\"text-sm text-muted-foreground\">{description}</p>\n      {children}\n    </div>\n  )\n)\nFeatureCard.displayName = \"FeatureCard\"\n\nexport { FeatureCard, featureCardVariants }\n```\n\n### 4. 컴포넌트 인덱스 업데이트\n```tsx\n// components/ui/index.ts\nexport * from \"./button\"\nexport * from \"./card\"\nexport * from \"./feature-card\"\n```\n\n### 5. Tailwind 설정 확인\n```js\n// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      backdropBlur: {\n        xs: '2px',\n      },\n      // glass morphism을 위한 추가 설정\n    },\n  },\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. Button 컴포넌트 테스트\n- 모든 variant에서 호버 효과가 정상 작동하는지 시각적 확인\n- 액티브(클릭) 상태에서 scale 효과가 적용되는지 확인\n- 트랜지션이 부드럽게 동작하는지 확인 (200ms duration)\n- disabled 상태에서 호버/액티브 효과가 비활성화되는지 확인\n- 키보드 포커스 시 ring 효과가 정상 표시되는지 확인\n\n### 2. Card Glass Morphism 테스트\n- 각 variant (default, glass, glassDark, glassColored)가 올바르게 렌더링되는지 확인\n- backdrop-blur 효과가 배경 이미지/색상 위에서 정상 작동하는지 확인\n- 다양한 브라우저에서 glass morphism 호환성 테스트 (Chrome, Firefox, Safari, Edge)\n- 기존 Card 사용처에서 breaking change가 없는지 확인\n\n### 3. FeatureCard 컴포넌트 테스트\n- 모든 variant와 size 조합이 정상 렌더링되는지 확인\n- icon prop이 있을 때와 없을 때 레이아웃이 올바른지 확인\n- 호버 시 애니메이션 효과 (translate-y, scale) 동작 확인\n- children prop을 통한 추가 콘텐츠 렌더링 테스트\n- TypeScript 타입 정의가 올바른지 확인\n\n### 4. 통합 테스트\n- Storybook에서 모든 컴포넌트 스토리 작성 및 시각적 검증\n- 다크 모드에서 모든 컴포넌트가 올바르게 표시되는지 확인\n- 반응형 레이아웃에서 컴포넌트 동작 확인\n- 접근성 테스트: 스크린 리더 호환성, 색상 대비 확인\n\n### 5. 성능 테스트\n- backdrop-blur 사용 시 렌더링 성능 영향 측정\n- 애니메이션이 60fps로 부드럽게 동작하는지 확인",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Button 컴포넌트 호버/액티브 효과 구현",
            "description": "components/ui/button.tsx에 제공된 buttonVariants 코드 적용하고 모든 variant에서 호버(scale-[1.02], shadow-md), 액티브(scale-[0.98]) 효과 추가",
            "dependencies": [],
            "details": "cva variants에 default, destructive, outline, secondary, ghost, link 모든 variant에 hover:scale-[1.02] hover:shadow-md active:scale-[0.98] active:shadow-sm 등 효과 추가. transition-all duration-200 유지. shadcn/ui 패턴 준수.",
            "status": "pending",
            "testStrategy": "모든 variant 호버/액티브 시각적 확인, disabled 상태 효과 비활성화 확인, 키보드 focus ring 테스트, 200ms 트랜지션 부드러움 확인"
          },
          {
            "id": 2,
            "title": "Card 컴포넌트 Glass Morphism variant 추가",
            "description": "components/ui/card.tsx에 glass, glassDark, glassColored variant 구현하고 CardProps에 variant prop 추가",
            "dependencies": [],
            "details": "제공된 cardVariants 코드 적용 (default, glass: bg-white/10 backdrop-blur-md, glassDark, glassColored). React.forwardRef와 cn() 유틸리티 사용. Tailwind backdrop-blur-md 지원 확인.",
            "status": "pending",
            "testStrategy": "각 variant 시각적 비교 (default vs glass 효과), 라이트/다크 모드 호환성, backdrop-blur 렌더링 확인, border opacity 테스트"
          },
          {
            "id": 3,
            "title": "FeatureCard 컴포넌트 신규 생성",
            "description": "components/ui/feature-card.tsx 파일 생성하고 icon, title, description props 지원하는 FeatureCard 구현",
            "dependencies": [],
            "details": "제공된 featureCardVariants와 FeatureCard 컴포넌트 전체 코드 구현. variant(default, gradient, glass, outlined), size(sm, default, lg) 지원. icon hover scale-110 애니메이션 포함.",
            "status": "pending",
            "testStrategy": "icon 표시/숨김 테스트, 모든 variant/size 조합 확인, group-hover 효과 작동 확인, title/description 스타일링 검증"
          },
          {
            "id": 4,
            "title": "컴포넌트 index.ts 파일 업데이트",
            "description": "components/ui/index.ts에 FeatureCard export 추가하고 Button, Card export 확인",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "export * from './button', export * from './card', export * from './feature-card' 추가. 기존 export 유지하고 중복 제거.",
            "status": "pending",
            "testStrategy": "모든 컴포넌트 import 가능성 확인, TypeScript 에러 없음 검증, barrel export 정상 작동 테스트"
          },
          {
            "id": 5,
            "title": "Tailwind 설정 및 glass morphism 지원 확인",
            "description": "tailwind.config.js에 backdropBlur 확장 추가하고 glassmorphism 클래스 빌드 확인",
            "dependencies": [
              2
            ],
            "details": "theme.extend.backdropBlur.xs: '2px' 추가. bg-white/10, border-white/20 등 opacity 클래스 컴파일 확인. Next.js 빌드 후 스타일 적용 테스트.",
            "status": "pending",
            "testStrategy": "tailwind.config 변경 후 dev 서버 재시작, glass variant 클래스 실제 CSS 생성 확인, 브라우저 DevTools로 backdrop-blur-md 적용 검증"
          }
        ],
        "updatedAt": "2026-02-03T13:23:00.808Z"
      },
      {
        "id": 3,
        "title": "LandingPage Hero 섹션 시각적 개선 - 그라디언트 배경 및 애니메이션 효과",
        "description": "LandingPage의 Hero 섹션에 SaaS 스타일의 미니멀한 그라디언트 배경과 부드러운 애니메이션 효과를 추가합니다. 기존 문구(\"Know what's changing. Without reading everything.\")는 그대로 유지합니다.",
        "details": "## 구현 단계\n\n### 1. 그라디언트 배경 구현\n```tsx\n// components/landing/HeroSection.tsx\nconst HeroSection = () => {\n  return (\n    <section className=\"relative min-h-[80vh] overflow-hidden\">\n      {/* 그라디언트 배경 레이어 */}\n      <div className=\"absolute inset-0 bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-100/50 dark:from-slate-950 dark:via-blue-950/30 dark:to-indigo-950/50\" />\n      \n      {/* 애니메이션 블롭/오브 효과 */}\n      <div className=\"absolute top-1/4 -left-20 w-72 h-72 bg-blue-400/20 rounded-full blur-3xl animate-blob\" />\n      <div className=\"absolute top-1/3 -right-20 w-96 h-96 bg-indigo-400/20 rounded-full blur-3xl animate-blob animation-delay-2000\" />\n      <div className=\"absolute bottom-1/4 left-1/3 w-80 h-80 bg-purple-400/15 rounded-full blur-3xl animate-blob animation-delay-4000\" />\n      \n      {/* 콘텐츠 영역 */}\n      <div className=\"relative z-10 container mx-auto px-4 py-20\">\n        {/* 기존 문구 유지 */}\n        <h1 className=\"text-4xl md:text-6xl font-bold text-center\">\n          Know what's changing.\n        </h1>\n        <p className=\"text-xl md:text-2xl text-muted-foreground text-center mt-4\">\n          Without reading everything.\n        </p>\n      </div>\n    </section>\n  );\n};\n```\n\n### 2. Tailwind 애니메이션 설정 추가\n```js\n// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      animation: {\n        'blob': 'blob 7s infinite',\n        'fade-in': 'fadeIn 0.8s ease-out forwards',\n        'slide-up': 'slideUp 0.6s ease-out forwards',\n        'float': 'float 6s ease-in-out infinite',\n      },\n      keyframes: {\n        blob: {\n          '0%': { transform: 'translate(0px, 0px) scale(1)' },\n          '33%': { transform: 'translate(30px, -50px) scale(1.1)' },\n          '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },\n          '100%': { transform: 'translate(0px, 0px) scale(1)' },\n        },\n        fadeIn: {\n          '0%': { opacity: '0' },\n          '100%': { opacity: '1' },\n        },\n        slideUp: {\n          '0%': { opacity: '0', transform: 'translateY(20px)' },\n          '100%': { opacity: '1', transform: 'translateY(0)' },\n        },\n        float: {\n          '0%, 100%': { transform: 'translateY(0)' },\n          '50%': { transform: 'translateY(-10px)' },\n        },\n      },\n    },\n  },\n};\n```\n\n### 3. 애니메이션 딜레이 유틸리티 클래스\n```css\n/* globals.css 또는 별도 CSS 파일 */\n.animation-delay-2000 {\n  animation-delay: 2s;\n}\n.animation-delay-4000 {\n  animation-delay: 4s;\n}\n```\n\n### 4. 텍스트 애니메이션 효과 (선택적)\n```tsx\n// 텍스트에 순차적 fade-in 효과 적용\n<h1 className=\"animate-fade-in opacity-0\" style={{ animationDelay: '0.2s' }}>\n  Know what's changing.\n</h1>\n<p className=\"animate-slide-up opacity-0\" style={{ animationDelay: '0.4s' }}>\n  Without reading everything.\n</p>\n```\n\n### 5. 성능 최적화 고려사항\n- `will-change: transform` 속성 사용으로 GPU 가속 활용\n- `prefers-reduced-motion` 미디어 쿼리로 접근성 지원\n- 블롭 애니메이션은 CSS만으로 구현하여 JS 부하 최소화\n\n### 6. 다크모드 대응\n- 그라디언트 색상을 dark: 프리픽스로 분리 정의\n- 블롭 불투명도를 다크모드에서 조정",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 검증\n- 그라디언트 배경이 Hero 섹션 전체에 올바르게 적용되는지 확인\n- 블롭 애니메이션이 부드럽게 동작하는지 확인 (7초 주기)\n- 애니메이션 딜레이가 각 블롭에 올바르게 적용되어 자연스러운 움직임 생성 확인\n- 텍스트가 배경 위에서 명확하게 가독성 있게 표시되는지 확인\n\n### 2. 기존 문구 유지 확인\n- \"Know what's changing.\" 헤드라인이 그대로 유지되는지 확인\n- \"Without reading everything.\" 서브텍스트가 그대로 유지되는지 확인\n- 폰트 크기, 색상, 정렬이 기존과 동일한지 확인\n\n### 3. 반응형 테스트\n- 모바일 (320px ~ 768px): 그라디언트와 블롭이 화면에 맞게 조정되는지 확인\n- 태블릿 (768px ~ 1024px): 레이아웃 깨짐 없이 표시되는지 확인\n- 데스크톱 (1024px+): 전체 효과가 의도대로 표시되는지 확인\n\n### 4. 다크모드 테스트\n- 라이트모드에서 그라디언트 색상이 올바르게 표시되는지 확인\n- 다크모드 전환 시 그라디언트가 적절한 어두운 톤으로 변경되는지 확인\n- 블롭 불투명도가 다크모드에서 적절하게 조정되는지 확인\n\n### 5. 성능 테스트\n- Chrome DevTools Performance 탭에서 애니메이션 프레임 드롭 확인\n- 60fps 유지 여부 확인\n- CPU 사용량이 과도하지 않은지 확인\n\n### 6. 접근성 테스트\n- `prefers-reduced-motion: reduce` 설정 시 애니메이션이 비활성화되는지 확인\n- 스크린 리더로 텍스트 콘텐츠가 정상적으로 읽히는지 확인\n- 색상 대비가 WCAG 기준을 충족하는지 확인\n\n### 7. 브라우저 호환성 테스트\n- Chrome, Firefox, Safari, Edge에서 그라디언트 렌더링 확인\n- CSS blur 효과가 모든 브라우저에서 동작하는지 확인\n- 애니메이션 키프레임이 일관되게 동작하는지 확인",
        "status": "pending",
        "dependencies": [
          "1",
          "2"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement gradient background in HeroSection.tsx",
            "description": "Add the absolute positioned gradient background layer with light/dark mode variants to the Hero section container.",
            "dependencies": [],
            "details": "Update components/landing/HeroSection.tsx with the provided gradient div: absolute inset-0 bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-100/50 dark:from-slate-950 dark:via-blue-950/30 dark:to-indigo-950/50. Ensure section has relative min-h-[80vh] overflow-hidden classes.",
            "status": "pending",
            "testStrategy": "Verify gradient covers entire Hero section, transitions smoothly between light/dark modes, and maintains readability of overlaid content."
          },
          {
            "id": 2,
            "title": "Add animated blob elements to Hero background",
            "description": "Implement three animated blob divs with different positions, sizes, colors, and delays for dynamic visual effect.",
            "dependencies": [
              1
            ],
            "details": "Add three absolute positioned divs in HeroSection.tsx: top-1/4 -left-20 w-72 h-72 bg-blue-400/20, top-1/3 -right-20 w-96 h-96 bg-indigo-400/20, bottom-1/4 left-1/3 w-80 h-80 bg-purple-400/15. All with rounded-full blur-3xl animate-blob classes and respective animation-delay utilities.",
            "status": "pending",
            "testStrategy": "Confirm blobs animate smoothly over 7s cycle, delays create staggered motion (0s, 2s, 4s), remain blurred and subtle behind content."
          },
          {
            "id": 3,
            "title": "Extend Tailwind config with blob animation keyframes",
            "description": "Add custom blob, fadeIn, slideUp, and float animations plus corresponding keyframes to tailwind.config.js.",
            "dependencies": [
              1
            ],
            "details": "In tailwind.config.js theme.extend.animation, add 'blob': 'blob 7s infinite' and others. In keyframes, define blob transform sequence (0px0px scale1 → 30px-50px scale1.1 → -20px20px scale0.9 → 0px0px scale1), plus fadeIn, slideUp, float definitions as provided.",
            "status": "pending",
            "testStrategy": "Test animate-blob class applies 7s infinite loop with smooth transform changes. Verify all new animations (fade-in, slide-up, float) are available as Tailwind classes."
          },
          {
            "id": 4,
            "title": "Create CSS animation delay utility classes",
            "description": "Add custom CSS classes for animation delays in globals.css to support staggered blob animations.",
            "dependencies": [
              2,
              3
            ],
            "details": "In globals.css or dedicated CSS file, define .animation-delay-2000 { animation-delay: 2s; } and .animation-delay-4000 { animation-delay: 4s; }. Ensure these classes are properly scoped and don't conflict with Tailwind utilities.",
            "status": "pending",
            "testStrategy": "Apply classes to blob elements and verify first blob animates immediately, second after 2s delay, third after 4s delay for natural wave effect."
          },
          {
            "id": 5,
            "title": "Apply performance optimizations and accessibility",
            "description": "Add GPU acceleration, reduced motion support, and verify text animations while preserving original copy.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add will-change: transform to blob elements for GPU acceleration. Implement @media (prefers-reduced-motion: reduce) to disable animations. Optionally add staggered fade-in/slide-up to h1/p elements with delays (0.2s/0.4s). Confirm exact copy preservation: 'Know what's changing.' and 'Without reading everything.'",
            "status": "pending",
            "testStrategy": "Test 60fps smooth animations, no layout shifts, perfect text legibility over dynamic background. Verify animations disable in reduced-motion mode. Cross-browser/device responsive testing."
          }
        ]
      },
      {
        "id": 4,
        "title": "LandingPage 신뢰도 섹션 추가 - Stats/Numbers 및 Social Proof",
        "description": "LandingPage에 신뢰도를 높이는 Stats/Numbers 섹션과 Social Proof 요소를 미니멀한 디자인으로 추가합니다. 과장 없이 실제 데이터 기반의 통계와 사용자 증언을 표시합니다.",
        "details": "## 구현 단계\n\n### 1. Stats/Numbers 섹션 컴포넌트 생성\n```tsx\n// components/landing/StatsSection.tsx\ninterface StatItem {\n  value: string;\n  label: string;\n  suffix?: string;\n}\n\nconst StatsSection = () => {\n  const stats: StatItem[] = [\n    { value: \"50\", suffix: \"+\", label: \"활성 사용자\" },\n    { value: \"1,000\", suffix: \"+\", label: \"분석된 문서\" },\n    { value: \"95\", suffix: \"%\", label: \"시간 절약\" },\n    { value: \"24/7\", label: \"실시간 모니터링\" }\n  ];\n\n  return (\n    <section className=\"py-16 px-4 bg-slate-50/50 dark:bg-slate-900/50\">\n      <div className=\"max-w-5xl mx-auto\">\n        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-8\">\n          {stats.map((stat, index) => (\n            <div key={index} className=\"text-center\">\n              <div className=\"text-3xl md:text-4xl font-bold text-slate-900 dark:text-white\">\n                {stat.value}\n                {stat.suffix && <span className=\"text-blue-600\">{stat.suffix}</span>}\n              </div>\n              <p className=\"mt-2 text-sm text-slate-600 dark:text-slate-400\">\n                {stat.label}\n              </p>\n            </div>\n          ))}\n        </div>\n      </div>\n    </section>\n  );\n};\n```\n\n### 2. Social Proof 컴포넌트 생성\n```tsx\n// components/landing/SocialProofSection.tsx\ninterface Testimonial {\n  quote: string;\n  author: string;\n  role: string;\n  company?: string;\n}\n\nconst SocialProofSection = () => {\n  const testimonials: Testimonial[] = [\n    {\n      quote: \"문서 변경사항을 놓치지 않게 되어 업무 효율이 크게 향상되었습니다.\",\n      author: \"김민수\",\n      role: \"프로덕트 매니저\",\n      company: \"스타트업 A\"\n    },\n    // 2-3개의 간결한 증언\n  ];\n\n  return (\n    <section className=\"py-16 px-4\">\n      <div className=\"max-w-4xl mx-auto\">\n        <h3 className=\"text-center text-sm font-medium text-slate-500 dark:text-slate-400 uppercase tracking-wider mb-8\">\n          사용자 후기\n        </h3>\n        <div className=\"grid md:grid-cols-2 gap-6\">\n          {testimonials.map((item, index) => (\n            <div \n              key={index}\n              className=\"p-6 rounded-lg bg-white dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700\"\n            >\n              <p className=\"text-slate-700 dark:text-slate-300 text-sm leading-relaxed\">\n                \"{item.quote}\"\n              </p>\n              <div className=\"mt-4 flex items-center gap-3\">\n                <div className=\"w-8 h-8 rounded-full bg-slate-200 dark:bg-slate-700\" />\n                <div>\n                  <p className=\"text-sm font-medium text-slate-900 dark:text-white\">\n                    {item.author}\n                  </p>\n                  <p className=\"text-xs text-slate-500 dark:text-slate-400\">\n                    {item.role}{item.company && `, ${item.company}`}\n                  </p>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </section>\n  );\n};\n```\n\n### 3. 로고 클라우드 (선택적, 미니멀)\n```tsx\n// components/landing/TrustedBy.tsx\nconst TrustedBy = () => {\n  return (\n    <div className=\"py-8 border-t border-slate-200 dark:border-slate-800\">\n      <p className=\"text-center text-xs text-slate-400 mb-4\">\n        신뢰받는 서비스\n      </p>\n      <div className=\"flex justify-center items-center gap-8 opacity-50\">\n        {/* 실제 파트너/고객 로고 또는 플레이스홀더 */}\n      </div>\n    </div>\n  );\n};\n```\n\n### 4. LandingPage에 통합\n```tsx\n// app/page.tsx 또는 components/landing/LandingPage.tsx\nimport { StatsSection } from './StatsSection';\nimport { SocialProofSection } from './SocialProofSection';\n\n// Hero 섹션 아래에 배치\n<HeroSection />\n<StatsSection />\n<SocialProofSection />\n```\n\n### 5. 디자인 원칙\n- 과장된 숫자 사용 금지 (실제 데이터 또는 보수적 추정치 사용)\n- 여백을 충분히 활용하여 미니멀함 유지\n- 색상은 기존 디자인 시스템 준수 (slate, blue 계열)\n- 애니메이션은 최소화 (필요시 fade-in 정도만)",
        "testStrategy": "## 테스트 전략\n\n### 1. 시각적 검증\n- Stats 섹션이 Hero 섹션 아래에 올바르게 배치되는지 확인\n- 숫자와 레이블이 명확하게 가독성 있게 표시되는지 확인\n- 반응형 레이아웃 테스트: 모바일(2열), 데스크톱(4열) 그리드 확인\n- Social Proof 카드가 균일한 높이와 간격으로 표시되는지 확인\n\n### 2. 콘텐츠 검증\n- 통계 수치가 과장되지 않고 신뢰할 수 있는 범위인지 검토\n- 증언 내용이 자연스럽고 구체적인지 확인\n- 모든 텍스트가 다크모드/라이트모드에서 가독성 있는지 확인\n\n### 3. 디자인 일관성 테스트\n- 기존 Hero 섹션 및 다른 컴포넌트와 시각적 일관성 유지 확인\n- 색상 팔레트가 디자인 시스템을 준수하는지 확인\n- 여백과 타이포그래피가 미니멀한 느낌을 유지하는지 확인\n\n### 4. 접근성 테스트\n- 스크린 리더로 Stats 섹션 내용이 올바르게 읽히는지 확인\n- 색상 대비가 WCAG 기준을 충족하는지 확인\n- 키보드 네비게이션이 정상 작동하는지 확인\n\n### 5. 성능 테스트\n- 추가된 컴포넌트로 인한 페이지 로드 시간 증가가 미미한지 확인\n- 불필요한 리렌더링이 발생하지 않는지 확인",
        "status": "pending",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "StatsSection 컴포넌트 생성 및 데이터 검증",
            "description": "제공된 StatsSection.tsx 코드를 components/landing/StatsSection.tsx에 생성하고, 통계 데이터가 실제 기반인지 검증합니다.",
            "dependencies": [],
            "details": "StatItem 인터페이스와 4개 통계 아이템(활성 사용자 50+, 분석 문서 1,000+, 시간 절약 95%, 24/7 모니터링)을 구현. 숫자가 과장되지 않도록 실제 데이터 또는 보수적 추정치 사용 확인. 반응형 그리드(모바일 2열, 데스크톱 4열)와 다크모드 지원.",
            "status": "pending",
            "testStrategy": "시각적 검증: 모바일/데스크톱 그리드 레이아웃, 숫자/라벨 가독성, 다크모드 색상. 콘텐츠 검증: 통계 수치 신뢰성, suffix 표시 정상 작동."
          },
          {
            "id": 2,
            "title": "SocialProofSection 컴포넌트 완성 및 증언 추가",
            "description": "SocialProofSection.tsx를 완성하고 3개의 구체적 사용자 증언을 추가합니다.",
            "dependencies": [],
            "details": "Testimonial 인터페이스 구현. 3개 증언 추가(예: 업무 효율 향상, 문서 관리 개선 등). 각 증언에 quote, author, role, company 포함. 카드 디자인(패딩, 보더, 아바타 플레이스홀더)과 반응형 그리드 적용. 미니멀 타이틀 '사용자 후기' 추가.",
            "status": "pending",
            "testStrategy": "카드 균일 높이/간격 확인, 반응형 그리드 테스트, 증언 텍스트 가독성(라이트/다크모드), 아바타/텍스트 정렬 검증."
          },
          {
            "id": 3,
            "title": "TrustedBy 로고 클라우드 컴포넌트 구현",
            "description": "TrustedBy.tsx 컴포넌트를 생성하여 미니멀한 파트너 로고 섹션을 추가합니다.",
            "dependencies": [],
            "details": "상단 '신뢰받는 서비스' 텍스트와 중앙 정렬 로고 컨테이너 구현. opacity-50으로 미니멀 효과. 실제 파트너 로고 또는 플레이스홀더 4-6개 배치. 테두리(border-t)와 py-8 스페이싱 적용. 기존 디자인 시스템(slate 색상) 준수.",
            "status": "pending",
            "testStrategy": "로고 정렬/간격 확인, opacity 효과, 반응형(작은 화면에서 줄임), 텍스트 가독성 테스트."
          },
          {
            "id": 4,
            "title": "LandingPage에 신뢰도 섹션 통합",
            "description": "app/page.tsx 또는 LandingPage에 StatsSection, SocialProofSection, TrustedBy를 HeroSection 아래에 순서대로 추가합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "import 구문 추가 후 HeroSection 다음에 <StatsSection />, <SocialProofSection />, <TrustedBy /> 배치. 섹션 간 여백(py-16 등)으로 미니멀 레이아웃 유지. Task 3 의존성 고려하여 Hero 섹션과 조화 확인.",
            "status": "pending",
            "testStrategy": "전체 페이지 스크롤 시 섹션 순서/간격 확인, Hero와의 시각적 연결성, 로딩 후 배치 정확성."
          },
          {
            "id": 5,
            "title": "디자인 일관성 및 최종 검증",
            "description": "디자인 원칙 준수 여부와 테스트 전략 실행으로 신뢰도 섹션 완성도를 검증합니다.",
            "dependencies": [
              4
            ],
            "details": "미니멀 디자인(여백 활용, slate/blue 색상), 애니메이션 최소화 확인. 과장 금지 원칙 재검토. 반응형, 다크모드, 가독성 최종 테스트. Task 5 레이아웃 보완과 연계하여 전체 페이지 조화 검토.",
            "status": "pending",
            "testStrategy": "전체 테스트 전략 실행: 시각적(반응형, 다크모드), 콘텐츠(과장 여부, 자연스러움), 성능(로드 속도), 브라우저 호환성 확인."
          }
        ]
      },
      {
        "id": 5,
        "title": "LandingPage 레이아웃/섹션 보완 - 시각적 요소 개선 및 미니멀 아이콘/여백 활용",
        "description": "LandingPage의 전체 레이아웃과 섹션 구조를 보완합니다. 기존 문구는 그대로 유지하면서 시각적 요소만 개선하고, 미니멀한 아이콘과 적절한 여백을 활용하여 가독성과 사용자 경험을 향상시킵니다.",
        "details": "## 구현 단계\n\n### 1. 섹션 간 여백 및 간격 시스템 정의\n```tsx\n// styles/spacing.ts 또는 tailwind.config.js 확장\nconst sectionSpacing = {\n  sm: 'py-12 md:py-16',      // 작은 섹션\n  md: 'py-16 md:py-24',      // 중간 섹션\n  lg: 'py-20 md:py-32',      // 큰 섹션 (Hero 등)\n};\n\n// 컨테이너 최대 너비 및 패딩\nconst containerStyles = 'max-w-6xl mx-auto px-4 sm:px-6 lg:px-8';\n```\n\n### 2. 미니멀 아이콘 시스템 구현\n```tsx\n// components/landing/MinimalIcon.tsx\nimport { LucideIcon } from 'lucide-react';\n\ninterface MinimalIconProps {\n  icon: LucideIcon;\n  size?: 'sm' | 'md' | 'lg';\n  variant?: 'default' | 'outlined' | 'filled';\n}\n\nconst MinimalIcon = ({ icon: Icon, size = 'md', variant = 'default' }: MinimalIconProps) => {\n  const sizeClasses = {\n    sm: 'w-4 h-4',\n    md: 'w-5 h-5',\n    lg: 'w-6 h-6'\n  };\n\n  const variantClasses = {\n    default: 'text-slate-600 dark:text-slate-400',\n    outlined: 'text-blue-600 dark:text-blue-400 stroke-[1.5]',\n    filled: 'text-blue-500 dark:text-blue-400 fill-current'\n  };\n\n  return (\n    <Icon className={`${sizeClasses[size]} ${variantClasses[variant]} transition-colors`} />\n  );\n};\n```\n\n### 3. 섹션 구분선/디바이더 컴포넌트\n```tsx\n// components/landing/SectionDivider.tsx\nconst SectionDivider = ({ variant = 'subtle' }: { variant?: 'subtle' | 'gradient' | 'none' }) => {\n  if (variant === 'none') return null;\n  \n  return (\n    <div className=\"w-full flex justify-center\">\n      {variant === 'subtle' && (\n        <div className=\"w-16 h-px bg-slate-200 dark:bg-slate-700\" />\n      )}\n      {variant === 'gradient' && (\n        <div className=\"w-24 h-px bg-gradient-to-r from-transparent via-slate-300 dark:via-slate-600 to-transparent\" />\n      )}\n    </div>\n  );\n};\n```\n\n### 4. 섹션 래퍼 컴포넌트 생성\n```tsx\n// components/landing/Section.tsx\ninterface SectionProps {\n  children: React.ReactNode;\n  spacing?: 'sm' | 'md' | 'lg';\n  background?: 'default' | 'muted' | 'accent';\n  className?: string;\n}\n\nconst Section = ({ children, spacing = 'md', background = 'default', className }: SectionProps) => {\n  const spacingClasses = {\n    sm: 'py-12 md:py-16',\n    md: 'py-16 md:py-24',\n    lg: 'py-20 md:py-32'\n  };\n\n  const bgClasses = {\n    default: 'bg-white dark:bg-slate-900',\n    muted: 'bg-slate-50/50 dark:bg-slate-800/30',\n    accent: 'bg-gradient-to-b from-blue-50/30 to-transparent dark:from-blue-950/20'\n  };\n\n  return (\n    <section className={`${spacingClasses[spacing]} ${bgClasses[background]} ${className || ''}`}>\n      <div className=\"max-w-6xl mx-auto px-4 sm:px-6 lg:px-8\">\n        {children}\n      </div>\n    </section>\n  );\n};\n```\n\n### 5. Feature 섹션 아이콘 개선\n```tsx\n// components/landing/FeatureItem.tsx\nimport { FileText, Bell, Zap, Shield } from 'lucide-react';\n\nconst features = [\n  { icon: FileText, title: '기존 제목 유지', description: '기존 설명 유지' },\n  { icon: Bell, title: '기존 제목 유지', description: '기존 설명 유지' },\n  { icon: Zap, title: '기존 제목 유지', description: '기존 설명 유지' },\n  { icon: Shield, title: '기존 제목 유지', description: '기존 설명 유지' },\n];\n\nconst FeatureItem = ({ icon: Icon, title, description }) => (\n  <div className=\"group flex flex-col items-start space-y-3 p-6\">\n    <div className=\"p-2 rounded-lg bg-blue-50 dark:bg-blue-900/20 group-hover:bg-blue-100 dark:group-hover:bg-blue-900/30 transition-colors\">\n      <Icon className=\"w-5 h-5 text-blue-600 dark:text-blue-400 stroke-[1.5]\" />\n    </div>\n    <h3 className=\"text-lg font-semibold text-slate-900 dark:text-white\">{title}</h3>\n    <p className=\"text-slate-600 dark:text-slate-400 leading-relaxed\">{description}</p>\n  </div>\n);\n```\n\n### 6. 전체 LandingPage 레이아웃 구조 개선\n```tsx\n// app/(landing)/page.tsx 또는 components/landing/LandingPage.tsx\nconst LandingPage = () => {\n  return (\n    <main className=\"min-h-screen\">\n      {/* Hero Section - 기존 문구 유지 */}\n      <HeroSection />\n      \n      {/* 섹션 구분 */}\n      <SectionDivider variant=\"gradient\" />\n      \n      {/* Stats Section */}\n      <Section spacing=\"md\" background=\"muted\">\n        <StatsSection />\n      </Section>\n      \n      {/* Features Section - 기존 문구 유지, 아이콘만 개선 */}\n      <Section spacing=\"lg\" background=\"default\">\n        <FeaturesSection />\n      </Section>\n      \n      {/* Social Proof */}\n      <Section spacing=\"md\" background=\"muted\">\n        <SocialProofSection />\n      </Section>\n      \n      {/* CTA Section - 기존 문구 유지 */}\n      <Section spacing=\"lg\" background=\"accent\">\n        <CTASection />\n      </Section>\n    </main>\n  );\n};\n```\n\n### 7. 반응형 여백 조정\n```css\n/* globals.css 또는 tailwind 유틸리티 */\n@layer utilities {\n  .section-padding {\n    @apply py-12 md:py-16 lg:py-24;\n  }\n  \n  .content-spacing {\n    @apply space-y-4 md:space-y-6;\n  }\n  \n  .card-grid {\n    @apply grid gap-6 md:gap-8 lg:gap-10;\n  }\n}\n```\n\n### 8. 아이콘 선택 가이드라인\n- Lucide React 아이콘 사용 (일관성 유지)\n- stroke-width: 1.5 (미니멀한 느낌)\n- 크기: 20-24px (가독성과 미니멀 밸런스)\n- 색상: 브랜드 컬러 (blue-600/blue-400) 또는 중립 (slate-600/slate-400)",
        "testStrategy": "## 테스트 전략\n\n### 1. 문구 유지 검증\n- 모든 기존 헤드라인, 서브텍스트, 버튼 텍스트가 변경되지 않았는지 확인\n- Hero 섹션의 \"Know what's changing. Without reading everything.\" 문구 유지 확인\n- Feature 섹션의 모든 제목과 설명 텍스트 원본 대조 확인\n- CTA 섹션 문구 변경 없음 확인\n\n### 2. 시각적 요소 검증\n- 아이콘이 일관된 스타일(Lucide, stroke-width 1.5)로 적용되었는지 확인\n- 모든 아이콘이 적절한 크기(20-24px)로 표시되는지 확인\n- 아이콘 컬러가 다크모드/라이트모드에서 올바르게 전환되는지 확인\n- 아이콘 호버 효과가 부드럽게 동작하는지 확인\n\n### 3. 여백 및 간격 검증\n- 섹션 간 여백이 일관되게 적용되었는지 확인 (py-16/py-24/py-32)\n- 컨테이너 패딩이 반응형으로 올바르게 조정되는지 확인\n- 카드/아이템 간 간격이 균일한지 확인\n- 텍스트 블록 내 line-height와 letter-spacing 가독성 확인\n\n### 4. 반응형 레이아웃 테스트\n- 모바일 (320px, 375px, 414px): 여백 축소, 단일 컬럼 레이아웃 확인\n- 태블릿 (768px, 1024px): 중간 여백, 2열 그리드 확인\n- 데스크톱 (1280px, 1440px+): 최대 여백, 전체 그리드 레이아웃 확인\n- 각 브레이크포인트에서 콘텐츠 오버플로우 없음 확인\n\n### 5. 섹션 구분 및 흐름 검증\n- SectionDivider가 적절한 위치에 표시되는지 확인\n- 섹션 배경색 전환이 자연스러운지 확인\n- 스크롤 시 섹션 간 시각적 구분이 명확한지 확인\n\n### 6. 접근성 검증\n- 아이콘에 적절한 aria-label 또는 sr-only 텍스트 제공 확인\n- 색상 대비가 WCAG AA 기준 충족하는지 확인\n- 포커스 상태가 명확하게 표시되는지 확인\n\n### 7. 성능 검증\n- 아이콘 SVG가 최적화되어 있는지 확인\n- 불필요한 리렌더링 없이 컴포넌트가 동작하는지 확인\n- Lighthouse 성능 점수 유지 또는 개선 확인\n\n### 8. 디자인 일관성 검증\n- 기존 Task 2, 3, 4에서 구현된 컴포넌트와 스타일 일관성 확인\n- 전체 페이지 스크롤 시 시각적 통일감 확인\n- 브랜드 컬러 및 타이포그래피 일관성 확인",
        "status": "pending",
        "dependencies": [
          "1",
          "2",
          "3",
          "4"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "섹션 간 여백 및 간격 시스템 정의",
            "description": "LandingPage의 섹션 간 일관된 여백 시스템을 정의하고 Tailwind 클래스 또는 전역 스타일로 구현합니다.",
            "dependencies": [],
            "details": "styles/spacing.ts 파일 생성 또는 tailwind.config.js 확장. sectionSpacing 객체(sm, md, lg)와 containerStyles(max-w-6xl mx-auto px-4 sm:px-6 lg:px-8) 구현. 모든 섹션에서 재사용 가능하도록 export.",
            "status": "pending",
            "testStrategy": "모든 화면 크기에서 섹션 간격이 균일한지 확인. Hero(lg), 일반 섹션(md) 여백 적용 검증. 모바일/태블릿/데스크톱 반응형 동작 테스트."
          },
          {
            "id": 2,
            "title": "미니멀 아이콘 시스템 컴포넌트 구현",
            "description": "Lucide React 아이콘을 위한 재사용 가능한 MinimalIcon 컴포넌트를 생성합니다.",
            "dependencies": [
              1
            ],
            "details": "components/landing/MinimalIcon.tsx 생성. size(sm/md/lg), variant(default/outlined/filled) props 지원. stroke-width 1.5, 브랜드 컬러(blue-600/400) 적용. Feature 섹션에서 즉시 사용 가능.",
            "status": "pending",
            "testStrategy": "각 size/variant 조합에서 아이콘 렌더링 확인. 호버 시 transition-colors 효과 검증. 다크/라이트 모드 색상 일관성 테스트."
          },
          {
            "id": 3,
            "title": "섹션 래퍼 및 구분선 컴포넌트 생성",
            "description": "Section 래퍼와 SectionDivider 컴포넌트를 구현하여 레이아웃 구조를 통일합니다.",
            "dependencies": [
              1
            ],
            "details": "components/landing/Section.tsx와 SectionDivider.tsx 생성. Section은 spacing(sm/md/lg), background(default/muted/accent) props 지원. Divider는 subtle/gradient/none variant 구현.",
            "status": "pending",
            "testStrategy": "각 background variant에서 배경색과 여백 적용 확인. SectionDivider가 섹션 간에 자연스럽게 표시되는지 검증. 반응형 너비 조정 테스트."
          },
          {
            "id": 4,
            "title": "Feature 섹션 아이콘 및 카드 디자인 개선",
            "description": "기존 Feature 섹션에 MinimalIcon과 개선된 FeatureItem 카드를 적용합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "components/landing/FeatureItem.tsx 업데이트. group-hover 효과, blue 배경 패딩 영역, stroke-[1.5] 아이콘 적용. 기존 문구는 변경하지 않고 시각적 요소만 개선.",
            "status": "pending",
            "testStrategy": "기존 Feature 문구가 변경되지 않았는지 텍스트 대조 확인. 호버 애니메이션 부드러운 동작 검증. 카드 그리드 반응형(모바일 1열, 데스크톱 3-4열) 테스트."
          },
          {
            "id": 5,
            "title": "전체 LandingPage 레이아웃 구조 통합 및 최적화",
            "description": "새 컴포넌트들을 LandingPage에 적용하고 반응형 여백을 최종 조정합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "app/(landing)/page.tsx 업데이트. Hero → SectionDivider → Stats → Features → SocialProof → CTA 순서로 Section 컴포넌트 적용. globals.css에 .section-padding, .content-spacing, .card-grid 유틸리티 추가.",
            "status": "pending",
            "testStrategy": "전체 페이지 스크롤 경험 확인(부드러운 전환, 적절한 여백). 모든 기존 문구 유지 검증. 모바일 우선 반응형 테스트 및 Core Web Vitals 영향 최소화 확인."
          }
        ]
      },
      {
        "id": 6,
        "title": "Cloudflare Workers Cron Triggers 활성화",
        "description": "wrangler.toml에서 주석 처리된 cron triggers를 활성화하고 4시간 간격(0 */4 * * *)으로 설정하여 크롤링 주기를 12시간에서 4시간으로 단축",
        "details": "1. wrangler.toml 파일 수정:\n```toml\n[triggers]\ncrons = [\"0 */4 * * *\"]\n```\n\n2. Cloudflare Workers 배포 설정 확인:\n- wrangler.toml에서 name, main, compatibility_date 등 기본 설정 검증\n- 환경 변수(SUPABASE_URL, SUPABASE_KEY, AI_API_KEY 등) 설정 확인\n\n3. 배포 명령어:\n```bash\nwrangler deploy\n```\n\n4. Cloudflare Dashboard에서 cron trigger 활성화 상태 확인",
        "testStrategy": "1. wrangler dev로 로컬 테스트 실행\n2. Cloudflare Dashboard에서 cron trigger 등록 확인\n3. 수동으로 Worker 호출하여 정상 동작 검증\n4. 4시간 후 자동 실행 로그 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "wrangler.toml Cron Triggers 활성화",
            "description": "wrangler.toml 파일에서 주석 처리된 cron triggers 섹션을 활성화하고 crons를 '0 */4 * * *'로 설정",
            "dependencies": [],
            "details": "기존 [triggers] 섹션의 주석 제거 후 crons = ['0 */4 * * *']로 수정. 파일 저장 후 변경사항 git에 커밋.",
            "status": "pending",
            "testStrategy": "파일 내용 확인: cat wrangler.toml | grep crons 출력 검증"
          },
          {
            "id": 2,
            "title": "배포 설정 검증",
            "description": "wrangler.toml의 name, main, compatibility_date 설정 확인 및 환경변수 존재 여부 검토",
            "dependencies": [
              1
            ],
            "details": "wrangler.toml 기본 설정 검증(name 일치, main 올바른 경로, compatibility_date 최근 날짜). 환경변수 SUPABASE_URL, SUPABASE_KEY, AI_API_KEY 등이 wrangler secret에 설정되어 있는지 확인.",
            "status": "pending",
            "testStrategy": "wrangler whoami 및 wrangler secret list로 계정/환경변수 상태 확인"
          },
          {
            "id": 3,
            "title": "Cloudflare Worker 배포",
            "description": "수정된 wrangler.toml로 wrangler deploy 명령어 실행하여 변경사항 배포",
            "dependencies": [
              2
            ],
            "details": "터미널에서 npx wrangler deploy 실행. 배포 성공 메시지 및 Worker URL 확인. 에러 발생 시 wrangler.toml syntax 오류 수정.",
            "status": "pending",
            "testStrategy": "배포 로그에서 'Cron triggers successfully updated' 메시지 확인"
          },
          {
            "id": 4,
            "title": "Cron Trigger Dashboard 확인",
            "description": "Cloudflare Dashboard에서 Worker의 Triggers > Cron Triggers 섹션에서 4시간 간격 스케줄 등록 확인",
            "dependencies": [
              3
            ],
            "details": "Cloudflare Dashboard > Workers & Pages > 해당 Worker > Settings > Triggers > Cron Triggers 이동. '0 */4 * * *' 스케줄이 활성화되어 있는지 스크린샷 저장.",
            "status": "pending",
            "testStrategy": "Dashboard에서 cron 표현식과 활성화 상태 시각적 확인"
          },
          {
            "id": 5,
            "title": "로컬 Cron 테스트 및 로그 검증",
            "description": "wrangler dev --test-scheduled로 로컬에서 cron 트리거 테스트 후 로그 확인",
            "dependencies": [
              4
            ],
            "details": "npx wrangler dev --test-scheduled 실행 후 curl 'http://localhost:8787/__scheduled?cron=0+*/4+*+*+*+' 명령어로 테스트. 콘솔 로그에서 크롤링 시작 메시지 출력 확인.",
            "status": "pending",
            "testStrategy": "로컬 테스트 성공 + Cloudflare 로그(Observability 탭)에서 최근 실행 기록 확인"
          }
        ]
      },
      {
        "id": 7,
        "title": "workers/ingest.ts 에러 핸들링 및 로깅 강화",
        "description": "Cloudflare Workers의 ingest.ts 파일에 에러 핸들링 강화, 실행 로그 추가, 타임아웃 설정 검토를 통해 안정성 향상",
        "details": "1. 에러 핸들링 강화:\n```typescript\nexport default {\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    const startTime = Date.now();\n    const stats = { processed: 0, errors: 0, skipped: 0 };\n    \n    try {\n      console.log(`[CRON] Starting crawl at ${new Date().toISOString()}`);\n      \n      // 개별 피드 처리 with isolation\n      for (const feed of RSS_FEEDS) {\n        try {\n          const result = await processFeed(feed, env);\n          stats.processed += result.count;\n        } catch (feedError) {\n          console.error(`[ERROR] Feed ${feed.url} failed:`, feedError);\n          stats.errors++;\n          // 개별 피드 실패가 전체에 영향 없도록 continue\n          continue;\n        }\n      }\n      \n      const duration = Date.now() - startTime;\n      console.log(`[CRON] Completed in ${duration}ms. Stats:`, stats);\n    } catch (error) {\n      console.error('[CRON] Critical error:', error);\n      throw error;\n    }\n  }\n};\n```\n\n2. 타임아웃 설정 (Cloudflare Workers CPU limit: 30초 기본, 50ms CPU time):\n- 각 피드 처리에 AbortController 적용\n- 전체 실행 시간 모니터링",
        "testStrategy": "1. 의도적으로 잘못된 RSS URL로 테스트하여 에러 격리 확인\n2. 로그 출력 형식 및 내용 검증\n3. 타임아웃 시나리오 테스트\n4. Cloudflare Workers 로그에서 실행 기록 확인",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement per-feed error isolation and logging",
            "description": "Add try-catch blocks around individual RSS feed processing with detailed error logging and stats tracking while ensuring failures don't affect other feeds",
            "dependencies": [],
            "details": "Integrate provided code snippet into ingest.ts: wrap processFeed calls in try-catch, log feed-specific errors with URL context, update stats.processed/errors/skipped, use console.error for failures and console.log for success metrics[1][2]",
            "status": "pending",
            "testStrategy": "Test with invalid RSS URLs to verify isolation; check Cloudflare logs for structured error messages and stats; confirm other feeds process successfully on single failure"
          },
          {
            "id": 2,
            "title": "Add timeout monitoring and overall execution stats tracking",
            "description": "Implement AbortController for per-feed timeouts, monitor total execution time against Cloudflare limits (30s wall time, 50ms CPU), and enhance completion logging",
            "dependencies": [
              1
            ],
            "details": "Add AbortController to processFeed with 25s timeout per feed; track startTime/duration; log warnings if approaching limits; update final stats log with duration, processed/errors/skipped counts; review ctx.waitUntil for background tasks[2][3]",
            "status": "pending",
            "testStrategy": "Simulate slow feeds to test AbortController; verify timeout logs and graceful degradation; check wrangler tail for execution time metrics; confirm stats accuracy in Cloudflare dashboard"
          }
        ]
      },
      {
        "id": 8,
        "title": "중복 기사 AI 처리 스킵 로직 구현",
        "description": "deduplication 단계에서 이미 존재하는 기사는 AI 처리를 완전히 스킵하고, 새로운 기사만 AI 요약/분류를 수행하여 비용 최적화",
        "details": "1. Supabase에서 기존 기사 URL 조회:\n```typescript\nasync function getExistingArticleUrls(urls: string[], supabase: SupabaseClient): Promise<Set<string>> {\n  const { data, error } = await supabase\n    .from('articles')\n    .select('url')\n    .in('url', urls);\n  \n  if (error) throw error;\n  return new Set(data?.map(a => a.url) || []);\n}\n```\n\n2. 새 기사만 필터링:\n```typescript\nasync function processNewArticles(articles: Article[], env: Env) {\n  const urls = articles.map(a => a.url);\n  const existingUrls = await getExistingArticleUrls(urls, env.supabase);\n  \n  const newArticles = articles.filter(a => !existingUrls.has(a.url));\n  \n  console.log(`[DEDUP] ${articles.length} total, ${newArticles.length} new, ${existingUrls.size} skipped`);\n  \n  // 새 기사만 AI 처리\n  if (newArticles.length > 0) {\n    return await processWithAI(newArticles, env);\n  }\n  return [];\n}\n```\n\n3. URL 정규화 함수 추가 (쿼리 파라미터 제거 등):\n```typescript\nfunction normalizeUrl(url: string): string {\n  const parsed = new URL(url);\n  parsed.search = '';\n  parsed.hash = '';\n  return parsed.toString();\n}\n```",
        "testStrategy": "1. 동일 URL 기사 재크롤링 시 AI 호출 없음 확인\n2. 새 기사만 AI 처리되는지 로그로 검증\n3. AI API 호출 횟수 비교 (이전 vs 이후)\n4. 데이터베이스에 중복 기사 없음 확인",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Supabase deduplication query with URL normalization",
            "description": "Create getExistingArticleUrls function that normalizes input URLs before querying Supabase articles table and returns Set of normalized existing URLs",
            "dependencies": [],
            "details": "Integrate normalizeUrl function to clean query parameters and hash from URLs before .in('url', normalizedUrls) query. Handle large URL arrays with Supabase .in() performance optimization and error handling. Ensure normalized URLs are used consistently for comparison.",
            "status": "pending",
            "testStrategy": "Test normalization on URLs with/without query params; verify Supabase returns correct existing normalized URLs; check Set contains exact normalized matches; performance test with 1000+ URLs"
          },
          {
            "id": 2,
            "title": "Integrate filtering logic into main processing pipeline with logging",
            "description": "Implement processNewArticles function to filter new articles using normalized URL check and process only new ones with AI while logging dedup stats",
            "dependencies": [
              1
            ],
            "details": "Call getExistingArticleUrls with normalized article URLs, filter articles where !existingUrls.has(normalizeUrl(a.url)), log total/new/skipped counts, conditionally call processWithAI only for newArticles. Ensure async flow and empty return when no new articles.",
            "status": "pending",
            "testStrategy": "Mock Supabase to test full skip (0 new), partial skip, all new scenarios; verify logs show correct counts; confirm processWithAI called only for new articles; end-to-end test with duplicate URLs"
          }
        ]
      },
      {
        "id": 9,
        "title": "AI 응답 캐싱 시스템 구현",
        "description": "동일 도메인/유사 컨텐츠에 대한 AI 분류 결과를 캐싱하여 API 호출 비용 절감. 캐시 키는 컨텐츠 해시 기반, TTL 24시간",
        "details": "1. Cloudflare KV 또는 Supabase를 활용한 캐시 저장소:\n```typescript\n// KV 네임스페이스 설정 (wrangler.toml)\n// [[kv_namespaces]]\n// binding = \"AI_CACHE\"\n// id = \"your-kv-namespace-id\"\n\ninterface CachedAIResponse {\n  summary: string;\n  category: string;\n  cachedAt: number;\n}\n\nconst CACHE_TTL = 24 * 60 * 60 * 1000; // 24시간\n```\n\n2. 컨텐츠 해시 생성:\n```typescript\nasync function generateContentHash(content: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(content.substring(0, 1000)); // 처음 1000자만 사용\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n```\n\n3. 캐시 조회 및 저장:\n```typescript\nasync function getAIResponseWithCache(\n  article: Article,\n  env: Env\n): Promise<AIResponse> {\n  const cacheKey = await generateContentHash(article.content);\n  \n  // 캐시 조회\n  const cached = await env.AI_CACHE.get(cacheKey, 'json') as CachedAIResponse | null;\n  if (cached && Date.now() - cached.cachedAt < CACHE_TTL) {\n    console.log(`[CACHE HIT] ${article.url}`);\n    return { summary: cached.summary, category: cached.category };\n  }\n  \n  // AI API 호출\n  console.log(`[CACHE MISS] ${article.url}`);\n  const response = await callAI(article, env);\n  \n  // 캐시 저장\n  await env.AI_CACHE.put(cacheKey, JSON.stringify({\n    ...response,\n    cachedAt: Date.now()\n  }), { expirationTtl: 86400 });\n  \n  return response;\n}\n```",
        "testStrategy": "1. 동일 컨텐츠 재처리 시 캐시 히트 확인\n2. 캐시 TTL 만료 후 재호출 검증\n3. 캐시 히트율 로깅 및 모니터링\n4. KV 저장소 데이터 확인",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Cloudflare KV namespace setup and interface",
            "description": "wrangler.toml에 KV 네임스페이스 바인딩 설정하고 CachedAIResponse 인터페이스 및 CACHE_TTL 상수 정의",
            "dependencies": [],
            "details": "wrangler.toml에 [[kv_namespaces]] 섹션 추가 (binding='AI_CACHE', id 설정). TypeScript interface CachedAIResponse {summary, category, cachedAt}와 const CACHE_TTL=24*60*60*1000 구현",
            "status": "pending",
            "testStrategy": "wrangler.toml 설정 후 wrangler deploy로 KV 바인딩 정상 연결 확인"
          },
          {
            "id": 2,
            "title": "Content hashing function implementation",
            "description": "generateContentHash 함수 구현으로 컨텐츠 처음 1000자 SHA-256 해시 생성",
            "dependencies": [
              1
            ],
            "details": "TextEncoder로 UTF-8 인코딩 후 crypto.subtle.digest('SHA-256') 사용. Uint8Array를 hex 문자열로 변환하는 완전한 async 함수 구현 및 export",
            "status": "pending",
            "testStrategy": "동일 컨텐츠에 동일 해시 생성 확인, 다른 컨텐츠에 다른 해시 생성, 1000자 초과 컨텐츠 잘림 테스트"
          },
          {
            "id": 3,
            "title": "Cache get/put logic with TTL integration",
            "description": "getAIResponseWithCache 함수 완성으로 캐시 조회/저장 및 AI API fallback 로직 구현",
            "dependencies": [
              1,
              2
            ],
            "details": "generateContentHash로 cacheKey 생성 후 env.AI_CACHE.get('json') 조회. TTL 체크 후 히트/미스 로깅. AI 호출 후 put with expirationTtl:86400 저장",
            "status": "pending",
            "testStrategy": "캐시 히트(동일 article 재호출), 미스(AI 호출), TTL 만료 후 재호출 테스트"
          }
        ]
      },
      {
        "id": 10,
        "title": "AI API 배치 처리 및 Rate Limiting 최적화",
        "description": "AI API 호출 배치 크기 조정 및 rate limiting 개선. 현재 3개 동시 처리에서 최적 값으로 조정",
        "details": "1. 배치 처리 유틸리티:\n```typescript\nasync function processBatch<T, R>(\n  items: T[],\n  processor: (item: T) => Promise<R>,\n  options: { concurrency: number; delayMs: number }\n): Promise<R[]> {\n  const results: R[] = [];\n  const { concurrency, delayMs } = options;\n  \n  for (let i = 0; i < items.length; i += concurrency) {\n    const batch = items.slice(i, i + concurrency);\n    const batchResults = await Promise.allSettled(\n      batch.map(item => processor(item))\n    );\n    \n    for (const result of batchResults) {\n      if (result.status === 'fulfilled') {\n        results.push(result.value);\n      } else {\n        console.error('[BATCH ERROR]', result.reason);\n      }\n    }\n    \n    // Rate limiting delay\n    if (i + concurrency < items.length) {\n      await new Promise(resolve => setTimeout(resolve, delayMs));\n    }\n  }\n  \n  return results;\n}\n```\n\n2. AI 처리 최적화 (Claude 3 Haiku / GPT-4o-mini):\n```typescript\nconst AI_CONFIG = {\n  concurrency: 5, // 동시 처리 수 증가 (3 -> 5)\n  delayMs: 200,   // 배치 간 딜레이\n  maxRetries: 3,\n  retryDelayMs: 1000\n};\n\nasync function processArticlesWithAI(articles: Article[], env: Env) {\n  return processBatch(\n    articles,\n    (article) => getAIResponseWithCache(article, env),\n    { concurrency: AI_CONFIG.concurrency, delayMs: AI_CONFIG.delayMs }\n  );\n}\n```\n\n3. Exponential backoff for retries:\n```typescript\nasync function callAIWithRetry(article: Article, env: Env, attempt = 1): Promise<AIResponse> {\n  try {\n    return await callAI(article, env);\n  } catch (error) {\n    if (attempt >= AI_CONFIG.maxRetries) throw error;\n    const delay = AI_CONFIG.retryDelayMs * Math.pow(2, attempt - 1);\n    await new Promise(r => setTimeout(r, delay));\n    return callAIWithRetry(article, env, attempt + 1);\n  }\n}\n```",
        "testStrategy": "1. 다양한 concurrency 값으로 성능 테스트\n2. Rate limit 에러 발생 여부 모니터링\n3. 전체 처리 시간 측정 (목표: 2분 이내)\n4. API 에러 시 재시도 로직 검증",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Generic Batch Processing Utility Enhancement",
            "description": "Improve the existing processBatch utility with Promise.allSettled for robust error handling and configurable concurrency control.",
            "dependencies": [],
            "details": "Refactor processBatch<T,R> to properly partition fulfilled/rejected results, add result ordering preservation, enhance error logging with structured output, and ensure TypeScript type safety for PromiseSettledResult handling.",
            "status": "pending",
            "testStrategy": "Test with mixed success/failure batches, verify result ordering, measure performance across concurrency values (3,5,10), validate no data loss on partial failures."
          },
          {
            "id": 2,
            "title": "AI-Specific Concurrency and Rate Limit Configuration",
            "description": "Optimize AI_CONFIG for Claude 3 Haiku/GPT-4o-mini APIs with performance testing and Cloudflare Workers constraints.",
            "dependencies": [
              1
            ],
            "details": "Benchmark concurrency (3→5→10), tune delayMs based on real API rate limits, integrate with processArticlesWithAI, add dynamic adjustment based on observed error rates and CPU time.",
            "status": "pending",
            "testStrategy": "Load test with 100+ articles, monitor rate limit errors, measure total processing time (target <2min), validate Cloudflare CPU limits compliance."
          },
          {
            "id": 3,
            "title": "Exponential Backoff Retry Logic Implementation",
            "description": "Implement robust callAIWithRetry with exponential backoff, jitter, and integration into batch processor.",
            "dependencies": [
              1
            ],
            "details": "Enhance callAIWithRetry with exponential backoff (2^attempt), add jitter (±50ms), maxRetries=3, integrate into getAIResponseWithCache, add retry metrics logging.",
            "status": "pending",
            "testStrategy": "Simulate API failures (429, 5xx), verify backoff delays, test retry success rates, ensure no infinite loops, validate error recovery in batch context."
          }
        ]
      },
      {
        "id": 11,
        "title": "처리 통계 로깅 시스템 구현",
        "description": "크롤링당 처리된 기사 수, AI API 호출 횟수, 캐시 히트율, 실행 시간 등 비용 모니터링을 위한 통계 로깅 시스템 구현",
        "details": "1. 통계 수집 클래스:\n```typescript\nclass CrawlStats {\n  private startTime: number;\n  public totalArticles = 0;\n  public newArticles = 0;\n  public skippedArticles = 0;\n  public aiCalls = 0;\n  public cacheHits = 0;\n  public errors = 0;\n  public feedStats: Record<string, { count: number; errors: number }> = {};\n  \n  constructor() {\n    this.startTime = Date.now();\n  }\n  \n  get duration(): number {\n    return Date.now() - this.startTime;\n  }\n  \n  get cacheHitRate(): number {\n    const total = this.aiCalls + this.cacheHits;\n    return total > 0 ? (this.cacheHits / total) * 100 : 0;\n  }\n  \n  toJSON() {\n    return {\n      timestamp: new Date().toISOString(),\n      duration_ms: this.duration,\n      total_articles: this.totalArticles,\n      new_articles: this.newArticles,\n      skipped_articles: this.skippedArticles,\n      ai_api_calls: this.aiCalls,\n      cache_hits: this.cacheHits,\n      cache_hit_rate: `${this.cacheHitRate.toFixed(2)}%`,\n      errors: this.errors,\n      feed_stats: this.feedStats\n    };\n  }\n}\n```\n\n2. Supabase에 통계 저장:\n```typescript\nasync function saveStats(stats: CrawlStats, supabase: SupabaseClient) {\n  await supabase.from('crawl_logs').insert({\n    ...stats.toJSON(),\n    created_at: new Date().toISOString()\n  });\n}\n```\n\n3. crawl_logs 테이블 스키마:\n```sql\nCREATE TABLE crawl_logs (\n  id SERIAL PRIMARY KEY,\n  timestamp TIMESTAMPTZ NOT NULL,\n  duration_ms INTEGER,\n  total_articles INTEGER,\n  new_articles INTEGER,\n  skipped_articles INTEGER,\n  ai_api_calls INTEGER,\n  cache_hits INTEGER,\n  cache_hit_rate TEXT,\n  errors INTEGER,\n  feed_stats JSONB,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n```",
        "testStrategy": "1. 크롤링 실행 후 crawl_logs 테이블 데이터 확인\n2. 통계 값 정확성 검증 (수동 계산과 비교)\n3. 캐시 히트율 계산 정확성 확인\n4. 여러 번 실행 후 통계 추이 분석",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "CrawlStats 클래스 구현 및 통합",
            "description": "기존 CrawlStats 클래스 완성하고 크롤링 파이프라인 전반에 통계 수집 메서드 통합",
            "dependencies": [],
            "details": "totalArticles, aiCalls, cacheHits 등 카운터 메서드 구현 (incrementTotalArticles(), incrementAICalls() 등). 크롤링, AI 처리, 캐싱 단계에서 stats 객체 호출. toJSON() 및 computed properties (duration, cacheHitRate) 테스트.",
            "status": "pending",
            "testStrategy": "클래스 단위 테스트: 생성자 시간 기록, 카운터 증가, cacheHitRate 계산 정확성 검증, toJSON 직렬화 확인"
          },
          {
            "id": 2,
            "title": "Supabase crawl_logs 테이블 생성 및 저장 로직 구현",
            "description": "crawl_logs 테이블 SQL 실행하고 saveStats 함수를 크롤링 완료 후 호출하도록 통합",
            "dependencies": [
              1
            ],
            "details": "Supabase에서 제공된 테이블 스키마 생성. saveStats 함수 에러 핸들링 및 배치 삽입 최적화. 크롤링 메인 함수 마지막에 stats 저장 호출. feedStats JSONB 직렬화 확인.",
            "status": "pending",
            "testStrategy": "DB 삽입 성공 확인, 데이터 무결성 검증 (duration_ms >0, cache_hit_rate 형식), 여러 실행 후 데이터 누적 확인"
          }
        ]
      },
      {
        "id": 12,
        "title": "RSS 피드 재시도 로직 구현 (Exponential Backoff)",
        "description": "RSS 피드 실패 시 exponential backoff 재시도 로직 구현. 개별 피드 실패가 전체 크롤링에 영향 없도록 격리",
        "details": "1. Exponential backoff 재시도 함수:\n```typescript\ninterface RetryOptions {\n  maxRetries: number;\n  baseDelayMs: number;\n  maxDelayMs: number;\n}\n\nconst DEFAULT_RETRY_OPTIONS: RetryOptions = {\n  maxRetries: 3,\n  baseDelayMs: 1000,\n  maxDelayMs: 10000\n};\n\nasync function fetchWithRetry(\n  url: string,\n  options: RequestInit = {},\n  retryOptions: RetryOptions = DEFAULT_RETRY_OPTIONS\n): Promise<Response> {\n  let lastError: Error | null = null;\n  \n  for (let attempt = 0; attempt <= retryOptions.maxRetries; attempt++) {\n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: AbortSignal.timeout(30000) // 30초 타임아웃\n      });\n      \n      if (!response.ok && response.status >= 500) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      return response;\n    } catch (error) {\n      lastError = error as Error;\n      console.warn(`[RETRY] Attempt ${attempt + 1} failed for ${url}:`, error);\n      \n      if (attempt < retryOptions.maxRetries) {\n        const delay = Math.min(\n          retryOptions.baseDelayMs * Math.pow(2, attempt),\n          retryOptions.maxDelayMs\n        );\n        await new Promise(r => setTimeout(r, delay));\n      }\n    }\n  }\n  \n  throw lastError;\n}\n```\n\n2. 피드 처리 격리:\n```typescript\nasync function processFeedSafely(\n  feed: RSSFeed,\n  env: Env,\n  stats: CrawlStats\n): Promise<Article[]> {\n  try {\n    const response = await fetchWithRetry(feed.url);\n    const xml = await response.text();\n    const articles = parseRSS(xml, feed);\n    \n    stats.feedStats[feed.name] = { count: articles.length, errors: 0 };\n    return articles;\n  } catch (error) {\n    console.error(`[FEED ERROR] ${feed.name}:`, error);\n    stats.feedStats[feed.name] = { count: 0, errors: 1 };\n    stats.errors++;\n    return []; // 빈 배열 반환하여 다른 피드 처리 계속\n  }\n}\n```",
        "testStrategy": "1. 일시적 네트워크 오류 시뮬레이션으로 재시도 검증\n2. 최대 재시도 횟수 도달 시 graceful 실패 확인\n3. 개별 피드 실패 시 다른 피드 정상 처리 확인\n4. 재시도 딜레이 시간 로그로 검증",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Generic fetchWithRetry Function",
            "description": "Exponential backoff 재시도 로직을 가진 범용 fetchWithRetry 함수 구현. AbortSignal 타임아웃, HTTP 5xx 오류 처리, configurable RetryOptions 지원.",
            "dependencies": [],
            "details": "기존 제공된 fetchWithRetry 코드 완성 및 개선: maxRetries=3, baseDelayMs=1000, maxDelayMs=10000 기본값 설정. 500+ 상태코드 재시도, 30초 타임아웃 적용, 재시도 딜레이 로그 출력. 마지막 오류 보존하여 최종 throw.",
            "status": "pending",
            "testStrategy": "1. 네트워크 오류 시뮬레이션으로 재시도 3회 확인\n2. 딜레이 시간(1s,2s,4s) 로그 검증\n3. maxDelayMs 캡핑 확인\n4. 성공 시 즉시 반환, 최종 실패 시 lastError throw 확인"
          },
          {
            "id": 2,
            "title": "Implement Isolated processFeedSafely Wrapper",
            "description": "개별 RSS 피드 처리 격리 wrapper 구현. fetchWithRetry 통합, 오류 발생 시 빈 배열 반환, stats 업데이트 및 전체 크롤링 계속.",
            "dependencies": [
              1
            ],
            "details": "processFeedSafely 함수 구현: try-catch로 fetchWithRetry 호출, RSS 파싱, 성공 시 stats.feedStats[feed.name].count 업데이트, 실패 시 stats.feedStats[feed.name].errors++, stats.errors++ 후 빈 배열 반환하여 다른 피드 처리 격리.",
            "status": "pending",
            "testStrategy": "1. 단일 피드 실패 시 다른 피드 정상 처리 확인\n2. stats 정확성 검증 (count=0, errors=1)\n3. 콘솔 오류 로그 출력 확인\n4. 전체 크롤링 중단되지 않는지 통합 테스트"
          }
        ]
      },
      {
        "id": 13,
        "title": "실패 알림 시스템 구현 (Discord/Slack Webhook)",
        "description": "연속 실패 시 Discord 또는 Slack webhook을 통한 알림 시스템 구현",
        "details": "1. 알림 서비스 구현:\n```typescript\ninterface AlertConfig {\n  webhookUrl: string;\n  consecutiveFailureThreshold: number;\n}\n\nclass AlertService {\n  private config: AlertConfig;\n  \n  constructor(config: AlertConfig) {\n    this.config = config;\n  }\n  \n  async sendAlert(message: string, details?: Record<string, any>) {\n    const payload = {\n      content: `🚨 **Upday Crawler Alert**\\n${message}`,\n      embeds: details ? [{\n        title: 'Details',\n        fields: Object.entries(details).map(([name, value]) => ({\n          name,\n          value: String(value),\n          inline: true\n        }))\n      }] : undefined\n    };\n    \n    try {\n      await fetch(this.config.webhookUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload)\n      });\n    } catch (error) {\n      console.error('[ALERT ERROR]', error);\n    }\n  }\n}\n```\n\n2. 연속 실패 추적 (KV 사용):\n```typescript\nasync function checkAndAlert(\n  stats: CrawlStats,\n  env: Env,\n  alertService: AlertService\n) {\n  const failureKey = 'consecutive_failures';\n  const currentFailures = parseInt(await env.AI_CACHE.get(failureKey) || '0');\n  \n  if (stats.errors > 0 || stats.newArticles === 0) {\n    const newFailures = currentFailures + 1;\n    await env.AI_CACHE.put(failureKey, String(newFailures));\n    \n    if (newFailures >= 3) { // 3회 연속 실패 시 알림\n      await alertService.sendAlert(\n        `크롤링 ${newFailures}회 연속 실패/이상 감지`,\n        {\n          'Errors': stats.errors,\n          'New Articles': stats.newArticles,\n          'Duration': `${stats.duration}ms`\n        }\n      );\n    }\n  } else {\n    await env.AI_CACHE.put(failureKey, '0'); // 성공 시 리셋\n  }\n}\n```\n\n3. 환경 변수 설정:\n```toml\n# wrangler.toml\n[vars]\nALERT_WEBHOOK_URL = \"https://discord.com/api/webhooks/...\"\n```",
        "testStrategy": "1. 테스트 webhook으로 알림 전송 확인\n2. 연속 실패 카운터 정상 동작 검증\n3. 성공 시 카운터 리셋 확인\n4. 알림 메시지 포맷 및 내용 검증",
        "priority": "low",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "AlertService 클래스 구현 및 webhook 페이로드 포맷팅",
            "description": "AlertConfig 인터페이스와 AlertService 클래스를 구현하여 Discord/Slack webhook으로 풍부한 알림(embeds 포함)을 전송하는 기능을 완성합니다.",
            "dependencies": [],
            "details": "제공된 AlertService 코드를 기반으로 config 초기화, sendAlert 메서드에서 Discord embed 포맷팅(🚨 이모지, title, fields), fetch POST 요청 처리, 에러 핸들링을 완성. 환경변수 ALERT_WEBHOOK_URL 로드 및 Slack 호환성 고려.[1][4]",
            "status": "pending",
            "testStrategy": "테스트 webhook URL로 sendAlert 호출하여 메시지 포맷, embed fields, 에러 핸들링 동작 검증."
          },
          {
            "id": 2,
            "title": "KV 기반 연속 실패 카운터 및 임계값 알림 로직 구현",
            "description": "Cloudflare KV(AI_CACHE)를 활용하여 크롤링 실패 횟수를 추적하고, 연속 3회 실패 시 AlertService를 통해 알림을 발송하는 checkAndAlert 함수를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "제공된 checkAndAlert 함수를 기반으로 failureKey 관리, stats.errors 또는 newArticles===0 시 카운터 증가, threshold(3) 도달 시 sendAlert 호출(한국어 메시지, stats details 포함), 성공 시 '0'으로 리셋. wrangler.toml vars 설정 포함.",
            "status": "pending",
            "testStrategy": "모킹된 stats로 연속 실패(1-3회), 성공 리셋, KV put/get 정확성, 알림 트리거 조건 검증."
          }
        ]
      },
      {
        "id": 14,
        "title": "GitHub Actions 백업 스케줄 업데이트",
        "description": "Cloudflare Workers 실패 대비용 GitHub Actions 스케줄을 하루 2회에서 1회로 축소하거나 수동 트리거만 유지하도록 업데이트",
        "details": "1. GitHub Actions workflow 파일 수정 (.github/workflows/crawl.yml):\n```yaml\nname: Article Crawler (Backup)\n\non:\n  # 수동 트리거\n  workflow_dispatch:\n    inputs:\n      force:\n        description: 'Force full crawl'\n        required: false\n        default: 'false'\n  \n  # 백업 스케줄: 하루 1회 (UTC 12:00 = KST 21:00)\n  schedule:\n    - cron: '0 12 * * *'\n\njobs:\n  crawl:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Run crawler\n        env:\n          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}\n          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}\n          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n        run: npm run crawl\n      \n      - name: Notify on failure\n        if: failure()\n        run: |\n          curl -X POST ${{ secrets.ALERT_WEBHOOK_URL }} \\\n            -H 'Content-Type: application/json' \\\n            -d '{\"content\": \"⚠️ GitHub Actions backup crawler failed!\"}'\n```\n\n2. 또는 완전 비활성화 옵션:\n```yaml\non:\n  workflow_dispatch: # 수동 트리거만\n```\n\n3. README 업데이트로 새 스케줄 문서화",
        "testStrategy": "1. workflow_dispatch로 수동 실행 테스트\n2. 스케줄 변경 후 예상 시간에 실행 확인\n3. Cloudflare Workers와 중복 실행 없음 확인\n4. 실패 시 알림 동작 검증",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "GitHub Actions workflow 파일 수정",
            "description": "crawl.yml 파일의 schedule 섹션을 하루 1회(UTC 12:00)로 업데이트하거나 완전 제거",
            "dependencies": [],
            "details": "현재 제공된 YAML을 기반으로 .github/workflows/crawl.yml 파일 수정. 옵션1: cron: '0 12 * * *' 유지, 옵션2: schedule 섹션 완전 제거하고 workflow_dispatch만 남김.",
            "status": "pending",
            "testStrategy": "YAML 문법 검증 및 GitHub Actions syntax checker 사용"
          },
          {
            "id": 2,
            "title": "변경사항 Git 커밋 및 푸시",
            "description": "수정된 workflow 파일을 default branch에 커밋하고 푸시하여 GitHub Actions 적용",
            "dependencies": [
              1
            ],
            "details": "커밋 메시지: 'GitHub Actions backup schedule: daily -> once daily (UTC 12:00) or manual only'. default branch 확인 후 푸시.",
            "status": "pending",
            "testStrategy": "GitHub repository Actions 탭에서 workflow 파일 업데이트 확인"
          },
          {
            "id": 3,
            "title": "수동 트리거 테스트 실행",
            "description": "workflow_dispatch로 수동 실행하여 크롤러 정상 동작 검증",
            "dependencies": [
              2
            ],
            "details": "GitHub Actions 탭에서 'Run workflow' 버튼 클릭, force: false로 기본 실행 후 로그 확인. Supabase 연결 및 크롤링 성공 여부 검증.",
            "status": "pending",
            "testStrategy": "실행 로그에서 'Run crawler' 스텝 성공 확인 및 데이터베이스에 새 데이터 삽입 검증"
          },
          {
            "id": 4,
            "title": "스케줄 변경 검증 및 모니터링",
            "description": "새 스케줄(UTC 12:00) 실행 확인 및 Cloudflare Workers와 중복 실행 여부 점검",
            "dependencies": [
              2
            ],
            "details": "UTC 12:00 ±30분 내 실행 로그 확인. Cloudflare Workers 로그와 시간 비교하여 중복 없음 확인. GitHub Actions queue 지연 고려.",
            "status": "pending",
            "testStrategy": "실제 스케줄 시간에 Actions 탭 및 Cloudflare Dashboard 동시 모니터링"
          },
          {
            "id": 5,
            "title": "실패 알림 테스트 및 README 업데이트",
            "description": "실패 시 알림 동작 검증 후 README에 새 스케줄 문서화",
            "dependencies": [
              3
            ],
            "details": "의도적 실패 테스트(잘못된 env 변수 등)로 curl 알림 확인. README.md에 'Backup crawler: Manual or UTC 12:00 daily' 추가.",
            "status": "pending",
            "testStrategy": "ALERT_WEBHOOK_URL로 실제 알림 수신 확인 및 README 내용 정확성 검증"
          }
        ]
      },
      {
        "id": 15,
        "title": "일일 AI API 호출 한도 및 비용 알림 구현",
        "description": "일일 AI API 호출 한도를 설정하고 한도 초과 시 알림을 발송하는 비용 제어 시스템 구현",
        "details": "1. 일일 API 호출 추적:\n```typescript\nconst DAILY_LIMIT = 1000; // 일일 AI API 호출 한도\n\nasync function getDailyAPIUsage(env: Env): Promise<number> {\n  const today = new Date().toISOString().split('T')[0];\n  const key = `api_usage_${today}`;\n  return parseInt(await env.AI_CACHE.get(key) || '0');\n}\n\nasync function incrementAPIUsage(env: Env, count: number = 1): Promise<number> {\n  const today = new Date().toISOString().split('T')[0];\n  const key = `api_usage_${today}`;\n  const current = await getDailyAPIUsage(env);\n  const newCount = current + count;\n  \n  // 자정에 만료되도록 TTL 설정\n  const now = new Date();\n  const midnight = new Date(now);\n  midnight.setHours(24, 0, 0, 0);\n  const ttl = Math.ceil((midnight.getTime() - now.getTime()) / 1000);\n  \n  await env.AI_CACHE.put(key, String(newCount), { expirationTtl: ttl });\n  return newCount;\n}\n```\n\n2. 한도 체크 및 알림:\n```typescript\nasync function checkAPILimit(\n  env: Env,\n  alertService: AlertService,\n  requestedCalls: number\n): Promise<boolean> {\n  const currentUsage = await getDailyAPIUsage(env);\n  \n  // 80% 경고\n  if (currentUsage >= DAILY_LIMIT * 0.8 && currentUsage < DAILY_LIMIT) {\n    await alertService.sendAlert(\n      `⚠️ AI API 사용량 80% 도달: ${currentUsage}/${DAILY_LIMIT}`\n    );\n  }\n  \n  // 한도 초과\n  if (currentUsage + requestedCalls > DAILY_LIMIT) {\n    await alertService.sendAlert(\n      `🛑 AI API 일일 한도 초과! 현재: ${currentUsage}, 요청: ${requestedCalls}, 한도: ${DAILY_LIMIT}`\n    );\n    return false; // 처리 중단\n  }\n  \n  return true;\n}\n```\n\n3. AI 처리 전 한도 체크 통합:\n```typescript\nasync function processWithAI(articles: Article[], env: Env) {\n  const canProceed = await checkAPILimit(env, alertService, articles.length);\n  if (!canProceed) {\n    console.warn('[LIMIT] Daily API limit reached, skipping AI processing');\n    return articles.map(a => ({ ...a, summary: null, category: 'uncategorized' }));\n  }\n  // ... AI 처리 진행\n}\n```",
        "testStrategy": "1. 한도 근접 시 경고 알림 발송 확인\n2. 한도 초과 시 AI 처리 스킵 및 알림 확인\n3. 일일 카운터 자정 리셋 검증\n4. 여러 크롤링 실행 시 누적 카운트 정확성 확인",
        "priority": "low",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Daily usage tracking with KV and TTL reset",
            "description": "Implement robust daily API usage tracking using Cloudflare KV with automatic midnight TTL reset for accurate daily counter reset",
            "dependencies": [],
            "details": "Enhance existing getDailyAPIUsage and incrementAPIUsage functions: 1) Add error handling for KV operations, 2) Validate TTL calculation across timezones, 3) Add logging for usage increments, 4) Handle parseInt failures gracefully with fallback to 0",
            "status": "pending",
            "testStrategy": "1. Verify counter increments correctly 2. Test TTL reset at midnight boundary 3. Confirm timezone handling (UTC/KST) 4. Validate KV get/put error scenarios"
          },
          {
            "id": 2,
            "title": "Limit checking with 80% warning thresholds",
            "description": "Implement comprehensive limit checking with multi-threshold alerting (80% warning, 100% block) using AlertService integration",
            "dependencies": [
              1
            ],
            "details": "Refine checkAPILimit function: 1) Add deduplication for 80% warnings (prevent spam), 2) Support configurable thresholds via env vars, 3) Include projected usage in alerts, 4) TypeScript interfaces for AlertService and usage data",
            "status": "pending",
            "testStrategy": "1. Test 80% warning triggers once only 2. Verify 100% limit blocking 3. Confirm alert messages contain correct usage data 4. Test with varying requestedCalls values"
          },
          {
            "id": 3,
            "title": "Integration into AI processing pipeline",
            "description": "Integrate limit checking into AI processing workflow with graceful degradation and fallback behavior when limits exceeded",
            "dependencies": [
              1,
              2
            ],
            "details": "Update processWithAI: 1) Extract alertService dependency injection, 2) Implement partial processing for large article batches, 3) Add metrics logging for skipped processing, 4) Ensure fallback returns consistent Article shape with null summary",
            "status": "pending",
            "testStrategy": "1. Verify full pipeline skip when limit exceeded 2. Test graceful degradation with uncategorized fallback 3. Confirm Article shape consistency 4. Test large batch partial processing scenarios"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-02-03T13:36:42.531Z",
      "updated": "2026-02-03T13:36:42.532Z",
      "description": "Tasks for design context"
    }
  }
}